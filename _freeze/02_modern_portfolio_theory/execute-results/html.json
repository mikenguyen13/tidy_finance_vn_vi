{
  "hash": "9af73578c55c7946b0ecee8dd73ba1bc",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Modern Portfolio Theory\nformat:\n  html:\n    toc: true\n    number-sections: true\njupyter: python3\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\nIn the previous chapter, we showed how to download and analyze stock market data with figures and summary statistics. Now, we turn to one of the most fundamental questions in finance: How should an investor allocate their wealth across assets that differ in expected returns, variance, and correlations to optimize their portfolio's performance?\n\nThis question might seem straightforward at first glance. Why not simply invest everything in the asset with the highest expected return? The answer lies in a profound insight that transformed financial economics: **risk matters, and it can be managed through diversification**.\n\nModern Portfolio Theory (MPT), introduced by @Markowitz1952, revolutionized investment decision-making by formalizing the trade-off between risk and expected return. Before Markowitz, investors largely thought about risk on a security-by-security basis. Markowitz's genius was recognizing that what matters is not the risk of individual securities in isolation, but how they contribute to the risk of the *entire portfolio*. This insight was so influential that it earned him the Sveriges Riksbank Prize in Economic Sciences in 1990 and laid the foundation for much of modern finance.\n\n### The Core Insight: Diversification as a Free Lunch\n\nMPT relies on a crucial mathematical fact: portfolio risk depends not only on individual asset volatilities but also on the *correlations* between asset returns. This insight reveals the power of diversification—combining assets whose returns don't move in perfect lockstep can reduce overall portfolio risk without necessarily sacrificing expected return.\n\nConsider a simple analogy: Imagine you run a business selling both sunscreen and umbrellas. On sunny days, sunscreen sales boom but umbrella sales suffer; on rainy days, the reverse happens. By selling both products, your total revenue becomes more stable than if you sold only one. The \"correlation\" between sunscreen and umbrella sales is negative, and combining them reduces the variance of your overall income. This is precisely the logic behind portfolio diversification.\n\nThe fruit basket analogy offers another perspective: If all you have are apples and they spoil, you lose everything. With a variety of fruits, some may spoil, but others will stay fresh. Diversification provides insurance against the idiosyncratic risks of individual assets.\n\n### The Mean-Variance Framework\n\nAt the heart of MPT is **mean-variance analysis**, which evaluates portfolios based on two dimensions:\n\n1. **Expected return (mean)**: The anticipated average profit from holding the portfolio\n2. **Risk (variance)**: The dispersion of possible returns around the expected value\n\nThe key assumption is that investors care only about these two moments of the return distribution. This assumption is exactly correct if returns are normally distributed, or if investors have quadratic utility functions. Even when these conditions don't hold precisely, mean-variance analysis often provides a good approximation to optimal portfolio choice.\n\nBy balancing expected return and risk, investors can construct portfolios that either maximize expected return for a given level of risk, or minimize risk for a desired level of expected return. In this chapter, we derive these optimal portfolio decisions analytically and implement the mean-variance approach computationally.\n\n::: {#3b4e82d1 .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport tidyfinance as tf\n\nfrom plotnine import *\nfrom mizani.formatters import percent_format\nfrom adjustText import adjust_text\n```\n:::\n\n\n## The Asset Universe: Setting Up the Problem\n\nSuppose $N$ different risky assets are available to the investor. Each asset $i$ is characterized by:\n\n- **Expected return** $\\mu_i$: The anticipated profit from holding the asset for one period\n- **Variance** $\\sigma_i^2$: The dispersion of returns around the mean\n- **Covariances** $\\sigma_{ij}$: The degree to which asset $i$'s returns move together with asset $j$'s returns\n\nThe investor chooses **portfolio weights** $\\omega_i$ for each asset $i$. These weights represent the fraction of total wealth invested in each asset. We impose the constraint that weights sum to one:\n\n$$\n\\sum_{i=1}^N \\omega_i = 1\n$$\n\nThis \"budget constraint\" ensures that the investor is fully invested—there is no outside option such as keeping money under a mattress. Note that we allow weights to be negative (short selling) or greater than one (leverage), though in practice these positions may face constraints.\n\n### The Two Stages of Portfolio Selection\n\nAccording to @Markowitz1952, portfolio selection involves two distinct stages:\n\n1. **Estimation**: Forming expectations about future security performance based on observations, experience, and economic reasoning\n2. **Optimization**: Using these expectations to choose an optimal portfolio\n\nIn practice, these stages cannot be fully separated. The estimation stage determines the inputs ($\\mu$, $\\Sigma$) that feed into the optimization stage. Poor estimation leads to poor portfolio choices, regardless of how sophisticated the optimization procedure.\n\nTo keep things conceptually clear, we focus primarily on the optimization stage in this chapter. We treat the expected returns and variance-covariance matrix as known, using historical data to compute reasonable proxies. In later chapters, we address the substantial challenges that arise from estimation uncertainty.\n\n### Loading and Preparing the Data\n\nWe work with the VN30 index constituents—the 30 largest and most liquid stocks on Vietnam's Ho Chi Minh Stock Exchange. This provides a realistic asset universe for a domestic Vietnamese investor.\n\n::: {#b3b37062 .cell execution_count=3}\n``` {.python .cell-code}\nvn30_symbols = [\n    \"ACB\",\"BCM\",\"BID\",\"BVH\",\"CTG\",\"FPT\",\"GAS\",\"GVR\",\"HDB\",\"HPG\",\n    \"MBB\",\"MSN\",\"MWG\",\"PLX\",\"POW\",\"SAB\",\"SHB\",\"SSB\",\"STB\",\"TCB\",\n    \"TPB\",\"VCB\",\"VHM\",\"VIB\",\"VIC\",\"VJC\",\"VNM\",\"VPB\",\"VRE\",\"EIB\"\n]\n```\n:::\n\n\nWe load the historical price data:\n\n::: {#e36d83a3 .cell execution_count=4}\n``` {.python .cell-code}\nimport pandas as pd\nfrom io import BytesIO\nimport datetime as dt\nimport os\nimport boto3\nfrom botocore.client import Config\n\nclass ConnectMinio:\n    def __init__(self):\n        self.MINIO_ENDPOINT = os.environ[\"MINIO_ENDPOINT\"]\n        self.MINIO_ACCESS_KEY = os.environ[\"MINIO_ACCESS_KEY\"]\n        self.MINIO_SECRET_KEY = os.environ[\"MINIO_SECRET_KEY\"]\n        self.REGION = os.getenv(\"MINIO_REGION\", \"us-east-1\")\n\n        self.s3 = boto3.client(\n            \"s3\",\n            endpoint_url=self.MINIO_ENDPOINT,\n            aws_access_key_id=self.MINIO_ACCESS_KEY,\n            aws_secret_access_key=self.MINIO_SECRET_KEY,\n            region_name=self.REGION,\n            config=Config(signature_version=\"s3v4\"),\n        )\n\n    def test_connection(self):\n        resp = self.s3.list_buckets()\n        print(\"Connected. Buckets:\")\n        for b in resp.get(\"Buckets\", []):\n            print(\" -\", b[\"Name\"])\n\nconn = ConnectMinio()\ns3 = conn.s3\nconn.test_connection()\n\nbucket_name = os.environ[\"MINIO_BUCKET\"]\n\nprices = pd.read_csv(\n    BytesIO(\n        s3.get_object(\n            Bucket=bucket_name,\n            Key=\"historycal_price/dataset_historical_price.csv\"\n        )[\"Body\"].read()\n    ),\n    low_memory=False\n)\n\nprices[\"date\"] = pd.to_datetime(prices[\"date\"])\nprices[\"adjusted_close\"] = prices[\"close_price\"] * prices[\"adj_ratio\"]\nprices = prices.rename(columns={\n    \"vol_total\": \"volume\",\n    \"open_price\": \"open\",\n    \"low_price\": \"low\",\n    \"high_price\": \"high\",\n    \"close_price\": \"close\"\n})\nprices = prices.sort_values([\"symbol\", \"date\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConnected. Buckets:\n - dsteam-data\n - rawbctc\n```\n:::\n:::\n\n\nWe filter to keep only the VN30 constituents:\n\n::: {#62d4c730 .cell execution_count=5}\n``` {.python .cell-code}\nprices_daily = prices[prices[\"symbol\"].isin(vn30_symbols)]\nprices_daily[[\"date\", \"symbol\", \"adjusted_close\"]].head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>date</th>\n      <th>symbol</th>\n      <th>adjusted_close</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>18176</th>\n      <td>2010-01-04</td>\n      <td>ACB</td>\n      <td>329.408244</td>\n    </tr>\n    <tr>\n      <th>18177</th>\n      <td>2010-01-05</td>\n      <td>ACB</td>\n      <td>329.408244</td>\n    </tr>\n    <tr>\n      <th>18178</th>\n      <td>2010-01-06</td>\n      <td>ACB</td>\n      <td>320.258015</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Computing Expected Returns\n\nThe sample mean return serves as our proxy for expected returns. For each asset $i$, we compute:\n\n$$\n\\hat{\\mu}_i = \\frac{1}{T} \\sum_{t=1}^{T} r_{i,t}\n$$\n\nwhere $r_{i,t}$ is the return of asset $i$ in period $t$, and $T$ is the total number of periods.\n\n**Why monthly returns?** While daily data provides more observations, monthly returns offer several advantages for portfolio optimization. First, monthly returns are less noisy and exhibit weaker serial correlation. Second, monthly rebalancing is more realistic for most investors, avoiding excessive transaction costs. Third, the estimation error in mean returns is already substantial—using daily data doesn't materially improve the precision of mean estimates because the mean return scales with the horizon while estimation error scales with the square root of observations.\n\n::: {#14eb91f6 .cell execution_count=6}\n``` {.python .cell-code}\nreturns_monthly = (prices_daily\n  .assign(\n    date=prices_daily[\"date\"].dt.to_period(\"M\").dt.to_timestamp()\n  )\n  .groupby([\"symbol\", \"date\"], as_index=False)\n  .agg(adjusted_close=(\"adjusted_close\", \"last\"))\n  .assign(\n    ret=lambda x: x.groupby(\"symbol\")[\"adjusted_close\"].pct_change()\n  )\n)\n```\n:::\n\n\n### Computing Volatilities\n\nIndividual asset risk in MPT is quantified using variance ($\\sigma^2_i$) or its square root, the standard deviation or volatility ($\\sigma_i$). We use the sample standard deviation as our proxy:\n\n$$\n\\hat{\\sigma}_i = \\sqrt{\\frac{1}{T-1} \\sum_{t=1}^{T} (r_{i,t} - \\hat{\\mu}_i)^2}\n$$\n\nAlternative risk measures exist, including Value-at-Risk, Expected Shortfall, and higher-order moments such as skewness and kurtosis. However, variance remains the workhorse measure in portfolio theory because of its mathematical tractability and the central role of the normal distribution in finance.\n\n::: {#569e0765 .cell execution_count=7}\n``` {.python .cell-code}\nassets = (returns_monthly\n  .groupby(\"symbol\", as_index=False)\n  .agg(\n    mu=(\"ret\", \"mean\"),\n    sigma=(\"ret\", \"std\")\n  )\n)\n```\n:::\n\n\n### Visualizing the Risk-Return Trade-off\n\n@fig-201 displays each asset's expected return (vertical axis) against its volatility (horizontal axis). This \"mean-standard deviation\" space is fundamental to portfolio theory.\n\n::: {#cell-fig-201 .cell execution_count=8}\n``` {.python .cell-code}\nassets_figure = (\n  ggplot(\n    assets, \n    aes(x=\"sigma\", y=\"mu\", label=\"symbol\")\n  )\n  + geom_point()\n  + geom_text(adjust_text={\"arrowprops\": {\"arrowstyle\": \"-\"}})\n  + scale_x_continuous(labels=percent_format())\n  + scale_y_continuous(labels=percent_format())\n  + labs(\n      x=\"Volatility (Standard Deviation)\", \n      y=\"Expected Return\",\n      title=\"Expected returns and volatilities of VN30 index constituents\"\n  )\n)\nassets_figure.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Expected returns and volatilities based on monthly returns adjusted for dividend payments and stock splits.](02_modern_portfolio_theory_files/figure-html/fig-201-output-1.png){#fig-201 width=672 height=480 fig-alt='Title: Expected returns and volatilities of VN30 index constituents. The figure is a scatter plot with volatilities on the horizontal and expected returns on the vertical axis.'}\n:::\n:::\n\n\nSeveral observations emerge from this figure. First, there is substantial heterogeneity in both expected returns and volatilities across stocks. Second, the relationship between risk and return is far from linear. Some high-volatility stocks have low or even negative expected returns. Third, most individual stocks appear to offer poor risk-return trade-offs. As we will see, portfolios can substantially improve upon these individual positions.\n\n## The Variance-Covariance Matrix: Capturing Asset Interactions\n\n### Why Correlations Matter\n\nA key innovation of MPT is recognizing that portfolio risk depends critically on how assets move together. The **variance-covariance matrix** $\\Sigma$ captures all pairwise interactions between asset returns.\n\nTo understand why correlations matter, consider the variance of a two-asset portfolio:\n$$\\sigma_p^2 = \\omega_1^2\\sigma_1^2 + \\omega_2^2\\sigma_2^2 + 2\\omega_1\\omega_2\\sigma_{12}$$\n\nThe third term involves the covariance $\\sigma_{12} = \\rho_{12}\\sigma_1\\sigma_2$, where $\\rho_{12}$ is the correlation coefficient. When $\\rho_{12} < 1$, the portfolio variance is *less* than the weighted average of individual variances. When $\\rho_{12} < 0$, the diversification benefit is even more pronounced.\n\nThis mathematical fact has profound implications: **You can reduce risk without reducing expected return** by combining assets that don't move perfectly together. This is sometimes called the \"only free lunch in finance.\"\n\n### Computing the Variance-Covariance Matrix\n\nWe compute the sample covariance matrix as:\n$$\\hat{\\sigma}_{ij} = \\frac{1}{T-1} \\sum_{t=1}^{T} (r_{i,t} - \\hat{\\mu}_i)(r_{j,t} - \\hat{\\mu}_j)$$\n\nFirst, we reshape the returns data into a wide format with assets as columns:\n\n::: {#45a6ff99 .cell execution_count=9}\n``` {.python .cell-code}\nreturns_wide = (returns_monthly\n  .pivot(index=\"date\", columns=\"symbol\", values=\"ret\")\n  .reset_index()\n)\n\nsigma = (returns_wide\n  .drop(columns=[\"date\"])\n  .cov()\n)\n```\n:::\n\n\n### Interpreting the Variance-Covariance Matrix\n\nThe diagonal elements of $\\Sigma$ are the variances of individual assets. The off-diagonal elements are covariances, which can be positive (assets tend to move together), negative (assets tend to move in opposite directions), or zero (no linear relationship).\n\nFor easier interpretation, we often convert covariances to correlations:\n$$\\rho_{ij} = \\frac{\\sigma_{ij}}{\\sigma_i \\sigma_j}$$\n\nCorrelations are bounded between -1 and +1, making them easier to compare across asset pairs.\n\n@fig-203 visualizes the variance-covariance matrix as a heatmap.\n\n::: {#cell-fig-203 .cell execution_count=10}\n``` {.python .cell-code}\nsigma_long = (sigma\n  .reset_index()\n  .melt(id_vars=\"symbol\", var_name=\"symbol_b\", value_name=\"value\")\n)\n\nsigma_long[\"symbol_b\"] = pd.Categorical(\n  sigma_long[\"symbol_b\"], \n  categories=sigma_long[\"symbol_b\"].unique()[::-1],\n  ordered=True\n)\n\nsigma_figure = (\n  ggplot(\n    sigma_long, \n    aes(x=\"symbol\", y=\"symbol_b\", fill=\"value\")\n  )\n  + geom_tile()\n  + labs(\n      x=\"\", y=\"\", fill=\"(Co-)Variance\",\n      title=\"Sample variance-covariance matrix of VN30 index constituents\"\n    )\n  + scale_fill_continuous(labels=percent_format())\n  + theme(axis_text_x=element_text(angle=45, hjust=1))\n)\nsigma_figure.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Variances and covariances based on monthly returns adjusted for dividend payments and stock splits.](02_modern_portfolio_theory_files/figure-html/fig-203-output-1.png){#fig-203 width=672 height=480 fig-alt='Title: Variance-covariance matrix of VN30 index constituents.'}\n:::\n:::\n\n\nThe heatmap reveals important patterns. The diagonal (variances) shows which stocks are most volatile. The off-diagonal patterns show which pairs of stocks tend to move together. In general, stocks within the same sector tend to have higher correlations with each other than with stocks from different sectors.\n\n## The Minimum-Variance Portfolio\n\n### Motivation: Risk Minimization as a Benchmark\n\nBefore considering expected returns, let's find the portfolio that minimizes risk entirely. This **minimum-variance portfolio (MVP)** serves as an important benchmark and reference point. It represents what an extremely risk-averse investor—one who cares only about minimizing volatility—would choose.\n\n### The Optimization Problem\n\nThe minimum-variance investor solves:\n$$\n\\min_{\\omega} \\omega^{\\prime}\\Sigma\\omega\n$$\n\nsubject to the constraint that weights sum to one:\n\n$$\n\\omega^{\\prime}\\iota = 1\n$$\n\nwhere $\\iota$ is an $N \\times 1$ vector of ones.\n\nIn words: minimize portfolio variance, subject to being fully invested.\n\n### The Analytical Solution\n\nThis is a classic constrained optimization problem that can be solved using Lagrange multipliers. The Lagrangian is:\n\n$$\n\\mathcal{L} = \\omega^{\\prime}\\Sigma\\omega - \\lambda(\\omega^{\\prime}\\iota - 1)\n$$\n\nTaking the first-order condition with respect to $\\omega$:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\omega} = 2\\Sigma\\omega - \\lambda\\iota = 0\n$$\n\nSolving for $\\omega$:\n$$\n\\omega = \\frac{\\lambda}{2}\\Sigma^{-1}\\iota\n$$\n\nUsing the constraint $\\omega^{\\prime}\\iota = 1$ to solve for $\\lambda$:\n$$\n\\frac{\\lambda}{2}\\iota^{\\prime}\\Sigma^{-1}\\iota = 1 \\implies \\frac{\\lambda}{2} = \\frac{1}{\\iota^{\\prime}\\Sigma^{-1}\\iota}\n$$\n\nSubstituting back:\n$$\n\\omega_{\\text{mvp}} = \\frac{\\Sigma^{-1}\\iota}{\\iota^{\\prime}\\Sigma^{-1}\\iota}\n$$\n\nThis elegant formula shows that the minimum-variance weights depend only on the covariance matrix—expected returns play no role. The inverse covariance matrix $\\Sigma^{-1}$ determines how much to invest in each asset based on its variance and its covariances with all other assets.\n\n### Implementation\n\n::: {#0c47eef1 .cell execution_count=11}\n``` {.python .cell-code}\niota = np.ones(sigma.shape[0])\nsigma_inv = np.linalg.inv(sigma.values)\nomega_mvp = (sigma_inv @ iota) / (iota @ sigma_inv @ iota)\n```\n:::\n\n\n### Visualizing the Minimum-Variance Weights\n\n@fig-204 displays the portfolio weights of the minimum-variance portfolio.\n\n::: {#cell-fig-204 .cell execution_count=12}\n``` {.python .cell-code}\nassets = assets.assign(omega_mvp=omega_mvp)\n\nassets[\"symbol\"] = pd.Categorical(\n  assets[\"symbol\"],\n  categories=assets.sort_values(\"omega_mvp\")[\"symbol\"],\n  ordered=True\n)\n\nomega_figure = (\n  ggplot(\n    assets,\n    aes(y=\"omega_mvp\", x=\"symbol\", fill=\"omega_mvp>0\")\n  )\n  + geom_col()\n  + coord_flip()\n  + scale_y_continuous(labels=percent_format())\n  + labs(\n      x=\"\", \n      y=\"Portfolio Weight\", \n      title=\"Minimum-variance portfolio weights\"\n  )\n  + theme(legend_position=\"none\")\n)\nomega_figure.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Weights are based on historical moments of monthly returns adjusted for dividend payments and stock splits.](02_modern_portfolio_theory_files/figure-html/fig-204-output-1.png){#fig-204 width=672 height=480 fig-alt='Title: Minimum-variance portfolio weights. The figure shows a bar chart with portfolio weights for each VN30 index constituent.'}\n:::\n:::\n\n\nSeveral features of the minimum-variance portfolio are noteworthy. First, many stocks receive zero or near-zero weights. Second, some stocks receive negative weights (short positions). These short positions are not a computational artifact, they reflect the optimizer's attempt to exploit correlations for risk reduction. Third, the weights are quite extreme (both large positive and large negative), which often indicates estimation error amplification, which is a topic we address in later chapters.\n\n### Portfolio Performance\n\nLet's compute the expected return and volatility of the minimum-variance portfolio:\n\n::: {#fa2c23c7 .cell execution_count=13}\n``` {.python .cell-code}\nmu = assets[\"mu\"].values\nmu_mvp = omega_mvp @ mu\nsigma_mvp = np.sqrt(omega_mvp @ sigma.values @ omega_mvp)\n\nsummary_mvp = pd.DataFrame({\n  \"mu\": [mu_mvp],\n  \"sigma\": [sigma_mvp],\n  \"type\": [\"Minimum-Variance Portfolio\"]\n})\nsummary_mvp\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>mu</th>\n      <th>sigma</th>\n      <th>type</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>-0.011424</td>\n      <td>0.043512</td>\n      <td>Minimum-Variance Portfolio</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#05ee521a .cell execution_count=14}\n``` {.python .cell-code}\nmu_mvp_fmt = f\"{mu_mvp:.4f}\"\nsigma_mvp_fmt = f\"{sigma_mvp:.4f}\"\nprint(f\"The MVP return is {mu_mvp_fmt} and volatility is {sigma_mvp_fmt}.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe MVP return is -0.0114 and volatility is 0.0435.\n```\n:::\n:::\n\n\nIf the expected return is negative, this is not a computational error. The minimum-variance portfolio minimizes risk without regard to expected returns. Because some assets in the sample have negative average returns, the risk-minimizing combination may inherit a negative expected return. This highlights a fundamental limitation of using historical sample means as estimates of expected returns: they are extremely noisy, and can lead to economically unintuitive results even when the optimization mathematics are working correctly.\n\n## Efficient Portfolios: Balancing Risk and Return\n\n### The Investor's Trade-off\n\nIn most cases, minimizing variance is not the investor's sole objective. A more realistic formulation allows the investor to trade off risk against expected return. The investor might be willing to accept higher portfolio variance in exchange for higher expected returns.\n\nAn **efficient portfolio** minimizes variance subject to earning at least some target expected return $\\bar{\\mu}$. Formally:\n\n$$\\min_{\\omega} \\omega^{\\prime}\\Sigma\\omega$$\n\nsubject to:\n$$\\omega^{\\prime}\\iota = 1 \\quad \\text{(fully invested)}$$\n$$\\omega^{\\prime}\\mu \\geq \\bar{\\mu} \\quad \\text{(minimum return)}$$\n\nWhen $\\bar{\\mu}$ exceeds the expected return of the minimum-variance portfolio, the investor accepts more risk to earn more return.\n\n### Setting the Target Return\n\nFor illustration, suppose the investor wants to earn at least the historical average return of the best-performing stock:\n\n::: {#e7b79a0d .cell execution_count=15}\n``` {.python .cell-code}\nmu_bar = assets[\"mu\"].max()\nprint(f\"Target expected return: {mu_bar:.5f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTarget expected return: 0.01886\n```\n:::\n:::\n\n\nThis is an ambitious target—it means matching the return of the single highest-returning stock while benefiting from diversification to reduce risk.\n\n### The Analytical Solution\n\nThe constrained optimization problem with an inequality constraint on expected returns can be solved using the Karush-Kuhn-Tucker (KKT) conditions. At the optimum (assuming the return constraint binds), the solution is:\n\n$$\\omega_{\\text{efp}} = \\frac{\\lambda^*}{2}\\left(\\Sigma^{-1}\\mu - \\frac{D}{C}\\Sigma^{-1}\\iota\\right)$$\n\nwhere:\n\n- $C = \\iota^{\\prime}\\Sigma^{-1}\\iota$ (a scalar measuring the \"size\" of the inverse covariance matrix)\n- $D = \\iota^{\\prime}\\Sigma^{-1}\\mu$ (capturing the interaction between expected returns and the inverse covariance matrix)\n- $E = \\mu^{\\prime}\\Sigma^{-1}\\mu$ (measuring the \"signal\" in expected returns weighted by inverse covariances)\n- $\\lambda^* = 2\\frac{\\bar{\\mu} - D/C}{E - D^2/C}$ (the shadow price of the return constraint)\n\nAlternatively, we can express the efficient portfolio as a linear combination of the minimum-variance portfolio and an \"excess return\" portfolio:\n\n$$\\omega_{\\text{efp}} = \\omega_{\\text{mvp}} + \\frac{\\lambda^*}{2}\\left(\\Sigma^{-1}\\mu - D \\cdot \\omega_{\\text{mvp}}\\right)$$\n\nThis representation reveals important intuition: the efficient portfolio starts from the minimum-variance portfolio and tilts toward higher-expected-return assets, with the tilt magnitude determined by $\\lambda^*$.\n\n### Implementation\n\n::: {#03edc9a8 .cell execution_count=16}\n``` {.python .cell-code}\nC = iota @ sigma_inv @ iota\nD = iota @ sigma_inv @ mu\nE = mu @ sigma_inv @ mu\nlambda_tilde = 2 * (mu_bar - D / C) / (E - (D ** 2) / C)\nomega_efp = omega_mvp + (lambda_tilde / 2) * (sigma_inv @ mu - D * omega_mvp)\n\nmu_efp = omega_efp @ mu\nsigma_efp = np.sqrt(omega_efp @ sigma.values @ omega_efp)\n\nsummary_efp = pd.DataFrame({\n  \"mu\": [mu_efp],\n  \"sigma\": [sigma_efp],\n  \"type\": [\"Efficient Portfolio\"]\n})\n```\n:::\n\n\n### Comparing the Portfolios\n\n@fig-205 plots both portfolios alongside the individual assets.\n\n::: {#cell-fig-205 .cell execution_count=17}\n``` {.python .cell-code}\nsummaries = pd.concat(\n  [assets, summary_mvp, summary_efp], ignore_index=True\n)\n\nsummaries_figure = (\n  ggplot(\n    summaries, \n    aes(x=\"sigma\", y=\"mu\")\n  )\n  + geom_point(data=summaries.query(\"type.isna()\"))\n  + geom_point(data=summaries.query(\"type.notna()\"), color=\"#F21A00\", size=3)\n  + geom_label(aes(label=\"type\"), adjust_text={\"arrowprops\": {\"arrowstyle\": \"-\"}})\n  + scale_x_continuous(labels=percent_format())\n  + scale_y_continuous(labels=percent_format())\n  + labs(\n      x=\"Volatility (Standard Deviation)\", \n      y=\"Expected Return\",\n      title=\"Efficient & minimum-variance portfolios\"\n    ) \n)\nsummaries_figure.show()\n```\n\n::: {.cell-output .cell-output-display}\n![The big dots indicate the location of the minimum-variance and the efficient portfolio that delivers the expected return of the stock with the highest return, respectively. The small dots indicate the location of the individual constituents.](02_modern_portfolio_theory_files/figure-html/fig-205-output-1.png){#fig-205 width=672 height=480 fig-alt='Title: Efficient & minimum-variance portfolios. The figure shows big dots indicating the location of the minimum-variance and the efficient portfolio that delivers the expected return of the stock with the higehst return, respectively. The small dots indicate the location of the individual constituents.'}\n:::\n:::\n\n\nThe figure demonstrates the substantial diversification benefits of portfolio optimization. The efficient portfolio achieves the same expected return as the highest-returning individual stock but with substantially lower volatility. This \"free lunch\" from diversification is the central insight of Modern Portfolio Theory.\n\n### The Role of Risk Aversion\n\nThe target return $\\bar{\\mu}$ implicitly reflects the investor's risk aversion. Less risk-averse investors choose higher $\\bar{\\mu}$, accepting more variance to earn more expected return. More risk-averse investors choose $\\bar{\\mu}$ closer to the minimum-variance portfolio's expected return.\n\nEquivalently, the mean-variance framework can be derived from the optimal decisions of an investor with a mean-variance utility function:\n$$U(\\omega) = \\omega^{\\prime}\\mu - \\frac{\\gamma}{2}\\omega^{\\prime}\\Sigma\\omega$$\n\nwhere $\\gamma$ is the coefficient of relative risk aversion. The Appendix shows there is a one-to-one mapping between $\\gamma$ and $\\bar{\\mu}$, so both formulations yield identical efficient portfolios.\n\n## The Efficient Frontier: The Menu of Optimal Portfolios\n\nThe **efficient frontier** is the set of all portfolios for which no other portfolio offers higher expected return at the same or lower variance. Geometrically, it traces the upper boundary of achievable (volatility, expected return) combinations.\n\nEvery rational mean-variance investor should hold a portfolio on the efficient frontier. Portfolios below the frontier are \"dominated,\" there exists another portfolio with either higher return for the same risk, or lower risk for the same return.\n\n### The Mutual Fund Separation Theorem\n\nA remarkable result simplifies the construction of the efficient frontier. The **mutual fund separation theorem** (sometimes called the two-fund theorem) states that any efficient portfolio can be expressed as a linear combination of any two distinct efficient portfolios.\n\nFormally, if $\\omega_{\\mu_1}$ and $\\omega_{\\mu_2}$ are efficient portfolios earning expected returns $\\mu_1$ and $\\mu_2$ respectively, then the portfolio:\n$$\\omega_{a\\mu_1 + (1-a)\\mu_2} = a \\cdot \\omega_{\\mu_1} + (1-a) \\cdot \\omega_{\\mu_2}$$\n\nis also efficient and earns expected return $a\\mu_1 + (1-a)\\mu_2$.\n\nThis result has profound practical implications: an investor needs access to only two efficient \"mutual funds\" to construct any portfolio on the efficient frontier. The specific funds don't matter—any two distinct efficient portfolios span the entire frontier.\n\n### Proof of the Separation Theorem\n\nThe proof follows directly from the analytical solution for efficient portfolios. Consider:\n\n$$\na \\cdot \\omega_{\\mu_1} + (1-a) \\cdot \\omega_{\\mu_2} = \\left(\\frac{a\\mu_1 + (1-a)\\mu_2 - D/C}{E - D^2/C}\\right)\\left(\\Sigma^{-1}\\mu - \\frac{D}{C}\\Sigma^{-1}\\iota\\right)\n$$\n\nThis expression has exactly the form of the efficient portfolio earning expected return $a\\mu_1 + (1-a)\\mu_2$, proving the theorem.\n\n### Computing the Efficient Frontier\n\nUsing the minimum-variance portfolio and our efficient portfolio as the two \"funds,\" we can trace out the entire efficient frontier:\n\n::: {#1b1bed24 .cell execution_count=18}\n``` {.python .cell-code}\nefficient_frontier = (\n  pd.DataFrame({\n    \"a\": np.arange(-1, 2.01, 0.01)\n  })\n  .assign(\n    omega=lambda x: x[\"a\"].map(lambda a: a * omega_efp + (1 - a) * omega_mvp)\n  )\n  .assign(\n    mu=lambda x: x[\"omega\"].map(lambda w: w @ mu),\n    sigma=lambda x: x[\"omega\"].map(lambda w: np.sqrt(w @ sigma @ w))\n  )\n)\n```\n:::\n\n\nNote that we allow $a$ to range from -1 to 2, which means some portfolios involve shorting one of the two basis funds and leveraging into the other. This traces out both the upper and lower portions of the frontier hyperbola.\n\n### Visualizing the Efficient Frontier\n\n@fig-206 displays the efficient frontier alongside individual assets and the benchmark portfolios.\n\n::: {#cell-fig-206 .cell execution_count=19}\n``` {.python .cell-code}\nsummaries = pd.concat(\n  [summaries, efficient_frontier], ignore_index=True\n)\n\nsummaries_figure = (\n  ggplot(\n    summaries, \n    aes(x=\"sigma\", y=\"mu\")\n  )\n  + geom_point(data=summaries.query(\"type.isna()\"))\n  + geom_line(data=efficient_frontier, color=\"blue\", alpha=0.7)\n  + geom_point(data=summaries.query(\"type.notna()\"), color=\"#F21A00\", size=3)\n  + geom_label(aes(label=\"type\"), adjust_text={\"arrowprops\": {\"arrowstyle\": \"-\"}})\n  + scale_x_continuous(labels=percent_format())\n  + scale_y_continuous(labels=percent_format())\n  + labs(\n      x=\"Volatility (Standard Deviation)\", \n      y=\"Expected Return\",\n      title=\"The Efficient Frontier and VN30 Constituents\"\n    ) \n)\nsummaries_figure.show()\n```\n\n::: {.cell-output .cell-output-display}\n![The big dots indicate the location of the minimum-variance and the efficient portfolio. The small dots indicate the location of the individual constituents.](02_modern_portfolio_theory_files/figure-html/fig-206-output-1.png){#fig-206 width=672 height=480 fig-alt='Title: Efficient frontier constructed from historical data for VN30 index constituents. The figure shows VN30 index constituents in a mean-variance diagram. A hyperbola indicates the efficient frontier of portfolios that dominate the individual holdings in the sense that they deliver higher expected returns for the same level of volatility.'}\n:::\n:::\n\n\nThe efficient frontier has a characteristic hyperbolic shape. The leftmost point is the minimum-variance portfolio. Moving up and to the right along the frontier, expected return increases but so does volatility. The upper portion of the hyperbola (above the minimum-variance portfolio) is the \"efficient\" part—these portfolios offer the highest return for each level of risk. The lower portion is \"inefficient\"—these portfolios are dominated by their mirror images on the upper portion.\n\nThe figure also reveals how dramatically diversification improves upon individual stock positions. Nearly all individual stocks lie well inside the efficient frontier, meaning investors can achieve the same expected return with much less risk, or much higher expected return with the same risk, simply by diversifying.\n\n## Key Takeaways\n\nThis chapter introduced the concepts of Modern Portfolio Theory. The main insights are:\n\n1. **Portfolio risk depends on correlations**: The variance of a portfolio is not simply the weighted average of individual variances. Covariances between assets play a crucial role, creating opportunities for diversification.\n\n2. **Diversification is the \"only free lunch\" in finance**: By combining assets that don't move perfectly together, investors can reduce risk without sacrificing expected return. This insight is the cornerstone of modern investment practice.\n\n3. **The minimum-variance portfolio minimizes risk**: This portfolio depends only on the covariance matrix and serves as an important benchmark. It represents the least risky way to be fully invested in risky assets.\n\n4. **Efficient portfolios balance risk and return**: By accepting more variance, investors can earn higher expected returns. Efficient portfolios are those that offer the best possible trade-off.\n\n5. **The efficient frontier characterizes optimal portfolios**: This boundary in mean-standard deviation space represents the menu of optimal choices available to mean-variance investors.\n\n6. **Two-fund separation simplifies implementation**: Any efficient portfolio can be constructed from any two distinct efficient portfolios, reducing the computational burden of portfolio optimization.\n\nLooking ahead, several important complications arise in practice. First, the inputs to portfolio optimization (expected returns and covariances) must be estimated from data, and estimation error can dramatically affect portfolio performance. Second, real-world constraints such as transaction costs, short-sale restrictions, and position limits modify the optimization problem. Third, the assumption that investors care only about mean and variance may be too restrictive when returns are non-normal or when investors have more complex preferences. We address these extensions in subsequent chapters.\n\n",
    "supporting": [
      "02_modern_portfolio_theory_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}