{
  "hash": "965ecf2d83d540b84c5e88ef8ec49357",
  "result": {
    "engine": "jupyter",
    "markdown": "# Market Integration and Segmentation\n\n::: callout-note\nIn this chapter, we measure the degree to which the Vietnamese equity market is integrated with or segmented from global capital markets. We construct multiple integration metrics, including correlation-based, factor-based, and pricing-error-based, trace their evolution through Vietnam's liberalization timeline, and quantify the cost of segmentation for Vietnamese firms.\n:::\n\nA market is *fully integrated* when its assets are priced by a global stochastic discount factor: risk premia reflect only exposures to global risk factors, and identical cash flow streams command the same expected return regardless of where the issuer is domiciled. A market is *fully segmented* when domestic risk factors alone determine prices, and the country's risk-return trade-off is independent of the rest of the world. Reality sits somewhere between these poles, and the location shifts over time.\n\nVietnam is a particularly interesting case. It opened its stock exchange in July 2000 with heavy restrictions on foreign participation. Foreign ownership limits (initially 20%, raised to 30% in 2003, 49% in 2015, and selectively removed for some firms) have been gradually relaxed. Vietnam joined the WTO in 2007. FTSE Russell upgraded Vietnam from \"unclassified\" to \"secondary emerging\" in its frontier index in 2018 and has been evaluating further upgrades. Each of these events has potentially shifted the degree of integration.\n\n@bekaert1995time and @bekaert2002research establish the modern framework for measuring time-varying integration. @errunza1985international develop the \"mild segmentation\" model in which foreign investors face barriers but can partially replicate emerging market returns through global securities. @pukthuanthong2009global propose a factor-model-based measure that avoids the pitfalls of simple correlation analysis. This chapter implements all three approaches and applies them to Vietnam's integration trajectory.\n\n## Integration in Theory {#sec-market-integration-theory}\n\n### The Integrated and Segmented Benchmarks\n\nUnder full integration, the expected excess return of Vietnamese stock $i$ is:\n\n$$\nE[R_{i,t} - R_{f,t}] = \\beta_{i,\\text{world}} \\cdot \\lambda_{\\text{world},t}\n$$ {#eq-integrated}\n\nwhere $\\beta_{i,\\text{world}}$ is the stock's loading on the global market factor and $\\lambda_{\\text{world},t}$ is the global risk premium. Only global systematic risk is priced; country-specific risk is diversifiable and commands no premium.\n\nUnder full segmentation:\n\n$$\nE[R_{i,t} - R_{f,t}] = \\beta_{i,\\text{local}} \\cdot \\lambda_{\\text{local},t}\n$$ {#eq-segmented}\n\nwhere $\\beta_{i,\\text{local}}$ is the stock's loading on the Vietnamese market and $\\lambda_{\\text{local},t}$ is the domestic risk premium. The domestic market is effectively a closed economy for pricing purposes.\n\n@bekaert1995time model the transition between these states as a regime-switching process where the mixing weight $\\omega_t \\in [0, 1]$ evolves over time:\n\n$$\nE[R_{i,t} - R_{f,t}] = \\omega_t \\cdot \\beta_{i,\\text{world}} \\lambda_{\\text{world},t} + (1 - \\omega_t) \\cdot \\beta_{i,\\text{local}} \\lambda_{\\text{local},t}\n$$ {#eq-partial}\n\nThe weight $\\omega_t$ is the *degree of integration*: $\\omega_t = 1$ is full integration, $\\omega_t = 0$ is full segmentation.\n\n### The Segmentation Premium\n\nWhen a market transitions from segmented to integrated, its cost of capital falls because the relevant risk for pricing narrows from total domestic risk to only the portion correlated with the global market [@henry2000stock; @bekaert2005does]. The *segmentation premium* is the excess expected return that investors in a segmented market require:\n\n$$\n\\text{Segmentation premium} = (1 - \\omega_t) \\cdot (\\lambda_{\\text{local}} - \\beta_{\\text{local,world}} \\cdot \\lambda_{\\text{world}})\n$$ {#eq-segmentation-premium}\n\nThis premium represents a deadweight cost: it raises the cost of capital for Vietnamese firms, reduces investment, and lowers welfare relative to the integrated benchmark.\n\n## Data Construction {#sec-market-integration-data}\n\n::: {#setup .cell execution_count=1}\n``` {.python .cell-code code-summary=\"Import libraries and configure environment\"}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport statsmodels.api as sm\nfrom scipy import stats, optimize\nfrom arch import arch_model\nfrom arch.univariate import ConstantMean, GARCH\nimport warnings\nwarnings.filterwarnings('ignore')\n\nplt.rcParams.update({\n    'figure.figsize': (12, 6),\n    'figure.dpi': 150,\n    'font.size': 11,\n    'axes.spines.top': False,\n    'axes.spines.right': False\n})\n```\n:::\n\n\n::: {#data-load .cell execution_count=2}\n``` {.python .cell-code code-summary=\"Load Vietnamese and global market data\"}\nfrom datacore import DataCoreClient\n\nclient = DataCoreClient()\n\n# Vietnamese market returns\nvn_index = client.get_index_returns(\n    index='VNINDEX',\n    start_date='2000-07-01',\n    end_date='2024-12-31',\n    frequency='monthly',\n    fields=['date', 'return', 'total_return_index']\n)\nvn_index['date'] = pd.to_datetime(vn_index['date'])\nvn_index = vn_index.set_index('date')\n\n# Global and regional indices (USD-denominated for comparability)\nglobal_indices = client.get_global_indices(\n    indices=[\n        'MSCI_WORLD', 'MSCI_EM', 'MSCI_ASIA_PAC_EX_JP',\n        'MSCI_FM',  # Frontier markets\n        'SP500', 'STOXX600',\n        'MSCI_CHINA', 'MSCI_THAILAND', 'MSCI_INDONESIA',\n        'MSCI_PHILIPPINES', 'MSCI_MALAYSIA'\n    ],\n    start_date='2000-07-01',\n    end_date='2024-12-31',\n    frequency='monthly',\n    currency='USD'\n)\nglobal_indices['date'] = pd.to_datetime(global_indices['date'])\nglobal_indices = global_indices.pivot(index='date', columns='index', values='return')\n\n# Vietnam returns in USD for apples-to-apples comparison\nvn_usd = client.get_index_returns(\n    index='VNINDEX',\n    start_date='2000-07-01',\n    end_date='2024-12-31',\n    frequency='monthly',\n    currency='USD'\n)\nvn_usd['date'] = pd.to_datetime(vn_usd['date'])\nglobal_indices['VIETNAM'] = vn_usd.set_index('date')['return']\n\n# VND/USD exchange rate\nfx = client.get_exchange_rates(\n    pair='USD_VND',\n    start_date='2000-07-01',\n    end_date='2024-12-31',\n    frequency='monthly'\n)\nfx['date'] = pd.to_datetime(fx['date'])\nfx = fx.set_index('date')\n\n# Global factor returns (Fama-French global)\nglobal_factors = client.get_global_factor_returns(\n    start_date='2000-07-01',\n    end_date='2024-12-31',\n    frequency='monthly',\n    factors=['mkt_excess_world', 'smb_world', 'hml_world',\n             'rmw_world', 'cma_world', 'wml_world']\n)\nglobal_factors['date'] = pd.to_datetime(global_factors['date'])\nglobal_factors = global_factors.set_index('date')\n\n# Vietnamese factor returns (local)\nlocal_factors = client.get_factor_returns(\n    market='vietnam',\n    start_date='2008-01-01',\n    end_date='2024-12-31',\n    factors=['mkt_excess', 'smb', 'hml', 'rmw', 'cma', 'wml']\n)\nlocal_factors['date'] = pd.to_datetime(local_factors['date'])\nlocal_factors = local_factors.set_index('date')\n\nprint(f\"Vietnam index: {len(vn_index)} months\")\nprint(f\"Global indices: {global_indices.shape}\")\nprint(f\"Global factors: {len(global_factors)} months\")\n```\n:::\n\n\n### Vietnam's Liberalization Timeline\n\n::: {#timeline .cell execution_count=3}\n``` {.python .cell-code code-summary=\"Define key liberalization events for Vietnam\"}\nliberalization_events = pd.DataFrame([\n    ('2000-07-28', 'HOSE opens', 'Institutional'),\n    ('2002-03-01', 'FOL raised to 30%', 'Ownership'),\n    ('2005-03-01', 'HNX opens', 'Institutional'),\n    ('2006-01-01', 'Securities Law enacted', 'Legal'),\n    ('2007-01-11', 'WTO accession', 'Trade'),\n    ('2007-06-01', 'FOL raised to 49%', 'Ownership'),\n    ('2009-06-24', 'UPCoM opens', 'Institutional'),\n    ('2012-01-01', 'SSC restructuring', 'Regulatory'),\n    ('2015-09-01', 'FOL selectively removed', 'Ownership'),\n    ('2017-08-01', 'Derivatives market opens', 'Institutional'),\n    ('2018-09-01', 'FTSE Frontier Secondary', 'Index'),\n    ('2021-01-01', 'New Securities Law', 'Legal'),\n    ('2023-06-01', 'KRX trading system', 'Infrastructure'),\n], columns=['date', 'event', 'category'])\nliberalization_events['date'] = pd.to_datetime(liberalization_events['date'])\n\nprint(\"Vietnam Liberalization Timeline:\")\nfor _, row in liberalization_events.iterrows():\n    print(f\"  {row['date'].strftime('%Y-%m')}: {row['event']} [{row['category']}]\")\n```\n:::\n\n\n## Correlation-Based Integration Measures {#sec-market-integration-correlation}\n\n### Rolling Correlations\n\nThe simplest integration metric is the correlation between Vietnamese and global market returns. Higher correlation implies more integration (returns are driven by the same global factors). However, simple correlation is confounded by volatility changes (i.e., correlations tend to increase mechanically during high-volatility periods [@longin2001extreme]).\n\n::: {#rolling-correlations .cell execution_count=4}\n``` {.python .cell-code code-summary=\"Compute rolling correlations between Vietnam and global markets\"}\n# Align all series\nindices_aligned = global_indices.dropna(subset=['VIETNAM', 'MSCI_WORLD']).copy()\n\n# Rolling 36-month correlations\nrolling_window = 36\n\ncorr_series = {}\nfor idx in ['MSCI_WORLD', 'MSCI_EM', 'MSCI_ASIA_PAC_EX_JP',\n            'SP500', 'MSCI_CHINA', 'MSCI_THAILAND']:\n    if idx in indices_aligned.columns:\n        corr = (\n            indices_aligned[['VIETNAM', idx]]\n            .rolling(rolling_window)\n            .corr()\n            .unstack()['VIETNAM'][idx]\n        )\n        corr_series[idx] = corr\n\ncorr_df = pd.DataFrame(corr_series)\n```\n:::\n\n\n::: {#fig-rolling-corr .cell execution_count=5}\n``` {.python .cell-code code-summary=\"Plot rolling correlations with event timeline\"}\nfig, ax = plt.subplots(figsize=(14, 6))\n\ncolors_idx = {\n    'MSCI_WORLD': '#2C5F8A', 'MSCI_EM': '#C0392B',\n    'MSCI_ASIA_PAC_EX_JP': '#27AE60', 'SP500': '#8E44AD',\n    'MSCI_CHINA': '#E67E22', 'MSCI_THAILAND': '#1ABC9C'\n}\n\nfor idx, color in colors_idx.items():\n    if idx in corr_df.columns:\n        ax.plot(corr_df.index, corr_df[idx], color=color,\n                linewidth=1.5, label=idx.replace('MSCI_', '').replace('_', ' '),\n                alpha=0.85)\n\n# Add liberalization events\nfor _, event in liberalization_events.iterrows():\n    if event['date'] >= corr_df.index.min():\n        ax.axvline(x=event['date'], color='gray', linewidth=0.5,\n                   linestyle=':', alpha=0.6)\n\nax.axhline(y=0, color='black', linewidth=0.5)\nax.set_ylabel('Correlation with Vietnam')\nax.set_title('Rolling 36-Month Correlation: Vietnam vs Global Markets')\nax.legend(fontsize=8, ncol=3)\nax.set_ylim([-0.3, 0.8])\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n### DCC-GARCH Dynamic Correlations\n\nTo separate changes in correlation from changes in volatility, we estimate a Dynamic Conditional Correlation (DCC) model [@engle2002dynamic]. The DCC decomposes the time-varying covariance matrix into time-varying volatilities and a time-varying correlation matrix:\n\n$$\nH_t = D_t R_t D_t\n$$ {#eq-dcc-decomp}\n\nwhere $D_t = \\text{diag}(\\sigma_{1,t}, \\ldots, \\sigma_{n,t})$ and $R_t$ is the conditional correlation matrix that evolves according to:\n\n$$\nQ_t = (1 - a - b) \\bar{Q} + a \\epsilon_{t-1} \\epsilon_{t-1}' + b Q_{t-1}\n$$ {#eq-dcc-evolution}\n\n$$\nR_t = \\text{diag}(Q_t)^{-1/2} Q_t \\text{diag}(Q_t)^{-1/2}\n$$ {#eq-dcc-normalize}\n\n::: {#dcc-garch .cell execution_count=6}\n``` {.python .cell-code code-summary=\"Estimate DCC-GARCH model for Vietnam and global market\"}\ndef estimate_dcc(y1, y2, p=1, q=1):\n    \"\"\"\n    Two-step DCC-GARCH estimation.\n    Step 1: Univariate GARCH for each series.\n    Step 2: DCC parameters from standardized residuals.\n    \"\"\"\n    # Step 1: Univariate GARCH(1,1) for each series\n    models = []\n    std_resids = []\n    cond_vols = []\n    \n    for y in [y1, y2]:\n        am = arch_model(y * 100, vol='GARCH', p=p, q=q,\n                          mean='Constant', dist='normal')\n        res = am.fit(disp='off')\n        models.append(res)\n        std_resids.append(res.std_resid)\n        cond_vols.append(res.conditional_volatility / 100)\n    \n    # Align residuals\n    e1 = std_resids[0]\n    e2 = std_resids[1]\n    common = e1.dropna().index.intersection(e2.dropna().index)\n    e1 = e1[common].values\n    e2 = e2[common].values\n    T = len(e1)\n    \n    # Step 2: DCC estimation\n    # Q_bar = unconditional correlation of standardized residuals\n    Q_bar = np.corrcoef(e1, e2)\n    \n    def dcc_loglik(params):\n        a, b = params\n        if a < 0 or b < 0 or a + b >= 1:\n            return 1e10\n        \n        Q = np.zeros((T, 2, 2))\n        R = np.zeros((T, 2, 2))\n        Q[0] = Q_bar.copy()\n        \n        ll = 0\n        for t in range(T):\n            if t > 0:\n                et = np.array([[e1[t-1]], [e2[t-1]]])\n                Q[t] = (1 - a - b) * Q_bar + a * (et @ et.T) + b * Q[t-1]\n            \n            # Normalize\n            d = np.sqrt(np.diag(Q[t]))\n            if d[0] > 0 and d[1] > 0:\n                R[t] = Q[t] / np.outer(d, d)\n            else:\n                R[t] = np.eye(2)\n            \n            # Clip correlation\n            R[t, 0, 1] = np.clip(R[t, 0, 1], -0.999, 0.999)\n            R[t, 1, 0] = R[t, 0, 1]\n            \n            # Log-likelihood contribution\n            det_R = 1 - R[t, 0, 1] ** 2\n            if det_R > 0:\n                et_vec = np.array([e1[t], e2[t]])\n                ll += -0.5 * (np.log(det_R) +\n                              et_vec @ np.linalg.inv(R[t]) @ et_vec -\n                              et_vec @ et_vec)\n        \n        return -ll\n    \n    result = optimize.minimize(dcc_loglik, [0.05, 0.90],\n                                method='Nelder-Mead',\n                                options={'maxiter': 5000})\n    a_hat, b_hat = result.x\n    \n    # Reconstruct dynamic correlations\n    Q = np.zeros((T, 2, 2))\n    dcc_corr = np.zeros(T)\n    Q[0] = Q_bar.copy()\n    \n    for t in range(T):\n        if t > 0:\n            et = np.array([[e1[t-1]], [e2[t-1]]])\n            Q[t] = (1 - a_hat - b_hat) * Q_bar + a_hat * (et @ et.T) + b_hat * Q[t-1]\n        \n        d = np.sqrt(np.diag(Q[t]))\n        if d[0] > 0 and d[1] > 0:\n            dcc_corr[t] = Q[t, 0, 1] / (d[0] * d[1])\n        else:\n            dcc_corr[t] = 0\n    \n    return {\n        'a': a_hat, 'b': b_hat,\n        'persistence': a_hat + b_hat,\n        'dcc_corr': pd.Series(dcc_corr, index=common),\n        'cond_vol_1': cond_vols[0],\n        'cond_vol_2': cond_vols[1]\n    }\n\n# Estimate DCC: Vietnam vs MSCI World\nvn_ret = indices_aligned['VIETNAM'].dropna()\nworld_ret = indices_aligned['MSCI_WORLD'].dropna()\ncommon_dates = vn_ret.index.intersection(world_ret.index)\n\ndcc_result = estimate_dcc(vn_ret[common_dates], world_ret[common_dates])\n\nprint(f\"DCC Parameters:\")\nprint(f\"  a (news): {dcc_result['a']:.4f}\")\nprint(f\"  b (persistence): {dcc_result['b']:.4f}\")\nprint(f\"  a + b: {dcc_result['persistence']:.4f}\")\nprint(f\"\\nDCC Correlation with MSCI World:\")\nprint(f\"  Mean: {dcc_result['dcc_corr'].mean():.3f}\")\nprint(f\"  Min:  {dcc_result['dcc_corr'].min():.3f}\")\nprint(f\"  Max:  {dcc_result['dcc_corr'].max():.3f}\")\n```\n:::\n\n\n::: {#fig-dcc .cell execution_count=7}\n``` {.python .cell-code code-summary=\"Plot DCC dynamic correlation with event annotations\"}\nfig, axes = plt.subplots(2, 1, figsize=(14, 8), sharex=True,\n                          gridspec_kw={'height_ratios': [2, 1]})\n\n# Panel A: DCC correlation\naxes[0].plot(dcc_result['dcc_corr'].index, dcc_result['dcc_corr'].values,\n             color='#2C5F8A', linewidth=1.5)\naxes[0].fill_between(dcc_result['dcc_corr'].index,\n                       dcc_result['dcc_corr'].values, 0,\n                       alpha=0.2, color='#2C5F8A')\n\n# Liberalization events\nevent_colors = {'Ownership': '#C0392B', 'Trade': '#27AE60',\n                'Institutional': '#E67E22', 'Legal': '#8E44AD',\n                'Index': '#1ABC9C', 'Regulatory': '#F1C40F',\n                'Infrastructure': '#3498DB'}\n\nfor _, event in liberalization_events.iterrows():\n    if event['date'] in dcc_result['dcc_corr'].index or True:\n        color = event_colors.get(event['category'], 'gray')\n        axes[0].axvline(x=event['date'], color=color, linewidth=1.5,\n                         linestyle='--', alpha=0.7)\n        axes[0].text(event['date'], axes[0].get_ylim()[1] * 0.95,\n                      event['event'][:15], rotation=90, fontsize=6,\n                      va='top', color=color)\n\naxes[0].set_ylabel('Dynamic Conditional Correlation')\naxes[0].set_title('Panel A: DCC-GARCH Correlation (Vietnam–World)')\naxes[0].axhline(y=0, color='black', linewidth=0.5)\n\n# Panel B: Conditional volatilities\nvol1 = dcc_result['cond_vol_1'] * np.sqrt(12)  # Annualized\nvol2 = dcc_result['cond_vol_2'] * np.sqrt(12)\ncommon_vol = vol1.index.intersection(vol2.index)\n\naxes[1].plot(common_vol, vol1[common_vol], color='#C0392B',\n             linewidth=1, label='Vietnam', alpha=0.8)\naxes[1].plot(common_vol, vol2[common_vol], color='#2C5F8A',\n             linewidth=1, label='World', alpha=0.8)\naxes[1].set_ylabel('Annualized Cond. Vol')\naxes[1].set_title('Panel B: Conditional Volatility')\naxes[1].legend(fontsize=9)\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n### Asymmetric Integration\n\nIntegration may be state-dependent: co-movement often increases during global crises (contagion) but not during local booms. @longin2001extreme and @ang2002asymmetric show that equity correlations are higher during market downturns. We test for asymmetry:\n\n::: {#asymmetric-corr .cell execution_count=8}\n``` {.python .cell-code code-summary=\"Test for asymmetric integration (bear vs bull markets)\"}\n# Classify global market regimes\nworld_ret_aligned = world_ret[common_dates]\nvn_ret_aligned = vn_ret[common_dates]\n\n# Bear: world return in bottom 25th percentile\n# Bull: world return in top 25th percentile\nq25 = world_ret_aligned.quantile(0.25)\nq75 = world_ret_aligned.quantile(0.75)\n\nbear = world_ret_aligned <= q25\nbull = world_ret_aligned >= q75\nnormal = ~bear & ~bull\n\nregimes = {\n    'Bear (bottom 25%)': bear,\n    'Normal (middle 50%)': normal,\n    'Bull (top 25%)': bull,\n    'All': pd.Series(True, index=world_ret_aligned.index)\n}\n\nprint(\"Asymmetric Correlation:\")\nprint(f\"{'Regime':<25} {'Correlation':>12} {'N months':>10}\")\nprint(\"-\" * 47)\n\nfor name, mask in regimes.items():\n    r_vn = vn_ret_aligned[mask]\n    r_w = world_ret_aligned[mask]\n    corr = r_vn.corr(r_w)\n    print(f\"{name:<25} {corr:>12.3f} {mask.sum():>10}\")\n\n# Test: is bear correlation > bull correlation?\nr_bear_vn = vn_ret_aligned[bear]\nr_bear_w = world_ret_aligned[bear]\nr_bull_vn = vn_ret_aligned[bull]\nr_bull_w = world_ret_aligned[bull]\n\n# Fisher z-transformation test\ndef fisher_z_test(r1, n1, r2, n2):\n    z1 = np.arctanh(r1)\n    z2 = np.arctanh(r2)\n    se = np.sqrt(1 / (n1 - 3) + 1 / (n2 - 3))\n    z_stat = (z1 - z2) / se\n    p_val = 2 * (1 - stats.norm.cdf(abs(z_stat)))\n    return z_stat, p_val\n\nz, p = fisher_z_test(\n    r_bear_vn.corr(r_bear_w), len(r_bear_vn),\n    r_bull_vn.corr(r_bull_w), len(r_bull_vn)\n)\nprint(f\"\\nFisher z-test (bear vs bull): z = {z:.2f}, p = {p:.4f}\")\n```\n:::\n\n\n## Factor-Based Integration Measures {#sec-market-integration-factor}\n\n### The Pukthuanthong-Roll R² Measure\n\n@pukthuanthong2009global propose measuring integration as the $R^2$ from regressing a country's returns on a set of global principal components. The intuition: if a market is fully integrated, global factors should explain all of its systematic return variation.\n\n::: {#pr-measure .cell execution_count=9}\n``` {.python .cell-code code-summary=\"Implement the Pukthuanthong-Roll integration measure\"}\ndef pukthuanthong_roll_integration(country_returns, global_returns_matrix,\n                                     n_components=10, rolling_window=36):\n    \"\"\"\n    Pukthuanthong-Roll (2009) R²-based integration measure.\n    \n    1. Extract principal components from global returns.\n    2. Regress country returns on these PCs.\n    3. R² = degree of integration.\n    \"\"\"\n    common = country_returns.dropna().index.intersection(\n        global_returns_matrix.dropna().index\n    )\n    \n    dates = sorted(common)\n    T = len(dates)\n    \n    integration = []\n    \n    for t in range(rolling_window, T):\n        window = dates[t - rolling_window:t]\n        \n        # Global returns in window\n        G = global_returns_matrix.loc[window].dropna(axis=1)\n        if G.shape[1] < n_components:\n            continue\n        \n        # Standardize\n        G_std = (G - G.mean()) / G.std()\n        \n        # PCA\n        cov = G_std.T @ G_std / len(G_std)\n        eigenvalues, eigenvectors = np.linalg.eigh(cov.values)\n        \n        # Sort descending\n        idx = np.argsort(-eigenvalues)\n        eigenvalues = eigenvalues[idx]\n        eigenvectors = eigenvectors[:, idx]\n        \n        # Project onto top K PCs\n        PCs = G_std.values @ eigenvectors[:, :n_components]\n        \n        # Regress country returns on PCs\n        y = country_returns.loc[window].values\n        X = sm.add_constant(PCs)\n        \n        try:\n            model = sm.OLS(y, X).fit()\n            integration.append({\n                'date': dates[t],\n                'r_squared': model.rsquared,\n                'adj_r_squared': model.rsquared_adj,\n                'var_explained_pc1': eigenvalues[0] / eigenvalues.sum(),\n                'n_countries': G.shape[1]\n            })\n        except Exception:\n            pass\n    \n    return pd.DataFrame(integration)\n\n# Build global returns matrix from multiple country indices\nglobal_matrix = global_indices.drop(columns=['VIETNAM'], errors='ignore')\n\npr_result = pukthuanthong_roll_integration(\n    indices_aligned['VIETNAM'],\n    global_matrix,\n    n_components=5,\n    rolling_window=36\n)\n\nif len(pr_result) > 0:\n    pr_result['date'] = pd.to_datetime(pr_result['date'])\n    print(f\"Pukthuanthong-Roll Integration (R²):\")\n    print(f\"  Mean: {pr_result['r_squared'].mean():.3f}\")\n    print(f\"  2008-2012: {pr_result[(pr_result['date'] >= '2008') & (pr_result['date'] < '2013')]['r_squared'].mean():.3f}\")\n    print(f\"  2013-2018: {pr_result[(pr_result['date'] >= '2013') & (pr_result['date'] < '2019')]['r_squared'].mean():.3f}\")\n    print(f\"  2019-2024: {pr_result[pr_result['date'] >= '2019']['r_squared'].mean():.3f}\")\n```\n:::\n\n\n### Global vs. Local Factor Pricing\n\n@griffin2002fama tests whether global or local versions of the Fama-French factors better explain country-level returns. We implement this horse race for Vietnam:\n\n::: {#global-vs-local .cell execution_count=10}\n``` {.python .cell-code code-summary=\"Compare explanatory power of global vs local factor models\"}\n# Align global and local factors\ncommon_factor_dates = (\n    global_factors.index\n    .intersection(local_factors.index)\n    .intersection(vn_index.index)\n)\n\nvn_excess = vn_index.loc[common_factor_dates, 'return']\n\n# Model 1: Global FF5\nX_global = sm.add_constant(\n    global_factors.loc[common_factor_dates,\n                        ['mkt_excess_world', 'smb_world', 'hml_world',\n                         'rmw_world', 'cma_world']]\n)\nmodel_global = sm.OLS(vn_excess, X_global).fit(\n    cov_type='HAC', cov_kwds={'maxlags': 6}\n)\n\n# Model 2: Local FF5\nX_local = sm.add_constant(\n    local_factors.loc[common_factor_dates,\n                       ['mkt_excess', 'smb', 'hml', 'rmw', 'cma']]\n)\nmodel_local = sm.OLS(vn_excess, X_local).fit(\n    cov_type='HAC', cov_kwds={'maxlags': 6}\n)\n\n# Model 3: Both global and local\nX_both = sm.add_constant(pd.concat([\n    global_factors.loc[common_factor_dates,\n                        ['mkt_excess_world', 'smb_world', 'hml_world']],\n    local_factors.loc[common_factor_dates,\n                       ['mkt_excess', 'smb', 'hml']]\n], axis=1))\nmodel_both = sm.OLS(vn_excess, X_both).fit(\n    cov_type='HAC', cov_kwds={'maxlags': 6}\n)\n\nprint(\"Global vs Local Factor Models for VN-Index:\")\nprint(f\"{'Model':<20} {'R²':>8} {'Adj R²':>8} {'α (ann)':>10} {'α t-stat':>10}\")\nprint(\"-\" * 56)\nfor name, mod in [('Global FF5', model_global),\n                    ('Local FF5', model_local),\n                    ('Global + Local', model_both)]:\n    print(f\"{name:<20} {mod.rsquared:>8.3f} {mod.rsquared_adj:>8.3f} \"\n          f\"{mod.params['const']*12:>10.4f} {mod.tvalues['const']:>10.2f}\")\n```\n:::\n\n\n::: {#fig-global-local-r2 .cell execution_count=11}\n``` {.python .cell-code code-summary=\"Rolling R² comparison of global and local models\"}\nrolling_r2 = []\nrw = 36\n\nfor t in range(rw, len(common_factor_dates)):\n    window = common_factor_dates[t - rw:t]\n    y = vn_excess[window]\n    \n    # Global\n    X_g = sm.add_constant(global_factors.loc[window,\n                           ['mkt_excess_world', 'smb_world', 'hml_world',\n                            'rmw_world', 'cma_world']])\n    try:\n        r2_g = sm.OLS(y, X_g).fit().rsquared\n    except:\n        r2_g = np.nan\n    \n    # Local\n    X_l = sm.add_constant(local_factors.loc[window,\n                           ['mkt_excess', 'smb', 'hml', 'rmw', 'cma']])\n    try:\n        r2_l = sm.OLS(y, X_l).fit().rsquared\n    except:\n        r2_l = np.nan\n    \n    rolling_r2.append({\n        'date': common_factor_dates[t],\n        'r2_global': r2_g,\n        'r2_local': r2_l,\n        'ratio': r2_g / r2_l if r2_l > 0 else np.nan\n    })\n\nr2_df = pd.DataFrame(rolling_r2)\n\nfig, axes = plt.subplots(2, 1, figsize=(14, 8), sharex=True)\n\naxes[0].plot(r2_df['date'], r2_df['r2_global'], color='#2C5F8A',\n             linewidth=1.5, label='Global FF5')\naxes[0].plot(r2_df['date'], r2_df['r2_local'], color='#C0392B',\n             linewidth=1.5, label='Local FF5')\naxes[0].set_ylabel('R²')\naxes[0].set_title('Panel A: Global vs Local Factor R²')\naxes[0].legend()\n\naxes[1].plot(r2_df['date'], r2_df['ratio'], color='#27AE60', linewidth=1.5)\naxes[1].axhline(y=1, color='gray', linewidth=1, linestyle='--',\n                label='Full integration (ratio = 1)')\naxes[1].set_ylabel('Global R² / Local R²')\naxes[1].set_title('Panel B: Integration Ratio')\naxes[1].legend()\naxes[1].set_ylim([0, 1.5])\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Pricing-Error-Based Integration {#sec-market-integration-pricing-error}\n\n### The Bekaert-Harvey Approach\n\n@bekaert1995time measure integration as the ability of a global CAPM to price local assets. Under integration, the local market alpha (intercept) in a regression on the global market should be zero, and the global risk premium should explain the local expected return. Under segmentation, the local alpha captures the segmentation premium.\n\n::: {#bh-integration .cell execution_count=12}\n``` {.python .cell-code code-summary=\"Bekaert-Harvey integration measure: rolling alpha from global CAPM\"}\ndef bekaert_harvey_integration(local_return, global_return,\n                                 rolling_window=36):\n    \"\"\"\n    Rolling alpha from regressing local on global market.\n    Under integration, alpha -> 0.\n    \"\"\"\n    common = local_return.dropna().index.intersection(global_return.dropna().index)\n    \n    results = []\n    for t in range(rolling_window, len(common)):\n        window = common[t - rolling_window:t]\n        y = local_return[window]\n        X = sm.add_constant(global_return[window])\n        \n        model = sm.OLS(y, X).fit()\n        \n        results.append({\n            'date': common[t],\n            'alpha': model.params['const'],\n            'alpha_t': model.tvalues['const'],\n            'beta_global': model.params.iloc[1],\n            'r_squared': model.rsquared\n        })\n    \n    return pd.DataFrame(results)\n\nbh_result = bekaert_harvey_integration(\n    indices_aligned['VIETNAM'],\n    indices_aligned['MSCI_WORLD'],\n    rolling_window=36\n)\n\n# The absolute alpha is the segmentation premium\nbh_result['abs_alpha_ann'] = bh_result['alpha'].abs() * 12\n\nprint(\"Bekaert-Harvey Integration Diagnostic:\")\nprint(f\"  Mean |α| (ann.): {bh_result['abs_alpha_ann'].mean():.4f}\")\nprint(f\"  Mean β_world: {bh_result['beta_global'].mean():.3f}\")\nprint(f\"  Mean R²: {bh_result['r_squared'].mean():.3f}\")\n```\n:::\n\n\n### Composite Integration Index\n\nWe combine all measures into a single composite index of Vietnamese market integration:\n\n::: {#composite-index .cell execution_count=13}\n``` {.python .cell-code code-summary=\"Construct a composite integration index\"}\n# Standardize each measure to [0, 1] using historical percentile ranks\nmeasures = pd.DataFrame(index=bh_result['date'])\n\n# 1. DCC correlation (higher = more integrated)\ndcc_aligned = dcc_result['dcc_corr'].reindex(measures.index).interpolate()\nmeasures['dcc_corr'] = dcc_aligned\n\n# 2. PR R² (higher = more integrated)\npr_aligned = pr_result.set_index('date')['r_squared'].reindex(measures.index).interpolate()\nmeasures['pr_r2'] = pr_aligned\n\n# 3. Global/Local R² ratio (higher = more integrated)\nr2_aligned = r2_df.set_index('date')['ratio'].reindex(measures.index).interpolate()\nmeasures['gl_ratio'] = r2_aligned\n\n# 4. |Alpha| from global CAPM (lower = more integrated)\n# Invert: 1 - percentile rank of |alpha|\nmeasures['inv_alpha'] = bh_result.set_index('date')['abs_alpha_ann']\nmeasures['inv_alpha'] = 1 - measures['inv_alpha'].rank(pct=True)\n\n# 5. Global beta (higher = more integrated, up to a point)\nmeasures['global_beta'] = bh_result.set_index('date')['beta_global']\n\n# Standardize to percentile ranks\nfor col in ['dcc_corr', 'pr_r2', 'gl_ratio', 'inv_alpha', 'global_beta']:\n    measures[f'{col}_rank'] = measures[col].rank(pct=True)\n\n# Composite = equal-weighted average of ranks\nrank_cols = [c for c in measures.columns if c.endswith('_rank')]\nmeasures['composite'] = measures[rank_cols].mean(axis=1)\n\n# Smooth with 6-month moving average\nmeasures['composite_smooth'] = measures['composite'].rolling(6).mean()\n```\n:::\n\n\n::: {#fig-composite .cell execution_count=14}\n``` {.python .cell-code code-summary=\"Plot the composite integration index with milestones\"}\nfig, ax = plt.subplots(figsize=(14, 6))\n\nax.fill_between(measures.index, measures['composite_smooth'],\n                 alpha=0.3, color='#2C5F8A')\nax.plot(measures.index, measures['composite_smooth'],\n        color='#2C5F8A', linewidth=2)\n\n# Add event markers\nfor _, event in liberalization_events.iterrows():\n    if event['date'] >= measures.index.min():\n        color = event_colors.get(event['category'], 'gray')\n        ax.axvline(x=event['date'], color=color,\n                   linewidth=1.5, linestyle='--', alpha=0.6)\n\nax.set_ylabel('Integration Index (0 = segmented, 1 = integrated)')\nax.set_title('Vietnam Equity Market Integration: Composite Index')\nax.set_ylim([0, 1])\n\n# Legend for event categories\nfrom matplotlib.patches import Patch\nlegend_patches = [Patch(facecolor=c, label=cat)\n                   for cat, c in event_colors.items() if cat in\n                   liberalization_events['category'].values]\nax.legend(handles=legend_patches, fontsize=7, loc='lower right', ncol=2)\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Structural Break Detection {#sec-market-integration-breaks}\n\n### Bai-Perron Tests for Integration Regime Shifts\n\nWe test whether Vietnam's integration trajectory contains discrete structural breaks (i.e., sudden shifts in the integration level) rather than a smooth trend:\n\n::: {#structural-breaks .cell execution_count=15}\n``` {.python .cell-code code-summary=\"Detect structural breaks in the integration time series\"}\ndef detect_breaks_cusum(series, significance=0.05):\n    \"\"\"\n    CUSUM-based structural break detection.\n    \"\"\"\n    y = series.dropna().values\n    T = len(y)\n    \n    # Recursive residuals from rolling mean\n    cumsum = np.cumsum(y - y.mean()) / (y.std() * np.sqrt(T))\n    \n    # Brown-Durbin-Evans critical values (approximate)\n    # At 5%: ±0.948\n    critical = 0.948\n    \n    breaks = []\n    for t in range(1, T - 1):\n        if abs(cumsum[t]) > critical:\n            breaks.append(t)\n    \n    return cumsum, breaks\n\n# Apply to composite index\ncomposite_clean = measures['composite_smooth'].dropna()\ncusum, break_points = detect_breaks_cusum(composite_clean)\n\n# Alternative: Chow test at key liberalization dates\ndef chow_test(y, breakpoint_idx):\n    \"\"\"Simple Chow test for structural break.\"\"\"\n    T = len(y)\n    y1 = y[:breakpoint_idx]\n    y2 = y[breakpoint_idx:]\n    \n    # Full sample regression (on constant)\n    rss_full = np.sum((y - y.mean()) ** 2)\n    \n    # Split samples\n    rss1 = np.sum((y1 - y1.mean()) ** 2)\n    rss2 = np.sum((y2 - y2.mean()) ** 2)\n    rss_split = rss1 + rss2\n    \n    k = 1  # Number of parameters\n    f_stat = ((rss_full - rss_split) / k) / (rss_split / (T - 2 * k))\n    p_val = 1 - stats.f.cdf(f_stat, k, T - 2 * k)\n    \n    return f_stat, p_val\n\nprint(\"Chow Tests for Structural Breaks at Key Dates:\")\nprint(f\"{'Event':<30} {'Date':>12} {'F-stat':>10} {'p-value':>10}\")\nprint(\"-\" * 62)\n\nfor _, event in liberalization_events.iterrows():\n    if event['date'] < composite_clean.index.min():\n        continue\n    # Find nearest date\n    nearest = composite_clean.index.searchsorted(event['date'])\n    if nearest < 12 or nearest > len(composite_clean) - 12:\n        continue\n    \n    f_stat, p_val = chow_test(composite_clean.values, nearest)\n    sig = '***' if p_val < 0.01 else '**' if p_val < 0.05 else '*' if p_val < 0.1 else ''\n    print(f\"{event['event']:<30} {event['date'].strftime('%Y-%m'):>12} \"\n          f\"{f_stat:>10.2f} {p_val:>10.4f} {sig}\")\n```\n:::\n\n\n## The Segmentation Premium for Vietnam {#sec-market-integration-premium}\n\n### Cross-Sectional Evidence\n\nUnder partial segmentation, stocks with higher foreign ownership should have lower expected returns (because foreign investors can diversify away local risk). This yields a testable prediction: foreign ownership should be negatively associated with expected returns, controlling for global risk exposure.\n\n::: {#segmentation-premium .cell execution_count=16}\n``` {.python .cell-code code-summary=\"Estimate the cross-sectional segmentation premium\"}\n# Get monthly stock returns with foreign ownership\nstock_data = client.get_monthly_returns(\n    exchanges=['HOSE', 'HNX'],\n    start_date='2008-01-01',\n    end_date='2024-12-31',\n    fields=['ticker', 'month_end', 'monthly_return', 'market_cap',\n            'foreign_ownership_pct']\n)\nstock_data['month_end'] = pd.to_datetime(stock_data['month_end'])\n\n# Fama-MacBeth: regress returns on lagged foreign ownership\nstock_data = stock_data.sort_values(['ticker', 'month_end'])\nstock_data['fol_lag'] = (\n    stock_data.groupby('ticker')['foreign_ownership_pct'].shift(1)\n)\nstock_data['log_mcap'] = np.log(stock_data['market_cap'].clip(lower=1))\n\n# Monthly cross-sectional regressions\ngamma_fol = []\nfor month, group in stock_data.dropna(subset=['fol_lag', 'monthly_return']).groupby('month_end'):\n    if len(group) < 100:\n        continue\n    \n    y = group['monthly_return'].values\n    X = sm.add_constant(group[['fol_lag', 'log_mcap']].values)\n    \n    try:\n        model = sm.OLS(y, X).fit()\n        gamma_fol.append({\n            'month': month,\n            'gamma_fol': model.params[1],\n            'gamma_size': model.params[2],\n            'n': len(group)\n        })\n    except:\n        pass\n\ngamma_fol_df = pd.DataFrame(gamma_fol)\n\nmean_gamma = gamma_fol_df['gamma_fol'].mean()\nse_gamma = gamma_fol_df['gamma_fol'].std() / np.sqrt(len(gamma_fol_df))\nt_gamma = mean_gamma / se_gamma\n\nprint(f\"Fama-MacBeth: Foreign Ownership and Expected Returns\")\nprint(f\"  γ_FOL (monthly):  {mean_gamma:.6f}\")\nprint(f\"  γ_FOL (ann.):     {mean_gamma * 12:.4f}\")\nprint(f\"  t-statistic:      {t_gamma:.2f}\")\nprint(f\"  Interpretation:   A 10pp increase in foreign ownership is \"\n      f\"associated with a {mean_gamma * 12 * 10:.2f}% change in \"\n      f\"annual expected returns\")\n```\n:::\n\n\n::: {#fig-segmentation-premium .cell execution_count=17}\n``` {.python .cell-code code-summary=\"Visualize the segmentation premium\"}\nfig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\n# Panel A: Quintile returns by foreign ownership\nfol_quintiles = stock_data.dropna(subset=['fol_lag', 'monthly_return']).copy()\nfol_quintiles['fol_q'] = (\n    fol_quintiles.groupby('month_end')['fol_lag']\n    .transform(lambda x: pd.qcut(x.rank(method='first'), 5,\n                                    labels=['Q1\\n(Low FOL)', 'Q2', 'Q3', 'Q4',\n                                            'Q5\\n(High FOL)']))\n)\n\nq_returns = (\n    fol_quintiles.groupby('fol_q')['monthly_return']\n    .mean() * 12 * 100\n)\n\ncolors_q = plt.cm.RdYlGn_r(np.linspace(0.2, 0.8, 5))\naxes[0].bar(range(5), q_returns.values, color=colors_q,\n            edgecolor='white', alpha=0.85)\naxes[0].set_xticks(range(5))\naxes[0].set_xticklabels(q_returns.index)\naxes[0].set_ylabel('Ann. Return (%)')\naxes[0].set_title('Panel A: Returns by Foreign Ownership Quintile')\naxes[0].axhline(y=0, color='black', linewidth=0.5)\n\n# Panel B: Rolling FM coefficient\ngamma_fol_df['date'] = pd.to_datetime(gamma_fol_df['month'])\nrolling_gamma = gamma_fol_df.set_index('date')['gamma_fol'].rolling(24).mean() * 12\n\naxes[1].plot(rolling_gamma.index, rolling_gamma.values,\n             color='#2C5F8A', linewidth=1.5)\naxes[1].axhline(y=0, color='black', linewidth=0.5)\naxes[1].set_ylabel('γ_FOL (annualized)')\naxes[1].set_title('Panel B: Rolling Segmentation Premium')\naxes[1].fill_between(rolling_gamma.index, rolling_gamma.values, 0,\n                      where=rolling_gamma.values < 0,\n                      alpha=0.3, color='#27AE60', label='Negative (integration)')\naxes[1].fill_between(rolling_gamma.index, rolling_gamma.values, 0,\n                      where=rolling_gamma.values >= 0,\n                      alpha=0.3, color='#C0392B', label='Positive (segmentation)')\naxes[1].legend(fontsize=8)\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Exchange Rate Risk and Integration {#sec-market-integration-fx}\n\n### Is Currency Risk Priced?\n\nIn a partially integrated market, exchange rate risk may carry a separate premium. @jorion1991estimation and @dumas1995world test whether currency exposure is priced beyond global equity risk. For Vietnam, the VND/USD exchange rate is managed (a crawling peg with occasional step devaluations), creating a specific risk that is neither fully diversifiable nor fully priced by global equity factors.\n\n::: {#fx-risk .cell execution_count=18}\n``` {.python .cell-code code-summary=\"Test whether VND/USD exchange rate risk is priced\"}\n# VND depreciation\nfx_return = fx['rate'].pct_change()\nfx_return.name = 'fx_return'\n\n# Merge with stock data\nstock_fx = stock_data.merge(\n    fx_return.to_frame().reset_index().rename(columns={'date': 'month_end'}),\n    on='month_end', how='left'\n)\n\n# Estimate FX beta for each stock (rolling 60-month)\n# Then test in Fama-MacBeth whether FX beta is priced\nfx_betas = {}\nfor ticker, group in stock_fx.groupby('ticker'):\n    if len(group) < 60:\n        continue\n    group = group.sort_values('month_end')\n    y = group['monthly_return']\n    x = group[['fx_return']].dropna()\n    common = y.dropna().index.intersection(x.index)\n    if len(common) < 48:\n        continue\n    model = sm.OLS(y[common], sm.add_constant(x.loc[common])).fit()\n    fx_betas[ticker] = model.params.get('fx_return', np.nan)\n\nfx_beta_series = pd.Series(fx_betas, name='fx_beta')\n\n# Cross-sectional test: do stocks with higher FX beta earn different returns?\nstock_fx_beta = stock_fx.merge(\n    fx_beta_series.to_frame().reset_index().rename(columns={'index': 'ticker'}),\n    on='ticker', how='left'\n)\n\n# Quintile sort on FX beta\nfx_q = stock_fx_beta.dropna(subset=['fx_beta', 'monthly_return'])\nfx_q['fx_quintile'] = pd.qcut(fx_q['fx_beta'].rank(method='first'),\n                                 5, labels=False)\n\nfx_premium = fx_q.groupby('fx_quintile')['monthly_return'].mean() * 12\nprint(\"Returns by FX Beta Quintile:\")\nfor q, ret in fx_premium.items():\n    print(f\"  Q{q+1}: {ret*100:.2f}% ann.\")\nprint(f\"  Q5-Q1: {(fx_premium.iloc[-1] - fx_premium.iloc[0])*100:.2f}% ann.\")\n```\n:::\n\n\n## Contagion vs. Interdependence {#sec-market-integration-contagion}\n\nDuring global crises, correlations between Vietnam and world markets spike. The question is whether this represents *contagion* (a structural change in the transmission mechanism) or simply *interdependence* (normal co-movement amplified by higher volatility). @longin2001extreme show that correlation increases mechanically with volatility even without any change in the underlying dependence structure.\n\n::: {#contagion-test .cell execution_count=19}\n``` {.python .cell-code code-summary=\"Test for contagion during major crisis episodes\"}\ndef forbes_rigobon_test(r_local, r_global, crisis_dates, tranquil_dates):\n    \"\"\"\n    Forbes-Rigobon (2002) contagion test.\n    Adjusts for heteroskedasticity-induced bias in correlation.\n    \n    H0: No contagion (correlation increase is explained by volatility)\n    H1: Contagion (correlation increase exceeds what volatility explains)\n    \"\"\"\n    r_l_crisis = r_local[crisis_dates]\n    r_g_crisis = r_global[crisis_dates]\n    r_l_tranquil = r_local[tranquil_dates]\n    r_g_tranquil = r_global[tranquil_dates]\n    \n    # Unadjusted correlations\n    rho_crisis = r_l_crisis.corr(r_g_crisis)\n    rho_tranquil = r_l_tranquil.corr(r_g_tranquil)\n    \n    # Volatility ratio\n    delta = r_g_crisis.var() / r_g_tranquil.var() - 1\n    \n    # Adjusted correlation\n    rho_adj = rho_crisis / np.sqrt(1 + delta * (1 - rho_crisis ** 2))\n    \n    # Fisher z-test on adjusted vs tranquil\n    z_adj = np.arctanh(rho_adj)\n    z_tranquil = np.arctanh(rho_tranquil)\n    se = np.sqrt(1 / (len(r_l_crisis) - 3) + 1 / (len(r_l_tranquil) - 3))\n    z_stat = (z_adj - z_tranquil) / se\n    p_val = 2 * (1 - stats.norm.cdf(abs(z_stat)))\n    \n    return {\n        'rho_crisis_raw': rho_crisis,\n        'rho_crisis_adj': rho_adj,\n        'rho_tranquil': rho_tranquil,\n        'delta': delta,\n        'z_stat': z_stat,\n        'p_value': p_val,\n        'contagion': p_val < 0.05\n    }\n\n# Define crisis and tranquil periods\ncrises = {\n    'GFC (2008-09)': (pd.Timestamp('2008-09-01'), pd.Timestamp('2009-03-31')),\n    'European Debt (2011-12)': (pd.Timestamp('2011-06-01'), pd.Timestamp('2012-06-30')),\n    'COVID (2020)': (pd.Timestamp('2020-02-01'), pd.Timestamp('2020-06-30')),\n    'Fed Tightening (2022)': (pd.Timestamp('2022-01-01'), pd.Timestamp('2022-12-31')),\n}\n\n# Tranquil = 24 months before each crisis\nvn_aligned = indices_aligned['VIETNAM']\nworld_aligned = indices_aligned['MSCI_WORLD']\n\nprint(\"Contagion Tests (Forbes-Rigobon):\")\nprint(f\"{'Crisis':<28} {'ρ(raw)':>8} {'ρ(adj)':>8} {'ρ(calm)':>8} \"\n      f\"{'z-stat':>8} {'p-val':>8} {'Result':>12}\")\nprint(\"-\" * 80)\n\nfor name, (start, end) in crises.items():\n    crisis_mask = (vn_aligned.index >= start) & (vn_aligned.index <= end)\n    tranquil_start = start - pd.DateOffset(months=24)\n    tranquil_mask = ((vn_aligned.index >= tranquil_start) &\n                      (vn_aligned.index < start))\n    \n    crisis_dates = vn_aligned.index[crisis_mask]\n    tranquil_dates = vn_aligned.index[tranquil_mask]\n    \n    if len(crisis_dates) < 3 or len(tranquil_dates) < 12:\n        continue\n    \n    result = forbes_rigobon_test(vn_aligned, world_aligned,\n                                  crisis_dates, tranquil_dates)\n    \n    verdict = 'CONTAGION' if result['contagion'] else 'Interdependence'\n    print(f\"{name:<28} {result['rho_crisis_raw']:>8.3f} \"\n          f\"{result['rho_crisis_adj']:>8.3f} {result['rho_tranquil']:>8.3f} \"\n          f\"{result['z_stat']:>8.2f} {result['p_value']:>8.3f} \"\n          f\"{verdict:>12}\")\n```\n:::\n\n\n## ASEAN Peer Comparison {#sec-market-integration-asean}\n\nVietnam's integration trajectory is best understood in the context of its ASEAN peers, which share similar starting conditions but have followed different liberalization paths:\n\n::: {#fig-asean-comparison .cell execution_count=20}\n``` {.python .cell-code code-summary=\"Compare integration trajectories across ASEAN markets\"}\nfig, ax = plt.subplots(figsize=(14, 6))\n\nasean_markets = {\n    'VIETNAM': '#C0392B',\n    'MSCI_THAILAND': '#2C5F8A',\n    'MSCI_INDONESIA': '#27AE60',\n    'MSCI_PHILIPPINES': '#E67E22',\n    'MSCI_MALAYSIA': '#8E44AD'\n}\n\nfor market, color in asean_markets.items():\n    if market not in global_indices.columns:\n        continue\n    \n    corr = (\n        global_indices[['MSCI_WORLD', market]]\n        .rolling(36)\n        .corr()\n        .unstack()['MSCI_WORLD'][market]\n    )\n    \n    label = market.replace('MSCI_', '').replace('_', ' ').title()\n    if market == 'VIETNAM':\n        ax.plot(corr.index, corr.values, color=color,\n                linewidth=2.5, label=label, zorder=5)\n    else:\n        ax.plot(corr.index, corr.values, color=color,\n                linewidth=1.5, label=label, alpha=0.7)\n\nax.set_ylabel('Correlation with MSCI World')\nax.set_title('ASEAN Market Integration: Rolling 36-Month Correlation')\nax.legend(fontsize=9)\nax.set_ylim([-0.2, 0.9])\nax.axhline(y=0, color='black', linewidth=0.5)\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Practical Implications {#sec-market-integration-implications}\n\nThe degree of integration determines which asset pricing model is appropriate for Vietnamese equities. The evidence in this chapter supports several practical conclusions:\n\n**Vietnam is partially integrated and trending toward integration.** The composite index shows a clear upward trajectory, with the post-2015 period representing the highest sustained integration in the market's history. However, Vietnam remains less integrated than Thailand or Malaysia, and far from fully integrated with global markets.\n\n**Local factors dominate global factors for pricing Vietnamese stocks.** The rolling $R^2$ comparison shows that local Vietnamese factors consistently explain more return variation than global factors. This means that researchers studying Vietnamese cross-sectional returns should use local factor models (Vietnamese FF5) rather than global factors. Global factors are useful primarily for international investors assessing co-movement risk.\n\n**The segmentation premium is shrinking but not zero.** The Fama-MacBeth evidence shows that stocks with higher foreign ownership earn lower returns, consistent with partial segmentation. The magnitude has declined over time as foreign ownership limits have been relaxed, but a residual premium persists—likely driven by remaining ownership caps in banking and strategic sectors.\n\n**Crisis-period co-movement is mostly interdependence, not contagion.** The Forbes-Rigobon adjusted correlations show that the spike in Vietnam-World correlation during crises is largely explained by increased global volatility, not a structural change in the transmission mechanism. This is reassuring for diversification: Vietnam continues to offer meaningful diversification benefits even during global stress.\n\n**The FTSE/MSCI upgrade path matters.** Vietnam's potential upgrade from frontier to emerging market status would trigger mandatory index rebalancing by passive funds, increasing foreign flows and likely accelerating integration. Researchers and investors should monitor upgrade criteria and their implications for the cost of capital.\n\n## Summary {#sec-market-integration-summary}\n\n| Measure | What It Captures | Vietnam Range | Current Level | Trend |\n|---------------|---------------|---------------|---------------|---------------|\n| DCC correlation (World) | Co-movement | 0.0–0.5 | \\~0.35–0.45 | Rising |\n| PR R² (global PCs) | Global factor exposure | 0.05–0.50 | \\~0.30–0.40 | Rising |\n| Global/Local R² ratio | Relative pricing power | 0.1–0.8 | \\~0.5–0.6 | Rising |\n| Global CAPM α | Pricing error | 0–15% ann. | \\~3–5% ann. | Falling |\n| FOL premium (γ) | Segmentation cost | -5% to +2% | \\~-1% to 0% | Shrinking |\n\n: Summary of integration measures for the Vietnamese equity market. {#tbl-market-integration-summary}\n\n<!-- ## Exercises {#sec-market-integration-exercises}\n\n1.  **Regime-switching model.** Estimate the @bekaert1995time regime-switching model for Vietnam with two states (integrated, segmented). Use Hamilton filtering to extract the smoothed probability of being in the integrated state at each point in time. Does the filtered probability align with the composite index from this chapter?\n\n2.  **Spanning test.** Can a U.S. investor replicate the Vietnamese market return using a portfolio of U.S.-listed ETFs (e.g., VNM ETF, EEM, FXI, EWY)? Regress the VN-Index on these ETFs and examine the alpha. A zero alpha means the Vietnamese market is \"spanned\" and offers no diversification benefit beyond what is available through U.S.-listed instruments [@errunza1985international].\n\n3.  **Capital flow and integration.** Obtain monthly net foreign capital flow data for Vietnam (from the SSC or central bank). Test whether months of high foreign inflows are followed by higher Vietnam-World correlation. This tests whether integration is driven by capital flows or by other channels (trade, information).\n\n4.  **Sector-level integration.** Estimate DCC correlations separately for Vietnamese banking, real estate, consumer goods, and technology sectors against their global sector counterparts. Which sectors are most integrated? Sectors with heavy state ownership may be more segmented.\n\n5.  **Integration and the cost of capital.** Using the @bekaert2005does framework, estimate the reduction in Vietnam's implied cost of equity capital associated with the measured increase in integration since 2000. Use the local CAPM vs. global CAPM implied risk premia to quantify the \"integration dividend.\"\n\n6.  **Chinn-Ito index.** Download the @chinn2006what capital account openness index (KAOPEN) for Vietnam and its ASEAN peers. Plot KAOPEN against the market-based integration measures from this chapter. Is de jure openness (legal capital account liberalization) a good predictor of de facto integration (market co-movement)?\n\n7.  **Frequency-domain integration.** Decompose Vietnam-World co-movement by frequency band (weekly, monthly, quarterly, annual) using wavelet coherence. Integration may differ at different frequencies: high-frequency co-movement reflects arbitrage and information transmission, while low-frequency co-movement reflects shared business cycles.\n\n8.  **COVID stress test.** The March 2020 COVID crash was the most severe global synchronized selloff in a decade. Using daily data, estimate hour-by-hour or day-by-day correlation between Vietnam and global markets during the crisis. Did Vietnam's price limits (Chapter on price limits) prevent full contagion transmission, or merely delay it? -->\n\n",
    "supporting": [
      "56_market_integration_and_segmentation_files"
    ],
    "filters": [],
    "includes": {}
  }
}