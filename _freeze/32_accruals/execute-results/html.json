{
  "hash": "d5568d5ad6e750a1266cf4dbc039e340",
  "result": {
    "engine": "jupyter",
    "markdown": "# Accruals, Earnings Persistence, and Market Efficiency\n\n::: {#setup .cell message='false' execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mticker\nimport statsmodels.api as sm\nimport statsmodels.formula.api as smf\nfrom scipy import stats\nfrom itertools import product\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\nplt.rcParams.update({\n    \"figure.dpi\": 150,\n    \"axes.spines.top\": False,\n    \"axes.spines.right\": False,\n    \"font.size\": 11,\n})\n```\n:::\n\n\nAccrual accounting is the foundation of modern financial reporting. Under accrual principles, revenues are recognized when earned and expenses when incurred, regardless of when cash changes hands. This timing wedge between economic events and cash realization generates **accruals** (i.e., the non-cash component of reported earnings). Formally, we define total accruals as:\n\n$$\n\\text{Accruals}_t = \\text{Earnings}_t - \\text{Cash Flow from Operations}_t\n$$ {#eq-accruals-def}\n\nThe distinction between accruals and cash flows matters because these two components of earnings exhibit markedly different statistical properties. Cash flows from operations tend to be more persistent and harder for managers to manipulate, while accruals are inherently more transient and subject to managerial discretion through estimates, assumptions, and timing choices [@dechow2010understanding].\n\n@sloan1996stock demonstrated two important empirical regularities in U.S. data:\n\n1.  The accrual component of earnings is *less persistent* than the cash flow component in predicting future earnings, and\n2.  Equity prices behave as if investors fail to distinguish between these components, treating accruals as having the same persistence as cash flows. This second finding implies a predictable pattern in stock returns (i.e., firms with high accruals earn lower subsequent returns, and vice versa—known as the **accrual anomaly**).\n\n### Why Vietnam?\n\nVietnam's equity markets provide a compelling laboratory for studying accrual dynamics for several reasons:\n\n1.  **Accounting standards in transition.** Vietnam operates under Vietnamese Accounting Standards (VAS), which are broadly based on older International Accounting Standards but have not yet fully converged with IFRS. VAS retains certain rules-based provisions that may generate different accrual patterns compared to the principles-based frameworks in developed markets.\n\n2.  **State-owned enterprise (SOE) influence.** A significant fraction of listed firms on HOSE and HNX are former SOEs or remain partially state-owned. These firms may face different incentives regarding accrual management (political rather than purely economic), introducing heterogeneity absent in the original U.S. studies.\n\n3.  **Market maturity and investor sophistication.** Vietnam's stock market, with HOSE established in 2000 and HNX in 2005, is still developing. Retail investors dominate trading volume, and institutional infrastructure (analyst coverage, short-selling constraints, information intermediaries) is less developed than in the U.S. This environment may amplify or attenuate the mispricing patterns documented in developed markets.\n\n4.  **Daily price limits.** Both HOSE ($\\pm$ 7%) and HNX ($\\pm$ 10%) impose daily price limits, which can impede price discovery and create path dependencies in return measurement that have no analogue in the U.S. context.\n\n5.  **Emerging market growth dynamics.** High-growth economies generate different accrual profiles—rapid revenue growth mechanically produces large working capital accruals even absent any managerial manipulation [@fairfield2003accrued].\n\n## Measuring Accruals {#sec-accruals-measuring}\n\n### The Balance Sheet Approach\n\nThe traditional approach to measuring accruals, used in much of the early literature, constructs total accruals from successive balance sheet snapshots. Define the following balance sheet items for firm $i$ in period $t$ (@tbl-accruals-bs-items).\n\n| Symbol | Description | VAS Equivalent |\n|-------------------|-------------------------|----------------------------|\n| $\\Delta CA_{i,t}$ | Change in current assets | Thay đổi tài sản ngắn hạn |\n| $\\Delta Cash_{i,t}$ | Change in cash and equivalents | Thay đổi tiền và tương đương tiền |\n| $\\Delta CL_{i,t}$ | Change in current liabilities | Thay đổi nợ ngắn hạn |\n| $\\Delta STD_{i,t}$ | Change in short-term debt | Thay đổi vay ngắn hạn |\n| $\\Delta TP_{i,t}$ | Change in taxes payable | Thay đổi thuế phải nộp |\n| $Dep_{i,t}$ | Depreciation and amortization | Khấu hao TSCĐ |\n\n: Key balance sheet items for accrual measurement {#tbl-accruals-bs-items}\n\nTotal accruals under the balance sheet approach are:\n\n$$\nACC^{BS}_{i,t} = (\\Delta CA_{i,t} - \\Delta Cash_{i,t})\n  - (\\Delta CL_{i,t} - \\Delta STD_{i,t} - \\Delta TP_{i,t})\n  - Dep_{i,t}\n$$ {#eq-bs-accruals}\n\nThe intuition behind @eq-bs-accruals is straightforward. Changes in non-cash current assets (such as accounts receivable and inventory) represent revenues recognized or expenses deferred without corresponding cash flows. Changes in operating current liabilities (excluding debt) capture expenses recognized without cash outflows. Short-term debt and taxes payable are excluded because they relate to financing and tax timing rather than operating accruals. Depreciation is subtracted as a non-cash charge against earnings.\n\nAll variables are typically scaled by average total assets to control for firm size:\n\n$$\nacc_{i,t} = \\frac{ACC^{BS}_{i,t}}{(\\text{Assets}_{i,t} + \\text{Assets}_{i,t-1})/2}\n$$ {#eq-scaled-accruals}\n\n### The Cash Flow Statement Approach\n\n@hribar2002errors demonstrated that the balance sheet approach introduces measurement error because non-operating events, such as mergers, acquisitions, divestitures, and foreign currency translations, affect current asset and liability balances without corresponding earnings impacts. They advocate a simpler and more accurate approach:\n\n$$\nACC^{CF}_{i,t} = \\text{Earnings}_{i,t} - \\text{CFO}_{i,t}\n$$ {#eq-cf-accruals}\n\nwhere $\\text{CFO}_{i,t}$ is cash flow from operations reported directly on the cash flow statement.\n\n### Vietnamese Context\n\nFor Vietnamese listed firms, the cash flow statement approach is generally preferable, but practitioners should be aware of several data considerations:\n\n-   **Circular 200/2014/TT-BTC** standardizes the chart of accounts and financial statement templates. Cash flow from operations is reported using the *indirect method* by most firms (starting from net income and adjusting for non-cash items), though some use the direct method.\n\n-   **VAS 24** (Cash Flow Statements) governs disclosure. Unlike IFRS, VAS treatment of interest paid and dividends received in the operating section is less flexible, potentially affecting comparability.\n\nFor the remainder of this chapter, we use the balance sheet approach, where demonstrated on simulated data (for pedagogical transparency) and the cash flow statement approach on actual firm data where available.\n\n## Simulation Analysis {#sec-accruals-simulation}\n\nBefore turning to Vietnamese market data, we construct a simulation to build economic intuition for *why* accrual persistence differs from cash flow persistence, and what role estimation error in accrual accounting plays in generating this difference.\n\n### The Model\n\nConsider a simplified firm that:\n\n-   Sells goods on credit at a constant gross margin $\\mu$\n-   Follows an AR(1) sales process: $S_t = \\bar{S} + \\rho(S_{t-1} - \\bar{S}) + \\varepsilon_t$, where $\\varepsilon_t \\sim N(0, \\sigma^2_S)$\n-   Collects receivables in the following period, with a true default rate $\\delta$\n-   Records an allowance for doubtful debts as a fraction $\\alpha$ of current sales\n-   Pays dividends equal to 100% of net income\n\nThe key parameter of interest is $\\alpha$, the managerial estimate of bad debts. When $\\alpha = \\delta$ (the true default rate), the accounting system is unbiased. When $\\alpha \\neq \\delta$, accruals contain estimation error that affects persistence.\n\n::: {#sim-function .cell execution_count=3}\n``` {.python .cell-code code-summary=\"Simulation function for a single firm\"}\ndef simulate_firm(\n    alpha: float = 0.03,\n    n_years: int = 20,\n    delta: float = 0.03,\n    gross_margin: float = 0.80,\n    mean_sales: float = 1000.0,\n    sd_sales: float = 100.0,\n    rho: float = 0.9,\n    beg_cash: float = 1500.0,\n    rng: np.random.Generator = None,\n) -> pd.DataFrame:\n    \"\"\"\n    Simulate financial statements for a single firm.\n    \n    Parameters\n    ----------\n    alpha : float\n        Managerial estimate of doubtful debt rate (allowance parameter).\n    n_years : int\n        Number of years to simulate.\n    delta : float\n        True economic default rate on receivables.\n    gross_margin : float\n        Gross margin on sales.\n    mean_sales : float\n        Long-run mean of the AR(1) sales process.\n    sd_sales : float\n        Standard deviation of the sales innovation.\n    rho : float\n        AR(1) persistence parameter for sales.\n    beg_cash : float\n        Beginning cash balance.\n    rng : numpy Generator\n        Random number generator for reproducibility.\n        \n    Returns\n    -------\n    pd.DataFrame\n        Simulated financial statement data.\n    \"\"\"\n    if rng is None:\n        rng = np.random.default_rng(42)\n\n    # Generate AR(1) sales\n    errors = rng.normal(0, sd_sales, n_years)\n    sales = np.zeros(n_years)\n    sales[0] = mean_sales + errors[0]\n    for t in range(1, n_years):\n        sales[t] = mean_sales + rho * (sales[t - 1] - mean_sales) + errors[t]\n\n    # Allocate arrays\n    cogs = (1 - gross_margin) * sales\n    ar = sales.copy()                     # all sales on credit\n    allowance = alpha * sales             # allowance for doubtful debts\n\n    writeoffs = np.zeros(n_years)\n    collections = np.zeros(n_years)\n    bad_debt_exp = np.zeros(n_years)\n    net_income = np.zeros(n_years)\n    dividends = np.zeros(n_years)\n    cash = np.zeros(n_years)\n    equity = np.zeros(n_years)\n\n    # Year 1\n    bad_debt_exp[0] = allowance[0]\n    net_income[0] = sales[0] - cogs[0] - bad_debt_exp[0]\n    dividends[0] = net_income[0]\n    cash[0] = beg_cash + collections[0] - cogs[0] - dividends[0]\n    equity[0] = beg_cash + net_income[0] - dividends[0]\n\n    # Years 2 through n_years\n    for t in range(1, n_years):\n        writeoffs[t] = delta * ar[t - 1]\n        collections[t] = (1 - delta) * ar[t - 1]\n        bad_debt_exp[t] = allowance[t] - allowance[t - 1] + writeoffs[t]\n        net_income[t] = sales[t] - cogs[t] - bad_debt_exp[t]\n        dividends[t] = net_income[t]\n        cash[t] = cash[t - 1] + collections[t] - cogs[t] - dividends[t]\n        equity[t] = equity[t - 1] + net_income[t] - dividends[t]\n\n    return pd.DataFrame({\n        \"year\": np.arange(1, n_years + 1),\n        \"alpha\": alpha,\n        \"sales\": sales,\n        \"cogs\": cogs,\n        \"ar\": ar,\n        \"allowance\": allowance,\n        \"writeoffs\": writeoffs,\n        \"collections\": collections,\n        \"bad_debt_exp\": bad_debt_exp,\n        \"net_income\": net_income,\n        \"dividends\": dividends,\n        \"cash\": cash,\n        \"equity\": equity,\n    })\n```\n:::\n\n\n### Generating a Single Firm\n\nWe first generate 1,000 years of data for a single firm with $\\alpha = \\delta = 0.03$ (unbiased accounting) to visualize the sales process.\n\n::: {#cell-fig-sales-sim .cell execution_count=4}\n``` {.python .cell-code}\nrng = np.random.default_rng(2024)\ndf_long = simulate_firm(alpha=0.03, n_years=1000, rng=rng)\n\nfig, ax = plt.subplots()\nsubset = df_long.query(\"year <= 20\")\nax.plot(subset[\"year\"], subset[\"sales\"], color=\"firebrick\", linewidth=1.5)\nax.axhline(\n    df_long[\"sales\"].mean(), color=\"steelblue\",\n    linestyle=\"--\", linewidth=1, label=\"Long-run mean\"\n)\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Sales (millions VND, simulated)\")\nax.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Simulated sales for a single firm over 20 years. The blue dashed line shows mean sales. The AR(1) structure creates smooth, persistent fluctuations.](32_accruals_files/figure-html/fig-sales-sim-output-1.png){#fig-sales-sim width=1030 height=729}\n:::\n:::\n\n\n### Cross-Sectional Simulation: Persistence and Estimation Error\n\nThe central economic insight is that when the managerial estimate $\\alpha$ departs from the true rate $\\delta$, accruals contain a systematic estimation error that *reduces* the persistence of earnings. To demonstrate this, we simulate 5,000 firms, each with a randomly drawn $\\alpha \\in [0.01, 0.05]$ while keeping the true default rate fixed at $\\delta = 0.03$.\n\nFor each firm, we estimate earnings persistence as the slope coefficient $\\hat{\\beta}_1$ from an AR(1) regression of net income:\n\n$$\nNI_{i,t} = \\beta_0 + \\beta_1 NI_{i,t-1} + u_{i,t}\n$$ {#eq-persistence-reg}\n\n::: {#sim-cross-section .cell execution_count=5}\n``` {.python .cell-code code-summary=\"Cross-sectional simulation of persistence vs. alpha\"}\ndef estimate_persistence(df: pd.DataFrame) -> dict:\n    \"\"\"Estimate AR(1) persistence of net income for one firm.\"\"\"\n    temp = df[[\"year\", \"net_income\"]].copy()\n    temp[\"lag_ni\"] = temp[\"net_income\"].shift(1)\n    temp = temp.dropna()\n    if len(temp) < 10:\n        return {\"alpha\": df[\"alpha\"].iloc[0], \"persistence\": np.nan}\n    X = sm.add_constant(temp[\"lag_ni\"])\n    model = sm.OLS(temp[\"net_income\"], X).fit()\n    return {\"alpha\": df[\"alpha\"].iloc[0], \"persistence\": model.params[\"lag_ni\"]}\n\nn_firms = 5000\nrng_main = np.random.default_rng(2024)\nalphas = rng_main.uniform(0.01, 0.05, n_firms)\n\nresults = []\nfor i, a in enumerate(alphas):\n    firm_rng = np.random.default_rng(2024 + i)\n    firm_df = simulate_firm(alpha=a, n_years=200, rng=firm_rng)\n    results.append(estimate_persistence(firm_df))\n\nsim_results = pd.DataFrame(results)\n```\n:::\n\n\n::: {#cell-fig-persistence-alpha .cell execution_count=6}\n``` {.python .cell-code}\nfig, ax = plt.subplots()\nax.scatter(\n    sim_results[\"alpha\"], sim_results[\"persistence\"],\n    alpha=0.15, s=8, color=\"steelblue\", edgecolors=\"none\"\n)\nax.set_xlabel(r\"Allowance parameter ($\\alpha$)\")\nax.set_ylabel(\"Estimated earnings persistence\")\nax.axvline(0.03, color=\"firebrick\", linestyle=\"--\", linewidth=1, label=r\"$\\delta = 0.03$ (true rate)\")\nax.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Earnings persistence vs. allowance parameter ($\\alpha$). Persistence peaks near $\\alpha = 0.03$, the true default rate, and declines symmetrically as the accounting estimate deviates from economic reality in either direction.](32_accruals_files/figure-html/fig-persistence-alpha-output-1.png){#fig-persistence-alpha width=1029 height=727}\n:::\n:::\n\n\n### Decomposing Persistence by Earnings Component\n\nThe simulation allows us to verify the core theoretical prediction: cash flow persistence exceeds accrual persistence. We compute operating cash flows and accruals for each simulated firm and estimate component-specific persistence.\n\n::: {#sim-component-persistence .cell execution_count=7}\n``` {.python .cell-code code-summary=\"Component persistence in simulated data\"}\ndef component_persistence(df: pd.DataFrame) -> dict:\n    \"\"\"Estimate persistence of NI, CFO, and accruals.\"\"\"\n    temp = df.copy()\n    # CFO = collections - COGS (direct method, simplified)\n    temp[\"cfo\"] = temp[\"collections\"] - temp[\"cogs\"]\n    temp[\"acc\"] = temp[\"net_income\"] - temp[\"cfo\"]\n\n    out = {\"alpha\": temp[\"alpha\"].iloc[0]}\n    for var in [\"net_income\", \"cfo\", \"acc\"]:\n        t = temp[[\"year\", var]].copy()\n        t[\"lag\"] = t[var].shift(1)\n        t = t.dropna()\n        if len(t) < 10:\n            out[f\"persist_{var}\"] = np.nan\n            continue\n        X = sm.add_constant(t[\"lag\"])\n        model = sm.OLS(t[var], X).fit()\n        out[f\"persist_{var}\"] = model.params[\"lag\"]\n    return out\n\n# Run for a subset at alpha = 0.03 (unbiased) and alpha = 0.05 (biased)\ncomponent_results = []\nfor a_val in [0.01, 0.02, 0.03, 0.04, 0.05]:\n    for seed_offset in range(500):\n        frng = np.random.default_rng(10000 + seed_offset)\n        fdf = simulate_firm(alpha=a_val, n_years=200, rng=frng)\n        component_results.append(component_persistence(fdf))\n\ncomp_df = pd.DataFrame(component_results)\n```\n:::\n\n\n::: {#tbl-sim-persistence .cell tbl-cap='Mean earnings component persistence by allowance parameter. Cash flow persistence is stable across $\\alpha$ values, while accrual and overall earnings persistence peak when accounting estimates match the true default rate ($\\delta = 0.03$).' execution_count=8}\n``` {.python .cell-code}\nsummary = (\n    comp_df\n    .groupby(\"alpha\")[[\"persist_net_income\", \"persist_cfo\", \"persist_acc\"]]\n    .mean()\n    .round(4)\n    .rename(columns={\n        \"persist_net_income\": \"Earnings\",\n        \"persist_cfo\": \"Cash Flows\",\n        \"persist_acc\": \"Accruals\",\n    })\n)\nsummary.index.name = \"α\"\nsummary\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Earnings</th>\n      <th>Cash Flows</th>\n      <th>Accruals</th>\n    </tr>\n    <tr>\n      <th>α</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0.01</th>\n      <td>0.8728</td>\n      <td>0.6922</td>\n      <td>-0.0357</td>\n    </tr>\n    <tr>\n      <th>0.02</th>\n      <td>0.8758</td>\n      <td>0.6922</td>\n      <td>-0.0357</td>\n    </tr>\n    <tr>\n      <th>0.03</th>\n      <td>0.8788</td>\n      <td>0.6922</td>\n      <td>-0.0357</td>\n    </tr>\n    <tr>\n      <th>0.04</th>\n      <td>0.8818</td>\n      <td>0.6922</td>\n      <td>-0.0357</td>\n    </tr>\n    <tr>\n      <th>0.05</th>\n      <td>0.8846</td>\n      <td>0.6922</td>\n      <td>-0.0357</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe simulation confirms a key insight: cash flow persistence is largely invariant to the quality of accrual estimation, whereas accrual persistence, and consequently total earnings persistence, degrades when managerial estimates deviate from economic truth. This provides a structural explanation for the empirical regularity documented in @sloan1996stock: accruals are less persistent *because* they embed estimation error that mean-reverts as the accounting system self-corrects over time.\n\n::: callout-note\n## Vietnamese Interpretation\n\nIn the Vietnamese context, this mechanism is amplified by several institutional factors. VAS provisions for doubtful debts (Circular 228/2009/TT-BTC, updated by Circular 48/2019/TT-BTC) prescribe specific aging-based percentages rather than allowing full managerial discretion. While this rules-based approach reduces some forms of manipulation, it can *increase* estimation error when the prescribed rates diverge from firm-specific default experiences, particularly relevant for firms in rapidly changing sectors like real estate development or export manufacturing.\n:::\n\n## Earnings Persistence in Vietnamese Data {#sec-accruals-persistence}\n\nWe now turn to empirical analysis using Vietnamese listed firm data. The data requirements are:\n\n-   **Annual financial statements** for firms listed on HOSE and HNX\n-   **Stock return data**: Monthly adjusted closing prices for return computation\n-   **Industry classifications**: VSIC (Vietnam Standard Industrial Classification) codes\n\n### Data Preparation\n\nThe following code constructs the accrual measures from Vietnamese firm financial statements. We demonstrate the workflow assuming data is loaded from a local database or CSV files. Adapt the data loading step to match your source.\n\n::: {#data-prep .cell execution_count=9}\n``` {.python .cell-code code-summary=\"Construct accrual variables from Vietnamese financial statement data\"}\n# ─── Data Loading (adapt to your source) ───────────────────────────\n# funda = pd.read_parquet(\"data/vn_annual_financials.parquet\")\n# prices = pd.read_parquet(\"data/vn_monthly_prices.parquet\")\n\n# ─── Variable Construction ──────────────────────────────────────────\ndef construct_accruals(funda: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Construct accrual measures from Vietnamese annual financial data.\n    \n    Expected columns (VAS-aligned):\n        ticker, year, datadate,\n        act (current assets), lct (current liabilities),\n        che (cash & equivalents), dlc (short-term borrowings),\n        txp (taxes payable), dp (depreciation & amortization),\n        oiadp (operating income after depreciation),\n        at (total assets), cfo (cash flow from operations),\n        exchange (HOSE=1, HNX=2), vsic2 (2-digit industry code)\n    \"\"\"\n    df = funda.sort_values([\"ticker\", \"year\"]).copy()\n    \n    # Fill missing with zero where economically appropriate\n    for col in [\"che\", \"dlc\", \"txp\"]:\n        df[col] = df[col].fillna(0)\n\n    # Lagged total assets and average total assets\n    df[\"lag_at\"] = df.groupby(\"ticker\")[\"at\"].shift(1)\n    df[\"avg_at\"] = (df[\"at\"] + df[\"lag_at\"]) / 2\n\n    # Balance sheet approach to accruals\n    for col in [\"act\", \"che\", \"lct\", \"dlc\", \"txp\"]:\n        df[f\"d_{col}\"] = df.groupby(\"ticker\")[col].diff()\n\n    df[\"acc_bs\"] = (\n        (df[\"d_act\"] - df[\"d_che\"])\n        - (df[\"d_lct\"] - df[\"d_dlc\"] - df[\"d_txp\"])\n        - df[\"dp\"]\n    )\n\n    # Scaled variables\n    df[\"earn\"] = df[\"oiadp\"] / df[\"avg_at\"]\n    df[\"acc\"] = df[\"acc_bs\"] / df[\"avg_at\"]\n    df[\"cfo\"] = df[\"earn\"] - df[\"acc\"]\n\n    # If CFO from cash flow statement is available, prefer it\n    if \"cfo_stmt\" in df.columns:\n        df[\"cfo_direct\"] = df[\"cfo_stmt\"] / df[\"avg_at\"]\n        df[\"acc_cf\"] = df[\"earn\"] - df[\"cfo_direct\"]\n\n    # Lead earnings (next year)\n    df[\"lead_earn\"] = df.groupby(\"ticker\")[\"earn\"].shift(-1)\n\n    # Decile ranks (within each year for cross-sectional analysis)\n    for var in [\"acc\", \"earn\", \"cfo\"]:\n        df[f\"{var}_decile\"] = (\n            df.groupby(\"year\")[var]\n            .transform(lambda x: pd.qcut(x, 10, labels=False, duplicates=\"drop\") + 1)\n        )\n    df[\"lead_earn_decile\"] = (\n        df.groupby(\"year\")[\"lead_earn\"]\n        .transform(lambda x: pd.qcut(x, 10, labels=False, duplicates=\"drop\") + 1)\n    )\n\n    # Filter\n    df = df.query(\"avg_at > 0\").dropna(subset=[\"acc\", \"earn\", \"cfo\", \"lead_earn\"])\n\n    return df\n```\n:::\n\n\n### Simulated Vietnamese-Style Data for Demonstration\n\nSince we cannot distribute proprietary data in this chapter, we generate synthetic data that mimics the cross-sectional properties of Vietnamese listed firms. The parameters are calibrated to approximate values observed in the Vietnamese market.\n\n::: {#gen-demo-data .cell execution_count=10}\n``` {.python .cell-code code-summary=\"Generate synthetic Vietnamese-style panel data\"}\ndef generate_vn_panel(\n    n_firms: int = 400,\n    n_years: int = 15,\n    seed: int = 2024,\n) -> pd.DataFrame:\n    \"\"\"\n    Generate a synthetic panel dataset with properties resembling\n    Vietnamese listed firms for demonstration purposes.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    records = []\n    for i in range(n_firms):\n        # Firm-specific parameters\n        mean_earn = rng.normal(0.08, 0.04)      # mean ROA ~8%\n        persist = rng.uniform(0.3, 0.85)         # earnings persistence\n        acc_share = rng.normal(0.0, 0.03)        # mean accrual level\n        acc_noise = rng.uniform(0.02, 0.06)      # accrual volatility\n        \n        # SOE indicator (≈30% of Vietnamese listed firms)\n        is_soe = int(rng.random() < 0.30)\n        # Exchange: HOSE (1) vs HNX (2)\n        exchange = 1 if rng.random() < 0.6 else 2\n        # VSIC 2-digit code\n        vsic2 = rng.choice([10, 20, 25, 41, 46, 47, 52, 62, 64, 68])\n\n        earn_t = mean_earn\n        for t in range(n_years):\n            year = 2009 + t\n            shock = rng.normal(0, 0.04)\n            earn_t = mean_earn + persist * (earn_t - mean_earn) + shock\n\n            # Accruals: base + firm-specific noise\n            # SOEs tend to have slightly smoother accruals\n            soe_adj = -0.005 if is_soe else 0.0\n            acc_t = acc_share + soe_adj + rng.normal(0, acc_noise)\n            cfo_t = earn_t - acc_t\n\n            records.append({\n                \"ticker\": f\"VN{i:04d}\",\n                \"year\": year,\n                \"earn\": earn_t,\n                \"acc\": acc_t,\n                \"cfo\": cfo_t,\n                \"is_soe\": is_soe,\n                \"exchange\": exchange,\n                \"vsic2\": vsic2,\n            })\n\n    df = pd.DataFrame(records)\n\n    # Lead earnings\n    df = df.sort_values([\"ticker\", \"year\"])\n    df[\"lead_earn\"] = df.groupby(\"ticker\")[\"earn\"].shift(-1)\n\n    # Decile ranks within year\n    for var in [\"acc\", \"earn\", \"cfo\"]:\n        df[f\"{var}_decile\"] = (\n            df.groupby(\"year\")[var]\n            .transform(lambda x: pd.qcut(\n                x, 10, labels=False, duplicates=\"drop\"\n            ) + 1)\n        )\n    df[\"lead_earn_decile\"] = (\n        df.groupby(\"year\")[\"lead_earn\"]\n        .transform(lambda x: pd.qcut(\n            x, 10, labels=False, duplicates=\"drop\"\n        ) + 1)\n    )\n\n    # Simulate size-adjusted returns\n    # Returns load on contemporaneous earnings surprise and lagged mispricing\n    df[\"size_adj_ret\"] = (\n        1.5 * (df[\"lead_earn\"] - df[\"earn\"])  # earnings surprise\n        - 0.25 * df[\"acc\"]                     # accrual mispricing\n        + rng.normal(0, 0.30, len(df))         # noise\n    )\n\n    df = df.dropna(subset=[\"lead_earn\", \"size_adj_ret\"])\n    return df\n\npanel = generate_vn_panel(n_firms=500, n_years=15, seed=2024)\nprint(f\"Panel: {panel.shape[0]:,} firm-years, \"\n      f\"{panel['ticker'].nunique()} firms, \"\n      f\"{panel['year'].nunique()} years\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPanel: 7,000 firm-years, 500 firms, 14 years\n```\n:::\n:::\n\n\n### Descriptive Statistics by Accrual Decile\n\n@tbl-desc-decile reports mean values of earnings, accruals, and cash flows by accrual decile. The pattern should mirror the mechanical decomposition: $\\text{earn} = \\text{acc} + \\text{cfo}$.\n\n::: {#tbl-desc-decile .cell tbl-cap='Mean earnings, accruals, and cash flows by accrual decile. Firms in the lowest accrual decile have the highest cash flows, while high-accrual firms show compressed or negative cash flows—a pattern consistent with the accounting identity.' execution_count=11}\n``` {.python .cell-code}\ndesc = (\n    panel\n    .groupby(\"acc_decile\")[[\"acc\", \"earn\", \"cfo\"]]\n    .mean()\n    .round(4)\n)\ndesc.index.name = \"Accrual Decile\"\ndesc.columns = [\"Accruals\", \"Earnings\", \"Cash Flows\"]\ndesc\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Accruals</th>\n      <th>Earnings</th>\n      <th>Cash Flows</th>\n    </tr>\n    <tr>\n      <th>Accrual Decile</th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1</th>\n      <td>-0.0898</td>\n      <td>0.0760</td>\n      <td>0.1657</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>-0.0509</td>\n      <td>0.0814</td>\n      <td>0.1324</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>-0.0321</td>\n      <td>0.0769</td>\n      <td>0.1090</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>-0.0180</td>\n      <td>0.0800</td>\n      <td>0.0980</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>-0.0057</td>\n      <td>0.0792</td>\n      <td>0.0849</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>0.0071</td>\n      <td>0.0776</td>\n      <td>0.0705</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>0.0193</td>\n      <td>0.0814</td>\n      <td>0.0621</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>0.0334</td>\n      <td>0.0760</td>\n      <td>0.0425</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>0.0521</td>\n      <td>0.0760</td>\n      <td>0.0239</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>0.0896</td>\n      <td>0.0780</td>\n      <td>-0.0116</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Persistence Regressions\n\nWe estimate the pooled persistence regression analogous to Table 2 of @sloan1996stock. The baseline specification is:\n\n$$\n\\text{Earnings}_{i,t+1} = \\gamma_0 + \\gamma_1 \\text{Earnings}_{i,t} + \\epsilon_{i,t}\n$$ {#eq-persist-baseline}\n\nfollowed by the decomposition:\n\n$$\n\\text{Earnings}_{i,t+1} = \\gamma_0 + \\gamma_a \\text{Accruals}_{i,t}\n  + \\gamma_c \\text{CFO}_{i,t} + \\epsilon_{i,t}\n$$ {#eq-persist-decomp}\n\nThe hypothesis of differential persistence is $H_0: \\gamma_a = \\gamma_c$, which we test with a standard $F$-test.\n\n::: {#tbl-persistence .cell tbl-cap='Earnings persistence regressions. Column (1) estimates aggregate persistence. Column (2) decomposes earnings into accrual and cash flow components. The coefficient on accruals is significantly lower than on cash flows, confirming differential persistence.' execution_count=12}\n``` {.python .cell-code}\n# Column (1): Aggregate persistence\nmod1 = smf.ols(\"lead_earn ~ earn\", data=panel).fit()\n\n# Column (2): Component persistence\nmod2 = smf.ols(\"lead_earn ~ acc + cfo\", data=panel).fit()\n\n# F-test for H0: coef(acc) = coef(cfo)\nf_test = mod2.f_test(\"acc = cfo\")\n\nresults_table = pd.DataFrame({\n    \"(1) Aggregate\": {\n        \"Intercept\": f\"{mod1.params['Intercept']:.4f} ({mod1.bse['Intercept']:.4f})\",\n        \"Earnings\": f\"{mod1.params['earn']:.4f} ({mod1.bse['earn']:.4f})\",\n        \"Accruals\": \"\",\n        \"Cash Flows\": \"\",\n        \"N\": f\"{int(mod1.nobs):,}\",\n        \"R²\": f\"{mod1.rsquared:.3f}\",\n        \"F-test (acc=cfo)\": \"\",\n    },\n    \"(2) Components\": {\n        \"Intercept\": f\"{mod2.params['Intercept']:.4f} ({mod2.bse['Intercept']:.4f})\",\n        \"Earnings\": \"\",\n        \"Accruals\": f\"{mod2.params['acc']:.4f} ({mod2.bse['acc']:.4f})\",\n        \"Cash Flows\": f\"{mod2.params['cfo']:.4f} ({mod2.bse['cfo']:.4f})\",\n        \"N\": f\"{int(mod2.nobs):,}\",\n        \"R²\": f\"{mod2.rsquared:.3f}\",\n        \"F-test (acc=cfo)\": f\"F = {float(f_test.fvalue):.2f}, p = {float(f_test.pvalue):.4f}\", \n        \n        \n    },\n})\nresults_table\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>(1) Aggregate</th>\n      <th>(2) Components</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Intercept</th>\n      <td>0.0189 (0.0008)</td>\n      <td>0.0189 (0.0008)</td>\n    </tr>\n    <tr>\n      <th>Earnings</th>\n      <td>0.7618 (0.0079)</td>\n      <td></td>\n    </tr>\n    <tr>\n      <th>Accruals</th>\n      <td></td>\n      <td>0.7602 (0.0127)</td>\n    </tr>\n    <tr>\n      <th>Cash Flows</th>\n      <td></td>\n      <td>0.7618 (0.0079)</td>\n    </tr>\n    <tr>\n      <th>N</th>\n      <td>7,000</td>\n      <td>7,000</td>\n    </tr>\n    <tr>\n      <th>R²</th>\n      <td>0.569</td>\n      <td>0.569</td>\n    </tr>\n    <tr>\n      <th>F-test (acc=cfo)</th>\n      <td></td>\n      <td>F = 0.02, p = 0.8746</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Industry-Level Persistence\n\nMarket-wide regressions may mask heterogeneity across industries. Vietnamese industry structure is concentrated in manufacturing, real estate, banking, and retail (i.e., sectors with very different accrual profiles). We estimate persistence separately by two-digit VSIC code.\n\n::: {#tbl-industry-persistence .cell tbl-cap='Distribution of industry-level persistence coefficients. Each row reports statistics for the distribution of estimated coefficients across 2-digit VSIC industries.' execution_count=13}\n``` {.python .cell-code}\ndef industry_persistence(df: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"Estimate persistence regressions by VSIC 2-digit code.\"\"\"\n    coefs = []\n    for vsic, group in df.groupby(\"vsic2\"):\n        if len(group) < 30:\n            continue\n        try:\n            mod = smf.ols(\"lead_earn ~ acc + cfo\", data=group).fit()\n            coefs.append({\n                \"vsic2\": vsic,\n                \"intercept\": mod.params[\"Intercept\"],\n                \"acc\": mod.params[\"acc\"],\n                \"cfo\": mod.params[\"cfo\"],\n            })\n        except Exception:\n            continue\n    return pd.DataFrame(coefs)\n\nind_coefs = industry_persistence(panel)\n\nind_summary = ind_coefs[[\"intercept\", \"acc\", \"cfo\"]].describe().loc[\n    [\"mean\", \"25%\", \"50%\", \"75%\"]\n].round(4)\nind_summary.index = [\"Mean\", \"Q1\", \"Median\", \"Q3\"]\nind_summary.columns = [\"Intercept\", \"Accruals (γ_a)\", \"Cash Flows (γ_c)\"]\nind_summary\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Intercept</th>\n      <th>Accruals (γ_a)</th>\n      <th>Cash Flows (γ_c)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Mean</th>\n      <td>0.0192</td>\n      <td>0.7573</td>\n      <td>0.7587</td>\n    </tr>\n    <tr>\n      <th>Q1</th>\n      <td>0.0171</td>\n      <td>0.7310</td>\n      <td>0.7323</td>\n    </tr>\n    <tr>\n      <th>Median</th>\n      <td>0.0193</td>\n      <td>0.7621</td>\n      <td>0.7558</td>\n    </tr>\n    <tr>\n      <th>Q3</th>\n      <td>0.0213</td>\n      <td>0.7914</td>\n      <td>0.7750</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Persistence Visualization\n\n@fig-persistence-bars compares the accrual and cash flow persistence coefficients across industries, providing a visual test of the differential persistence hypothesis.\n\n::: {#cell-fig-persistence-bars .cell execution_count=14}\n``` {.python .cell-code}\nif len(ind_coefs) > 2:\n    ind_plot = ind_coefs.sort_values(\"cfo\").reset_index(drop=True)\n    fig, ax = plt.subplots(figsize=(8, 5))\n    x = np.arange(len(ind_plot))\n    width = 0.35\n    ax.barh(x - width / 2, ind_plot[\"acc\"], width, label=\"Accruals\", color=\"steelblue\")\n    ax.barh(x + width / 2, ind_plot[\"cfo\"], width, label=\"Cash Flows\", color=\"firebrick\")\n    ax.set_yticks(x)\n    ax.set_yticklabels([f\"VSIC {int(v)}\" for v in ind_plot[\"vsic2\"]])\n    ax.set_xlabel(\"Persistence Coefficient\")\n    ax.legend()\n    ax.set_title(\"Earnings Component Persistence by Industry\")\n    plt.tight_layout()\n    plt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Accrual vs. cash flow persistence coefficients by VSIC industry. In nearly all industries, cash flow persistence exceeds accrual persistence, consistent with the differential persistence hypothesis.](32_accruals_files/figure-html/fig-persistence-bars-output-1.png){#fig-persistence-bars width=1180 height=730}\n:::\n:::\n\n\n## Market Pricing of Earnings Components {#sec-accruals-mispricing}\n\nThe persistence analysis establishes that accruals are less persistent than cash flows. The market efficiency question is whether stock prices *reflect* this difference. If investors naïvely treat both components as equally persistent, what @sloan1996stock termed \"earnings fixation,\" then a predictable component of future returns should be related to the accrual composition of current earnings.\n\n### Theoretical Framework\n\nSuppose the market prices earnings using:\n\n$$\nP_t = \\frac{1}{r} \\left[ \\hat{\\gamma}^* \\cdot E_t \\right]\n$$ {#eq-naive-pricing}\n\nwhere $\\hat{\\gamma}^*$ is the market's *perceived* persistence of aggregate earnings. Rational pricing requires:\n\n$$\nP_t = \\frac{1}{r} \\left[ \\hat{\\gamma}_a \\cdot ACC_t + \\hat{\\gamma}_c \\cdot CFO_t \\right]\n$$ {#eq-rational-pricing}\n\nwith $\\hat{\\gamma}_a < \\hat{\\gamma}_c$. If the market uses @eq-naive-pricing instead of @eq-rational-pricing, then high-accrual firms are *overpriced* (because the market overestimates the persistence of their accrual-heavy earnings) and low-accrual firms are *underpriced*.\n\n### The Abel–Mishkin Test\n\nTesting whether market pricing coefficients match rational forecasting coefficients can be done via the approach of @abel1983optimal, which avoids the complexity of the full @abel1983integrated, @mishkin1983market and @mishkin2007rational nonlinear system. The intuition is simple: if lagged earnings components are mispriced, this should be detectable in a regression of *future abnormal returns* on those components:\n\n$$\nAR_{i,t+1} = \\alpha + \\beta_a \\cdot ACC_{i,t} + \\beta_c \\cdot CFO_{i,t} + \\eta_{i,t}\n$$ {#eq-abel-mishkin}\n\nUnder efficient pricing, $\\beta_a = \\beta_c = 0$: lagged public information should have no predictive power for abnormal returns. A finding of $\\beta_a < 0$ implies that the market overprices accruals and subsequently corrects.\n\n::: {#tbl-mispricing .cell tbl-cap='Abnormal return regressions. Column (1) regresses size-adjusted returns on lagged accruals and cash flows. Column (2) uses decile ranks. A negative coefficient on accruals indicates that the market overprices the accrual component and corrects in the subsequent period.' execution_count=15}\n``` {.python .cell-code}\n# Abel-Mishkin style test\nmod_am1 = smf.ols(\"size_adj_ret ~ acc + cfo\", data=panel).fit()\nmod_am2 = smf.ols(\"size_adj_ret ~ acc_decile + cfo_decile\", data=panel).fit()\n\nam_table = pd.DataFrame({\n    \"(1) Continuous\": {\n        \"Intercept\": f\"{mod_am1.params['Intercept']:.4f} ({mod_am1.bse['Intercept']:.4f})\",\n        \"Accruals\": f\"{mod_am1.params['acc']:.4f} ({mod_am1.bse['acc']:.4f})\",\n        \"Cash Flows\": f\"{mod_am1.params['cfo']:.4f} ({mod_am1.bse['cfo']:.4f})\",\n        \"N\": f\"{int(mod_am1.nobs):,}\",\n        \"R²\": f\"{mod_am1.rsquared:.4f}\",\n    },\n    \"(2) Decile Ranks\": {\n        \"Intercept\": f\"{mod_am2.params['Intercept']:.4f} ({mod_am2.bse['Intercept']:.4f})\",\n        \"Accruals\": f\"{mod_am2.params['acc_decile']:.4f} ({mod_am2.bse['acc_decile']:.4f})\",\n        \"Cash Flows\": f\"{mod_am2.params['cfo_decile']:.4f} ({mod_am2.bse['cfo_decile']:.4f})\",\n        \"N\": f\"{int(mod_am2.nobs):,}\",\n        \"R²\": f\"{mod_am2.rsquared:.4f}\",\n    },\n})\nam_table\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>(1) Continuous</th>\n      <th>(2) Decile Ranks</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Intercept</th>\n      <td>0.0263 (0.0058)</td>\n      <td>0.0962 (0.0161)</td>\n    </tr>\n    <tr>\n      <th>Accruals</th>\n      <td>-0.5686 (0.0920)</td>\n      <td>-0.0091 (0.0016)</td>\n    </tr>\n    <tr>\n      <th>Cash Flows</th>\n      <td>-0.3538 (0.0575)</td>\n      <td>-0.0087 (0.0016)</td>\n    </tr>\n    <tr>\n      <th>N</th>\n      <td>7,000</td>\n      <td>7,000</td>\n    </tr>\n    <tr>\n      <th>R²</th>\n      <td>0.0067</td>\n      <td>0.0055</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Interpretation for Vietnam\n\nThe limited attention hypothesis of @hirshleifer2003limited provides a particularly appealing explanation for Vietnamese markets. When retail investors dominate trading, as in Vietnam, where retail participation exceeds 80% of daily turnover, information processing capacity is limited. Investors may anchor on headline earnings without decomposing into accrual and cash flow components. The absence of short-selling mechanisms (Vietnam did not introduce covered short selling until 2024) further impedes the correction of overpricing, potentially allowing the accrual anomaly to persist longer than in developed markets.\n\n## The Accrual Anomaly {#sec-accruals-anomaly}\n\n### Portfolio Returns by Accrual Decile\n\nFollowing the portfolio approach of @sloan1996stock, we compute mean size-adjusted returns for each accrual decile. If the market misprices accruals, we expect a monotonically decreasing pattern: low-accrual firms (decile 1) earn positive abnormal returns, while high-accrual firms (decile 10) earn negative abnormal returns.\n\n::: {#tbl-anomaly-deciles .cell tbl-cap='Mean size-adjusted returns by accrual decile. The hedge portfolio (long decile 1, short decile 10) return and its t-statistic are reported at the bottom.' execution_count=16}\n``` {.python .cell-code}\n# Compute annual portfolio returns (equal-weighted within decile-year)\nport_rets = (\n    panel\n    .groupby([\"year\", \"acc_decile\"])[\"size_adj_ret\"]\n    .mean()\n    .reset_index()\n)\n\n# Regression approach: decile dummies (no intercept)\nport_rets[\"acc_decile_str\"] = \"D\" + port_rets[\"acc_decile\"].astype(str).str.zfill(2)\nmod_port = smf.ols(\n    \"size_adj_ret ~ C(acc_decile, Treatment(reference=0)) - 1\",\n    data=port_rets.assign(acc_decile=port_rets[\"acc_decile\"].astype(\"category\")),\n).fit()\n\n# Mean returns by decile\ndecile_means = (\n    port_rets\n    .groupby(\"acc_decile\")[\"size_adj_ret\"]\n    .agg([\"mean\", \"std\", \"count\"])\n    .round(4)\n)\ndecile_means[\"t_stat\"] = (\n    decile_means[\"mean\"] / (decile_means[\"std\"] / np.sqrt(decile_means[\"count\"]))\n).round(2)\ndecile_means.columns = [\"Mean Return\", \"Std Dev\", \"N Years\", \"t-stat\"]\n\n# Hedge portfolio\nhedge_series = (\n    port_rets.query(\"acc_decile == 1\").set_index(\"year\")[\"size_adj_ret\"]\n    - port_rets.query(\"acc_decile == 10\").set_index(\"year\")[\"size_adj_ret\"]\n)\nhedge_mean = hedge_series.mean()\nhedge_t = hedge_mean / (hedge_series.std() / np.sqrt(len(hedge_series)))\n\nprint(f\"Hedge portfolio (D1 - D10): {hedge_mean:.4f}\")\nprint(f\"t-statistic: {hedge_t:.2f}\")\nprint()\ndecile_means\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHedge portfolio (D1 - D10): 0.0397\nt-statistic: 2.21\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Mean Return</th>\n      <th>Std Dev</th>\n      <th>N Years</th>\n      <th>t-stat</th>\n    </tr>\n    <tr>\n      <th>acc_decile</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1</th>\n      <td>0.0242</td>\n      <td>0.0471</td>\n      <td>14</td>\n      <td>1.92</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0.0135</td>\n      <td>0.0370</td>\n      <td>14</td>\n      <td>1.37</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>-0.0008</td>\n      <td>0.0596</td>\n      <td>14</td>\n      <td>-0.05</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>-0.0111</td>\n      <td>0.0317</td>\n      <td>14</td>\n      <td>-1.31</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>0.0034</td>\n      <td>0.0337</td>\n      <td>14</td>\n      <td>0.38</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>0.0086</td>\n      <td>0.0422</td>\n      <td>14</td>\n      <td>0.76</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>-0.0097</td>\n      <td>0.0318</td>\n      <td>14</td>\n      <td>-1.14</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>0.0005</td>\n      <td>0.0580</td>\n      <td>14</td>\n      <td>0.03</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>-0.0280</td>\n      <td>0.0337</td>\n      <td>14</td>\n      <td>-3.11</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>-0.0155</td>\n      <td>0.0354</td>\n      <td>14</td>\n      <td>-1.64</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Visualizing the Anomaly\n\n::: {#cell-fig-anomaly-bar .cell execution_count=17}\n``` {.python .cell-code}\ndecile_plot = port_rets.groupby(\"acc_decile\")[\"size_adj_ret\"].mean()\n\nfig, ax = plt.subplots()\ncolors = [\"steelblue\" if r > 0 else \"firebrick\" for r in decile_plot.values]\nax.bar(decile_plot.index, decile_plot.values, color=colors, edgecolor=\"white\")\nax.axhline(0, color=\"black\", linewidth=0.5)\nax.set_xlabel(\"Accrual Decile\")\nax.set_ylabel(\"Mean Size-Adjusted Return\")\nax.set_xticks(range(1, 11))\nax.yaxis.set_major_formatter(mticker.PercentFormatter(xmax=1, decimals=1))\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Mean size-adjusted returns by accrual decile. The downward slope from low-accrual to high-accrual deciles is consistent with market overpricing of the accrual component of earnings.](32_accruals_files/figure-html/fig-anomaly-bar-output-1.png){#fig-anomaly-bar width=1030 height=729}\n:::\n:::\n\n\n### Time-Series Stability\n\nA critical question for any anomaly is whether it persists over time or is concentrated in specific sub-periods. @fig-anomaly-ts plots the hedge portfolio return by year.\n\n::: {#cell-fig-anomaly-ts .cell execution_count=18}\n``` {.python .cell-code}\nfig, ax = plt.subplots()\nax.bar(hedge_series.index, hedge_series.values,\n       color=[\"steelblue\" if v > 0 else \"firebrick\" for v in hedge_series.values],\n       edgecolor=\"white\")\nax.axhline(hedge_series.mean(), color=\"black\", linestyle=\"--\", linewidth=1,\n           label=f\"Mean = {hedge_series.mean():.1%}\")\nax.axhline(0, color=\"black\", linewidth=0.5)\nax.set_xlabel(\"Year\")\nax.set_ylabel(\"Hedge Portfolio Return\")\nax.yaxis.set_major_formatter(mticker.PercentFormatter(xmax=1, decimals=0))\nax.legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Annual hedge portfolio returns (decile 1 minus decile 10) over time. Positive values indicate that low-accrual firms outperformed high-accrual firms. Year-to-year variation is substantial, reflecting the noisy nature of annual return measurement.](32_accruals_files/figure-html/fig-anomaly-ts-output-1.png){#fig-anomaly-ts width=1030 height=729}\n:::\n:::\n\n\n## Discussion and Contemporary Perspectives {#sec-accruals-discussion}\n\n### Alternative Explanations\n\nThe accrual anomaly has generated an extensive debate in the accounting and finance literature. Several alternative explanations merit consideration in the Vietnamese context:\n\n**Risk-based explanations.** @khan2008accruals argues that high-accrual firms may earn lower returns because they are *less risky*, not because they are mispriced. If the CAPM or multi-factor models fail to capture the true risk structure, what appears as an anomaly may simply be compensation for omitted risk factors. This explanation is harder to evaluate in Vietnam given the limited history of factor models calibrated to local data.\n\n**Growth and investment.** @fairfield2003accrued show that the low persistence of accruals extends to long-term accruals (capital expenditures), suggesting that the phenomenon reflects diminishing marginal returns to investment rather than earnings manipulation. In Vietnam's high-growth environment, this channel may be particularly important as firms invest aggressively during credit booms.\n\n**Data artifacts.** @kraft2006analysis identify sensitivity to outliers and look-ahead bias in the original evidence. Vietnamese financial data, with its shorter history and higher incidence of reporting errors, warrants extra vigilance on these points.\n\n**Institutional constraints.** Short-selling restrictions, prevalent in Vietnam until recently, prevent arbitrageurs from correcting overpricing. Combined with high transaction costs and limited institutional investor participation, this creates an environment where mispricing can be sustained even if sophisticated investors identify it.\n\n### State-Owned Enterprises and Accrual Quality\n\nA distinctive feature of Vietnamese markets is the prevalence of SOEs and former SOEs. Several testable hypotheses arise:\n\n1.  **Political smoothing:** SOE managers may smooth earnings to meet government targets, generating accruals that differ in nature from those of private firms.\n\n2.  **Audit quality:** @khanh2018audit find that audit quality varies systematically with ownership structure in Vietnam. Lower audit quality may allow greater accrual manipulation.\n\n3.  **Information environment:** SOEs may have weaker voluntary disclosure, increasing the information asymmetry between accruals and cash flows.\n\nThese hypotheses suggest that the accrual anomaly may exhibit cross-sectional variation along ownership dimensions unique to Vietnam.\n\n### Methodological Considerations\n\nWhen implementing this analysis with actual Vietnamese data, several practical issues require attention:\n\n**Standard errors.** Pooled OLS standard errors assume independence across firm-years. In practice, both cross-sectional correlation (common shocks within a year) and time-series correlation (firm-level persistence) are present. Clustering standard errors by firm and year (two-way clustering) or using the Fama-MacBeth procedure [@fama1973risk] with Newey-West corrections is recommended.\n\n**VAS-specific items.** Vietnamese financial statements include items without direct equivalents in Compustat, such as *chi phí trả trước* (prepaid expenses reported separately from current assets in some VAS templates). Researchers must map these carefully.\n\n**Price limits.** Daily price limits on HOSE ($\\pm$ 7%) and HNX ($\\pm$ 10%) can truncate return distributions and create serial correlation in measured returns. For return measurement over 12-month windows, this is less problematic but should be documented.\n\n**Exchange effects.** HOSE-listed firms tend to be larger and more liquid than HNX-listed firms. Separate analysis by exchange, or inclusion of exchange fixed effects, can help ensure results are not driven by liquidity differences.\n\n\n## Summary\n\nThis chapter examined accrual accounting and its implications for earnings persistence and market efficiency in the Vietnamese context. The key findings are:\n\n-   Accruals are the portion of earnings not backed by contemporaneous cash flows. They arise naturally from accrual accounting but also embed estimation errors and managerial discretion.\n-   Simulation analysis demonstrates that when accounting estimates deviate from economic truth, accrual persistence falls below cash flow persistence—providing a structural explanation for the empirical regularity.\n-   Persistence regressions confirm that the accrual component of earnings is less persistent than the cash flow component, a finding that holds across industries.\n-   Market pricing tests suggest that stock prices in Vietnamese markets may not fully incorporate the differential persistence of earnings components, giving rise to the accrual anomaly.\n\nThe Vietnamese institutional environment provides rich variation for future research on the interplay between accounting quality, investor sophistication, and market efficiency.\n\n\n<!-- ## Exercises\n\n1.  **Verify the accounting identity.** Using the simulated data from @sec-simulation, verify that $\\text{Earnings} = \\text{Accruals} + \\text{CFO}$ holds exactly. Compute the maximum absolute deviation across all firm-years.\n\n2.  **Sensitivity to parameters.** Modify the simulation function to allow $\\rho = 0$ (i.i.d. sales). How does this change the persistence of earnings and its components? What does this tell you about the role of the underlying economic process vs. accounting measurement?\n\n3.  **SOE subsample analysis.** Using the synthetic panel, estimate persistence regressions separately for SOE and non-SOE firms. Is there evidence of differential accrual quality by ownership type?\n\n4.  **Fama-MacBeth standard errors.** Re-estimate the persistence regressions using the Fama-MacBeth approach: run cross-sectional regressions year-by-year, then compute time-series means and standard errors of the coefficient estimates. Compare these standard errors to the pooled OLS standard errors.\n\n5.  **Jones model decomposition.** Implement the @jones1991earnings model to separate accruals into \"normal\" and \"abnormal\" components. The model specification is: \n\n$$\n\\frac{ACC_{i,t}}{A_{i,t-1}} = \\alpha_1 \\frac{1}{A_{i,t-1}}\n      + \\alpha_2 \\frac{\\Delta Rev_{i,t}}{A_{i,t-1}}\n      + \\alpha_3 \\frac{PPE_{i,t}}{A_{i,t-1}} + \\varepsilon_{i,t}\n$$ \n\nEstimate this cross-sectionally by year and industry. Do abnormal accruals (the residual $\\hat{\\varepsilon}$) predict returns better than total accruals?\n\n6.  **VAS vs. IFRS measurement.** Research three specific areas where VAS differs from IFRS in ways that affect accrual measurement (e.g., revenue recognition, lease accounting, financial instrument classification). For each, explain the direction and likely magnitude of the impact on measured accruals.\n\n7.  **Short-selling constraints.** Vietnam introduced limited short-selling in 2024. Design a difference-in-differences framework to test whether the introduction of short selling affects the magnitude of the accrual anomaly. What are the key identification assumptions? -->\n\n",
    "supporting": [
      "32_accruals_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}