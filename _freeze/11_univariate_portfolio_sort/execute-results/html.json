{
  "hash": "00d0a44cc41b98897829cba91683eb2a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Univariate Portfolio Sorts\nformat:\n  html:\n    toc: true\n    number-sections: true\njupyter: python3\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\nIn this chapter, we dive into portfolio sorts, one of the most widely used statistical methodologies in empirical asset pricing [e.g., @BaliEngleMurray2016]. The key application of portfolio sorts is to examine whether one or more variables can predict future excess returns. In general, the idea is to sort individual stocks into portfolios, where the stocks within each portfolio are similar with respect to a sorting variable, such as firm size. The different portfolios then represent well-diversified investments that differ in the level of the sorting variable. You can then attribute the differences in the return distribution to the impact of the sorting variable. We start by introducing univariate portfolio sorts (which sort based on only one characteristic) and tackle bivariate sorting in Value and Bivariate Sorts. \n\nA univariate portfolio sort considers only one sorting variable $x_{i,t-1}$. Here, $i$ denotes the stock and $t-1$ indicates that the characteristic is observable by investors at time $t$. The objective is to assess the cross-sectional relation between $x_{i,t-1}$ and, typically, stock excess returns $r_{i,t}$ at time $t$ as the outcome variable. To illustrate how portfolio sorts work, we use estimates for market betas from the previous chapter as our sorting variable.\n\n::: {#53d99936 .cell execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport sqlite3\nimport statsmodels.api as sm\n\nfrom plotnine import *\nfrom mizani.formatters import percent_format\nfrom regtabletotext import prettify_result\n```\n:::\n\n\n## Data Preparation\n\nWe start with loading the required data from our SQLite database introduced in Accessing and Managing Financial Data and DataCore Data. In particular, we use the monthly stock price data as our asset universe. Once we form our portfolios, we use the market factor returns to compute the risk-adjusted performance (i.e., alpha). `beta` is the dataframe with market betas computed in the previous chapter.\n\n::: {#04c52454 .cell execution_count=3}\n``` {.python .cell-code}\ntidy_finance = sqlite3.connect(database=\"data/tidy_finance_python.sqlite\")\n\nprices_monthly = (pd.read_sql_query(\n    sql=\"SELECT symbol, date, ret_excess, mktcap_lag FROM prices_monthly\",\n    con=tidy_finance,\n    parse_dates={\"date\"})\n)\n\nfactors_ff3_monthly = pd.read_sql_query(\n  sql=\"SELECT date, mkt_excess FROM factors_ff3_monthly\",\n  con=tidy_finance,\n  parse_dates={\"date\"}\n)\n\nbeta = pd.read_sql_query(\n  sql=\"SELECT symbol, date, beta FROM beta_monthly\",\n  con=tidy_finance,\n  parse_dates={\"date\"}\n)\n```\n:::\n\n\n## Sorting by Market Beta\n\nNext, we merge our sorting variable with the return data. We use the one-month *lagged* betas as a sorting variable to ensure that the sorts rely only on information available when we create the portfolios. To lag stock beta by one month, we add one month to the current date and join the resulting information with our return data. This procedure ensures that month $t$ information is available in month $t+1$. You may be tempted to simply use a call such as `prices_monthly['beta_lag'] = prices_monthly.groupby('symbol')['beta'].shift(1)` instead. This procedure, however, does not work correctly if there are implicit missing values in the time series.\n\n::: {#5e19d7d2 .cell execution_count=4}\n``` {.python .cell-code}\nbeta_lag = (beta\n  .assign(date=lambda x: x[\"date\"]+pd.DateOffset(months=1))\n  .get([\"symbol\", \"date\", \"beta\"])\n  .rename(columns={\"beta\": \"beta_lag\"})\n  .dropna()\n)\n\ndata_for_sorts = (prices_monthly\n  .merge(beta_lag, how=\"inner\", on=[\"symbol\", \"date\"])\n  .dropna()\n)\n```\n:::\n\n\nThe first step to conduct portfolio sorts is to calculate periodic breakpoints that you can use to group the stocks into portfolios. For simplicity, we start with the median lagged market beta as the single breakpoint. We then compute the value-weighted returns for each of the two resulting portfolios, which means that the lagged market capitalization determines the weight in `np.average()`.\n\n::: {#b7e4e75f .cell execution_count=5}\n``` {.python .cell-code}\nbeta_portfolios = (\n    data_for_sorts\n    .groupby(\"date\")\n    .apply(lambda x: (\n        x.assign(\n            portfolio=pd.qcut(x[\"beta_lag\"], q=[0, 0.5, 1], labels=[\"low\", \"high\"]),\n            date=x.name\n        )\n    ))\n    .reset_index(drop=True)\n    .groupby([\"portfolio\", \"date\"])\n    .apply(lambda x: np.average(x[\"ret_excess\"], weights=x[\"mktcap_lag\"]))\n    .reset_index(name=\"ret\")\n    .dropna(subset=['ret'])\n)\nbeta_portfolios.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>portfolio</th>\n      <th>date</th>\n      <th>ret</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>low</td>\n      <td>2016-08-31</td>\n      <td>-0.016507</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>low</td>\n      <td>2016-09-30</td>\n      <td>-0.089155</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>low</td>\n      <td>2016-11-30</td>\n      <td>-0.015080</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>low</td>\n      <td>2017-01-31</td>\n      <td>0.004113</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>low</td>\n      <td>2017-02-28</td>\n      <td>0.035101</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Performance Evaluation\n\nWe can construct a long-short strategy based on the two portfolios: buy the high-beta portfolio and, at the same time, short the low-beta portfolio. Thereby, the overall position in the market is net-zero.\n\n::: {#3f0c8d0a .cell execution_count=6}\n``` {.python .cell-code}\nbeta_longshort = (beta_portfolios\n  .pivot_table(index=\"date\", columns=\"portfolio\", values=\"ret\")\n  .reset_index()\n  .assign(long_short=lambda x: x[\"high\"]-x[\"low\"])\n)\n```\n:::\n\n\nWe compute the average return and the corresponding standard error to test whether the long-short portfolio yields on average positive or negative excess returns. In the asset pricing literature, one typically adjusts for autocorrelation by using @Newey1987 $t$-statistics to test the null hypothesis that average portfolio excess returns are equal to zero. One necessary input for Newey-West standard errors is a chosen bandwidth based on the number of lags employed for the estimation. Researchers often default to choosing a pre-specified lag length of six months (which is not a data-driven approach). We do so in the `fit()` function by indicating the `cov_type` as `HAC` and providing the maximum lag length through an additional keywords dictionary.\n\n::: {#8d856d5f .cell execution_count=7}\n``` {.python .cell-code}\nmodel_fit = (sm.OLS.from_formula(\n    formula=\"long_short ~ 1\",\n    data=beta_longshort\n  )\n  .fit(cov_type=\"HAC\", cov_kwds={\"maxlags\": 6})\n)\nprettify_result(model_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOLS Model:\nlong_short ~ 1\n\nCoefficients:\n           Estimate  Std. Error  t-Statistic  p-Value\nIntercept     0.006       0.006        1.018    0.309\n\nSummary statistics:\n- Number of observations: 53\n- R-squared: 0.000, Adjusted R-squared: 0.000\n- F-statistic not available\n\n```\n:::\n:::\n\n\nThe results indicate that we cannot reject the null hypothesis of average returns being equal to zero. Our portfolio strategy using the median as a breakpoint does not yield any abnormal returns. Is this finding surprising if you reconsider the CAPM? It certainly is. The CAPM predicts that high-beta stocks should yield higher expected returns. Our portfolio sort implicitly mimics an investment strategy that finances high-beta stocks by shorting low-beta stocks. Therefore, one should expect that the average excess returns yield a return that is above the risk-free rate.\n\n## Functional Programming for Portfolio Sorts\n\nNow, we take portfolio sorts to the next level. We want to be able to sort stocks into an arbitrary number of portfolios. For this case, functional programming is very handy: we define a function that gives us flexibility concerning which variable to use for the sorting, denoted by `sorting_variable`. We use `np.quantile()` to compute breakpoints for `n_portfolios`. Then, we assign portfolios to stocks using the `pd.cut()` function. The output of the following function is a new column that contains the number of the portfolio to which a stock belongs.\n\nIn some applications, the variable used for the sorting might be clustered (e.g., at a lower bound of 0). Then, multiple breakpoints may be identical, leading to empty portfolios. Similarly, some portfolios might have a very small number of stocks at the beginning of the sample. Cases where the number of portfolio constituents differs substantially due to the distribution of the characteristics require careful consideration and, depending on the application, might require customized sorting approaches.\n\n::: {#5b6ca05e .cell execution_count=8}\n``` {.python .cell-code}\ndef assign_portfolio(data, sorting_variable, n_portfolios):\n    \"\"\"Assign portfolios to a bin between breakpoints.\"\"\"\n    \n    breakpoints = np.quantile(\n      data[sorting_variable].dropna(), \n      np.linspace(0, 1, n_portfolios + 1), \n      method=\"linear\"\n    )\n    \n    assigned_portfolios = pd.cut(\n      data[sorting_variable],\n      bins=breakpoints,\n      labels=range(1, breakpoints.size),\n      include_lowest=True,\n      right=False\n    )\n    \n    return assigned_portfolios\n```\n:::\n\n\nWe can use the above function to sort stocks into ten portfolios each month using lagged betas and compute value-weighted returns for each portfolio. Note that we transform the portfolio column to a factor variable because it provides more convenience for the figure construction below.\n\n::: {#25024556 .cell execution_count=9}\n``` {.python .cell-code}\nbeta_portfolios = (data_for_sorts\n  .groupby(\"date\")\n  .apply(lambda x: x.assign(\n      portfolio=assign_portfolio(x, \"beta_lag\", 10)\n    ), include_groups=False\n  )\n  .reset_index(level=\"date\")\n  .groupby([\"portfolio\", \"date\"])\n  .apply(lambda x: pd.Series({\n      \"ret\": np.average(x[\"ret_excess\"], weights=x[\"mktcap_lag\"])\n    }), include_groups=False\n  )\n  .reset_index()\n  .merge(factors_ff3_monthly, how=\"left\", on=\"date\")\n)\n```\n:::\n\n\n## More Performance Evaluation\n\nIn the next step, we compute summary statistics for each beta portfolio. Namely, we compute CAPM-adjusted alphas, the beta of each beta portfolio, and average returns.\n\n::: {#48a03aa3 .cell execution_count=10}\n``` {.python .cell-code}\nbeta_portfolios_summary = (beta_portfolios\n  .groupby(\"portfolio\")\n  .apply(lambda x: pd.Series({\n      \"alpha\": sm.OLS.from_formula(\n          formula=\"ret ~ 1 + mkt_excess\", \n          data=x\n        ).fit().params[\"Intercept\"],\n      \"beta\": sm.OLS.from_formula(\n          formula=\"ret ~ 1 + mkt_excess\", \n          data=x\n        ).fit().params[\"mkt_excess\"],\n      \"ret\": x[\"ret\"].mean()\n    }), include_groups=False\n  )\n  .reset_index()\n)\nbeta_portfolios_summary\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>portfolio</th>\n      <th>alpha</th>\n      <th>beta</th>\n      <th>ret</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>0.007031</td>\n      <td>0.356225</td>\n      <td>0.003892</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>-0.004215</td>\n      <td>0.227882</td>\n      <td>-0.005509</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>-0.010169</td>\n      <td>0.390216</td>\n      <td>-0.011241</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>-0.014205</td>\n      <td>0.388342</td>\n      <td>-0.015732</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>-0.007220</td>\n      <td>0.616833</td>\n      <td>-0.009723</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>6</td>\n      <td>0.010648</td>\n      <td>0.976502</td>\n      <td>0.006577</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>7</td>\n      <td>-0.010739</td>\n      <td>0.679145</td>\n      <td>-0.012645</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>8</td>\n      <td>-0.002757</td>\n      <td>0.991774</td>\n      <td>-0.006963</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>9</td>\n      <td>-0.003448</td>\n      <td>0.904886</td>\n      <td>-0.007174</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>10</td>\n      <td>0.010675</td>\n      <td>1.376356</td>\n      <td>0.004944</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n@fig-701 illustrates the CAPM alphas of beta-sorted portfolios.\n\n::: {#cell-fig-701 .cell execution_count=11}\n``` {.python .cell-code}\nbeta_portfolios_figure = (\n  ggplot(\n    beta_portfolios_summary, \n    aes(x=\"portfolio\", y=\"alpha\", fill=\"portfolio\")\n  )\n  + geom_bar(stat=\"identity\")\n  + labs(\n      x=\"Portfolio\", y=\"CAPM alpha\", fill=\"Portfolio\",\n      title=\"CAPM alphas of beta-sorted portfolios\"\n    )\n  + scale_y_continuous(labels=percent_format())\n  + theme(legend_position=\"none\")\n)\nbeta_portfolios_figure.show()\n```\n\n::: {.cell-output .cell-output-display}\n![The figure shows CAPM alphas of beta-sorted portfolios. Portfolios are sorted into deciles each month based on their estimated CAPM beta. The bar charts indicate the CAPM alpha of the resulting portfolio returns during the sample period.](11_univariate_portfolio_sort_files/figure-html/fig-701-output-1.png){#fig-701 width=672 height=480 fig-alt='Title: CAPM alphas of beta-sorted portfolios. The figure shows bar charts of alphas of beta-sorted portfolios with the decile portfolio on the horizontal axis and the corresponding CAPM alpha on the vertical axis.' fig-pos='htb'}\n:::\n:::\n\n\nUnlike the well-documented \"betting against beta\" anomaly in US markets, where low-beta portfolios exhibit positive alphas and high-beta portfolios exhibit negative alphas in a monotonic pattern, the Vietnamese market shows no clear relationship between beta and risk-adjusted returns. The alphas fluctuate without a discernible trend across deciles. This lack of pattern likely reflects the limited sample period rather than a definitive conclusion about beta pricing in Vietnam. With such a short time series, the portfolio-level CAPM regressions contain substantial estimation noise, making it difficult to detect subtle anomalies. Longer sample periods would be needed to draw reliable conclusions about whether the low-beta anomaly exists in the Vietnamese equity market.\n\n## Security Market Line and Beta Portfolios\n\nThe CAPM predicts that our portfolios should lie on the security market line (SML). The slope of the SML is equal to the market risk premium and reflects the risk-return trade-off at any given time.  @fig-702 illustrates the security market line: We see that (not surprisingly) the high-beta portfolio returns have a high correlation with the market returns. However, it seems like the average excess returns for high-beta stocks are lower than what the security market line implies would be an \"appropriate\" compensation for the high market risk. \n\n::: {#cell-fig-702 .cell execution_count=12}\n``` {.python .cell-code}\nsml_capm = (sm.OLS.from_formula(\n    formula=\"ret ~ 1 + beta\", \n    data=beta_portfolios_summary\n  )\n  .fit()\n  .params\n)\n\nsml_figure = (\n  ggplot(\n    beta_portfolios_summary,\n    aes(x=\"beta\", y=\"ret\", color=\"factor(portfolio)\")\n  )\n  + geom_point()\n  + geom_abline(\n      intercept=0, slope=factors_ff3_monthly[\"mkt_excess\"].mean(), linetype=\"solid\"\n    )\n  + geom_abline(\n      intercept=sml_capm[\"Intercept\"], slope=sml_capm[\"beta\"], linetype=\"dashed\"\n    )\n  + labs(\n      x=\"Beta\", y=\"Excess return\", color=\"Portfolio\",\n      title=\"Average portfolio excess returns and beta estimates\"\n    )\n  + scale_x_continuous(limits=(0, 2))\n  + scale_y_continuous(labels=percent_format())\n)\nsml_figure.show()\n```\n\n::: {.cell-output .cell-output-display}\n![The figure shows average portfolio excess returns and beta estimates. Excess returns are computed as CAPM alphas of the beta-sorted portfolios. The horizontal axis indicates the CAPM beta of the resulting beta-sorted portfolio return time series. The dashed line indicates the slope coefficient of a linear regression of excess returns on portfolio betas.](11_univariate_portfolio_sort_files/figure-html/fig-702-output-1.png){#fig-702 width=672 height=480 fig-alt='Title: Average portfolio excess returns and beta estimates. The figure shows a scatter plot of the average excess returns per beta portfolio with average beta estimates per portfolio on the horizontal axis and average excess returns on the vertical axis. An increasing solid line indicates the security market line. A dashed increasing line with lower slope than the security market line indicates that the CAPM prediction is not valid for the data.' fig-pos='htb'}\n:::\n:::\n\n\nTo provide more evidence against the CAPM predictions, we again form a long-short strategy that buys the high-beta portfolio and shorts the low-beta portfolio.\n\n::: {#efe304b5 .cell execution_count=13}\n``` {.python .cell-code}\nbeta_longshort = (beta_portfolios\n  .assign(\n    portfolio=lambda x: (\n      x[\"portfolio\"].apply(\n        lambda y: \"high\" if y == x[\"portfolio\"].max()\n        else (\"low\" if y == x[\"portfolio\"].min()\n        else y)\n      )\n    )\n  )\n  .query(\"portfolio in ['low', 'high']\")\n  .pivot_table(index=\"date\", columns=\"portfolio\", values=\"ret\")\n  .assign(long_short=lambda x: x[\"high\"]-x[\"low\"])\n  .merge(factors_ff3_monthly, how=\"left\", on=\"date\")\n)\n```\n:::\n\n\nAgain, the resulting long-short strategy does not exhibit statistically significant returns. \n\n::: {#49ea3c30 .cell execution_count=14}\n``` {.python .cell-code}\nmodel_fit = (sm.OLS.from_formula(\n    formula=\"long_short ~ 1\", \n    data=beta_longshort\n  )\n  .fit(cov_type=\"HAC\", cov_kwds={\"maxlags\": 1})\n)\nprettify_result(model_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOLS Model:\nlong_short ~ 1\n\nCoefficients:\n           Estimate  Std. Error  t-Statistic  p-Value\nIntercept     0.001       0.011        0.095    0.924\n\nSummary statistics:\n- Number of observations: 53\n- R-squared: 0.000, Adjusted R-squared: 0.000\n- F-statistic not available\n\n```\n:::\n:::\n\n\nHowever, controlling for the effect of beta, the long-short portfolio yields a CAPM-adjusted alpha. The results can provide evidence regarding the validity of the CAPM in the Vietnamese market. The betting-against-beta factor has been documented extensively in developed markets [@Frazzini2014]. Betting-against-beta corresponds to a strategy that shorts high-beta stocks and takes a (levered) long position in low-beta stocks. If borrowing constraints prevent investors from taking positions on the security market line, they are instead incentivized to buy high-beta stocks, which leads to a relatively higher price (and therefore lower expected returns than implied by the CAPM) for such high-beta stocks. As a result, the betting-against-beta strategy earns from providing liquidity to capital-constrained investors with lower risk aversion.\n\n::: {#768738bf .cell execution_count=15}\n``` {.python .cell-code}\nmodel_fit = (sm.OLS.from_formula(\n    formula=\"long_short ~ 1 + mkt_excess\", \n    data=beta_longshort\n  )\n  .fit(cov_type=\"HAC\", cov_kwds={\"maxlags\": 1})\n)\nprettify_result(model_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOLS Model:\nlong_short ~ 1 + mkt_excess\n\nCoefficients:\n            Estimate  Std. Error  t-Statistic  p-Value\nIntercept      0.004       0.009        0.394    0.694\nmkt_excess     1.020       0.116        8.784    0.000\n\nSummary statistics:\n- Number of observations: 52\n- R-squared: 0.527, Adjusted R-squared: 0.518\n- F-statistic: 77.156 on 1 and 50 DF, p-value: 0.000\n\n```\n:::\n:::\n\n\n@fig-703 shows the annual returns of the extreme beta portfolios we are mainly interested in. The figure illustrates the patterns over the sample period; each portfolio exhibits periods with positive and negative annual returns. \n\n::: {#cell-fig-703 .cell execution_count=16}\n``` {.python .cell-code}\nbeta_longshort_year = (beta_longshort\n  .assign(year=lambda x: x[\"date\"].dt.year)\n  .groupby(\"year\")\n  .aggregate(\n    low=(\"low\", lambda x: (1+x).prod()-1),\n    high=(\"high\", lambda x: (1+x).prod()-1),\n    long_short=(\"long_short\", lambda x: (1+x).prod()-1)\n  )\n  .reset_index()\n  .melt(id_vars=\"year\", var_name=\"name\", value_name=\"value\")\n)\n\nbeta_longshort_figure = (\n  ggplot(\n    beta_longshort_year, \n    aes(x=\"year\", y=\"value\", fill=\"name\")\n  )\n  + geom_col(position=\"dodge\")\n  + facet_wrap(\"~name\", ncol=1)\n  + labs(x=\"\", y=\"\", title=\"Annual returns of beta portfolios\")\n  + scale_y_continuous(labels=percent_format())\n  + theme(legend_position=\"none\")\n)\nbeta_longshort_figure.show()\n```\n\n::: {.cell-output .cell-output-display}\n![The figure shows annual returns of beta portfolios. We construct portfolios by sorting stocks into high and low based on their estimated CAPM beta. Long short indicates a strategy that goes long into high beta stocks and short low beta stocks.](11_univariate_portfolio_sort_files/figure-html/fig-703-output-1.png){#fig-703 width=672 height=480 fig-alt='Title: Annual returns of beta portfolios. The figure shows bar charts of annual returns of long, short, and long-short beta portfolios with years on the horizontal axis and returns on the vertical axis. Each portfolio is plotted in its own facet.' fig-pos='htb'}\n:::\n:::\n\n\nThe high-beta portfolio and low-beta portfolio both exhibit substantial year-to-year variation. The long-short portfolio, which goes long high-beta stocks and short low-beta stocks, shows no consistent pattern of positive returns. This erratic performance reinforces our earlier finding that the beta-return relationship in the Vietnamese market does not conform to theoretical CAPM predictions during our sample period. The high volatility of annual long-short returns highlights the substantial risk inherent in such a strategy, particularly in an emerging market context with a limited sample period.\n\n## Key Takeaways\n\n1. Univariate portfolio sorts assess whether a single firm characteristic, like lagged market beta, can predict future excess returns.\n\n2. Portfolios are formed each month using quantile breakpoints, with returns computed using value-weighted averages to reflect realistic investment strategies.\n\n3. A long-short strategy based on beta-sorted portfolios fails to generate significant positive excess returns in the Vietnamese market, contradicting CAPM predictions that higher beta should yield higher returns.\n\n4. The analysis provides a framework for examining the \"betting against beta\" anomaly, where low-beta portfolios may deliver higher alphas than high-beta portfolios, offering evidence regarding the validity of the CAPM.\n\n5. The functional programming capabilities of Python enable scalable and flexible portfolio sorting, making it easy to analyze multiple characteristics and portfolio configurations.\n\n6. Emerging markets like Vietnam may exhibit different beta-return relationships compared to developed markets, highlighting the importance of conducting market-specific empirical analysis rather than assuming universal applicability of asset pricing anomalies.\n\n",
    "supporting": [
      "11_univariate_portfolio_sort_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}