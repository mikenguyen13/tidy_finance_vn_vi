{
  "hash": "742011a4a3716115e56d24e2c623563d",
  "result": {
    "engine": "jupyter",
    "markdown": "# Xây dựng lãi suất phi rủi ro tại Việt Nam\n\n::: callout-note\nTrong chương này, chúng ta sẽ giải quyết một vấn đề đơn giản nhưng quan trọng: làm thế nào để xây dựng chuỗi lãi suất phi rủi ro cho nghiên cứu tài chính thực nghiệm tại Việt Nam. Chúng ta sẽ đánh giá các chỉ số thay thế hiện có, chẳng hạn như lợi suất trái phiếu chính phủ, lãi suất liên ngân hàng qua đêm và lãi suất chính sách của Ngân hàng Nhà nước Việt Nam (SBV), phát triển các quy trình nội suy và điều chỉnh tần số, và định lượng độ nhạy của các kết quả định giá tài sản chính đối với việc lựa chọn chỉ số thay thế lãi suất phi rủi ro.\n:::\n\nLãi suất phi rủi ro là con số quan trọng nhất trong lĩnh vực tài chính. Nó là cơ sở cho lợi nhuận vượt trội, lãi suất chiết khấu, phí bảo hiểm nhân tố, chi phí vốn chủ sở hữu, đánh giá hiệu suất và định giá phái sinh. Mặc dù đóng vai trò nền tảng như vậy, lãi suất phi rủi ro thường được coi là một con số cố định: một con số được lấy từ cơ sở dữ liệu và đưa vào các công thức mà không cần suy nghĩ thêm. Tại các thị trường phát triển với thị trường chứng khoán chính phủ sâu rộng và thanh khoản cao, cách tiếp cận hời hợt này thường không gây hại. Nhưng ở Việt Nam thì không phải vậy.\n\nThị trường trái phiếu của Việt Nam khá mỏng, phân mảnh và đặc trưng bởi việc phát hành trái phiếu chính phủ ngắn hạn không đều đặn. Không có một lãi suất phi rủi ro duy nhất, được chấp nhận rộng rãi, tương tự như lãi suất tín phiếu kho bạc kỳ hạn 1 tháng – vốn là nền tảng cho hầu hết các nghiên cứu định giá tài sản tại các thị trường phát triển. Thay vào đó, các nhà nghiên cứu phải lựa chọn giữa các chỉ số thay thế không hoàn hảo, mỗi chỉ số đều có những ưu điểm và hạn chế riêng. Sự lựa chọn này không hề đơn giản: các chỉ số thay thế khác nhau có thể tạo ra lợi nhuận vượt trội, phí bảo hiểm nhân tố và ước tính định giá khác nhau đáng kể.\n\nChương này trình bày một phương pháp tiếp cận có hệ thống để xây dựng lãi suất phi rủi ro. Chúng ta bắt đầu với các yêu cầu lý thuyết đối với một tài sản phi rủi ro, sau đó đánh giá các chỉ số thay thế hiện có của Việt Nam so với các yêu cầu này. Chúng ta xây dựng chuỗi lãi suất phi rủi ro hàng tháng theo các thông số kỹ thuật khác nhau, trình bày các kỹ thuật điều chỉnh tần số và nội suy, và tiến hành phân tích độ nhạy để định lượng ảnh hưởng của việc lựa chọn chỉ số thay thế đến các kết quả tiếp theo.\n\n## Vai trò của lãi suất phi rủi ro trong tài chính\n\n### Lợi nhuận vượt mức\n\nViệc sử dụng cơ bản nhất của tỷ lệ không rủi ro là tính toán lợi nhuận vượt mức. Lợi nhuận vượt quá trên tài sản $i$ trong kỳ $t$ là:\n\n$$\nr_{i,t}^{e} = r_{i,t} - r_{f,t}\n$$ {#eq-excess-return}\n\ntrong đó $r_{i,t}$ là lợi nhuận thô và $r_{f,t}$ là tỷ lệ không rủi ro trong cùng một khoảng thời gian, bằng cùng một loại tiền tệ và theo cùng một quy ước lãi kép. Lợi nhuận vượt mức cô lập khoản bồi thường cho rủi ro gánh chịu, loại bỏ lợi nhuận có thể kiếm được mà không phải chịu rủi ro.\n\nViệc đo sai $r{f,t}$ trực tiếp làm ô nhiễm mọi quan sát lợi nhuận dư thừa và mở rộng ra, mọi số lượng bắt nguồn từ lợi nhuận vượt mức. Nếu $r_{f,t}$ bị thiên vị đi lên một cách có hệ thống, lợi nhuận vượt quá bị đánh giá thấp một cách có hệ thống, phí bảo hiểm nhân tố bị nén và chi phí vốn chủ sở hữu bị phóng đại.\n\n### Phí bảo hiểm yếu tố\n\nTrong mô hình ba yếu tố @Fama1993, phí bảo hiểm rủi ro thị trường là:\n\n$$\n\\text{MKTRF}_t = r_{m,t} - r_{f,t}\n$$ {#eq-mktrf}\n\ntrong đó $r_{m,t}$ là lợi suất thị trường được tính theo giá trị. Phần bù rủi ro theo quy mô (SMB) và giá trị (HML) được định nghĩa là lợi suất của các danh mục đầu tư mua-bán và không phụ thuộc trực tiếp vào $r_{f,t}$. Tuy nhiên, hệ số chặn (alpha) từ hồi quy chuỗi thời gian của lợi suất vượt trội của bất kỳ danh mục đầu tư nào dựa trên các yếu tố lại phụ thuộc vào $r_{f,t}$ thông qua biến phụ thuộc. Lãi suất phi rủi ro bị sai lệch sẽ làm dịch chuyển tất cả các alpha một cách đồng đều.\n\n### Tỷ lệ chiết khấu và định giá\n\nMô hình dòng tiền chiết khấu định giá một công ty như sau:\n\n$$\nV_0 = \\sum_{t=1}^{\\infty} \\frac{E[CF_t]}{(1 + r_{WACC})^t}\n$$ {#eq-dcf}\n\ntrong đó chi phí vốn bình quân gia quyền (WACC) phụ thuộc vào chi phí vốn chủ sở hữu, do đó phụ thuộc vào tỷ lệ phi rủi ro thông qua Mô hình định giá tài sản vốn:\n\n$$\nr_{e} = r_f + \\beta_i (\\bar{r}_m - r_f)\n$$ {#eq-capm-cost}\n\nSai số 100 điểm cơ bản trong $r_f$ sẽ ảnh hưởng đến chi phí vốn chủ sở hữu và có thể làm thay đổi giá trị hiện tại của dòng tiền dài hạn từ 10-20%, tùy thuộc vào đặc điểm thời gian đáo hạn.\n\n### Đánh giá hiệu suất\n\nCác thước đo hiệu suất được điều chỉnh theo rủi ro, chẳng hạn như hệ số Sharpe:\n\n$$\n\\text{SR} = \\frac{\\bar{r}_p - \\bar{r}_f}{\\sigma(r_p - r_f)}\n$$ {#eq-sharpe}\n\nvà alpha của Jensen:\n\n$$\n\\alpha = \\bar{r}_p - r_f - \\hat{\\beta}_p (\\bar{r}_m - r_f)\n$$ {#eq-jensen}\n\nCả hai đều phụ thuộc trực tiếp vào $r_f$. Tỷ lệ Sharpe đặc biệt nhạy cảm vì mẫu số (biến động lợi nhuận vượt mức) cũng bị ảnh hưởng bởi mức độ và sự thay đổi của $r_f$.\n\n## \"Không rủi ro\" có nghĩa là gì trong thực tế?\n\nMột tài sản thực sự không có rủi ro phải đáp ứng đồng thời bốn điều kiện (@tbl-rf-requirements).\n\n| Điều kiện | Định nghĩa | Thử thách thực tế |\n|--------------------|--------------------|--------------------------------|\n| Không có rủi ro vỡ nợ | Tổ chức phát hành không thể không thanh toán | Chỉ nợ có chủ quyền bằng đồng tiền của chính mình mới đủ điều kiện |\n| Dòng tiền đã biết | Khoản thanh toán là chắc chắn trước | Loại trừ các công cụ lãi suất thả nổi |\n| Không có rủi ro tái đầu tư | Thời gian đáo hạn phù hợp với thời gian đầu tư | Yêu cầu chứng khoán không có phiếu giảm giá có kỳ hạn chính xác |\n| Tính thanh khoản cao | Có thể giao dịch với chi phí thấp | Thị trường trái phiếu chính phủ mỏng thất bại trong bài kiểm tra này |\n\n: Yêu cầu đối với tài sản không rủi ro {#tbl-rf-requirements}\n\nKhông có tài sản nào trong thế giới thực đáp ứng hoàn hảo cả bốn điều kiện. Ngay cả trong thị trường trái phiếu chính phủ sâu nhất, vẫn có một khoản phí thanh khoản cao hơn đối với chứng khoán ngoài hoạt động và lợi suất thuận tiện trong các đợt phát hành đang hoạt động [@krishnamurthy2012aggregate]. Câu hỏi thực tế là: công cụ hiện có nào gần nhất?\n\n### Proxy lý tưởng\n\nProxy tỷ lệ không rủi ro lý tưởng cho nghiên cứu định giá tài sản thực nghiệm có các thuộc tính sau:\n\n1. **Kỳ hạn ngắn**: Giảm thiểu rủi ro tái đầu tư và ô nhiễm phí bảo hiểm có kỳ hạn. Lựa chọn thông thường là đáo hạn 1 tháng.\n2. **Được chính phủ hậu thuẫn**: Loại bỏ rủi ro tín dụng (bằng nội tệ).\n3. **Giao dịch tích cực**: Đảm bảo rằng lợi nhuận quan sát được phản ánh các điều kiện thị trường hiện tại.\n4. **Phát hành thường xuyên**: Cung cấp một chuỗi thời gian liên tục mà không có khoảng trống.\n5. **Phương pháp nhất quán**: Tính toán năng suất rõ ràng và có thể so sánh theo thời gian.\n\n## Proxy có sẵn tại Việt Nam\n\nCơ sở hạ tầng tài chính của Việt Nam cung cấp một số công cụ ứng cử viên, không có công cụ nào đáp ứng hoàn toàn tất cả các tiêu chí. Chúng tôi lần lượt đánh giá từng công cụ.\n\n### Lợi suất trái phiếu chính phủ\n\nChính phủ Việt Nam phát hành trái phiếu trong một loạt các kỳ hạn thông qua Kho bạc Nhà nước và Thị trường Trái phiếu Việt Nam (VBM). Các đặc điểm chính (tbl-govt-bond-characteristics)\n\n| Feature | Description |\n|---|---|\n| Issuer | State Treasury of Vietnam |\n| Primary market | Auction through HNX |\n| Available maturities | 1, 2, 3, 5, 7, 10, 15, 20, 30 years |\n| Shortest benchmark | 1-year (sometimes shorter tenors via T-bills) |\n| Coupon structure | Fixed, semi-annual |\n| Issuance frequency | Regular weekly/bi-weekly auctions |\n| Secondary market liquidity | Concentrated in 3-5 year segment; short end is thin |\n| Data availability | Available through DataCore.vn |\n\n: Vietnamese Government Bond Characteristics {#tbl-govt-bond-characteristics}\n\n\nThe primary limitation of government bond yields as a risk-free proxy is the scarcity of short-maturity securities. One-year bonds are the shortest regularly issued benchmark, and their yield includes a term premium that is absent from a true risk-free rate. Treasury bills (maturity \\< 1 year) are issued irregularly and in small volumes, making them unsuitable as a continuous series.\n\n### Interbank Overnight Rate\n\nThe Vietnam interbank market sets overnight lending rates between commercial banks. The overnight rate is reported by the SBV.\n\n**Advantages**: Very short maturity (overnight), high frequency (daily), reflects actual borrowing costs in the financial system.\n\n**Limitations**: Reflects banking sector credit risk (interbank default risk, though small), can be volatile during liquidity crunches, and does not correspond to a tradeable zero-coupon instrument.\n\n### SBV Policy Rates\n\nThe State Bank of Vietnam sets several administered rates (@tbl-sbv-rates).\n\n| Rate | Role | Frequency of Change |\n|------------------|------------------|------------------------------------|\n| Refinancing rate | Rate at which SBV lends to banks | Infrequent (policy meetings) |\n| Discount rate | Rate for rediscounting eligible paper | Infrequent |\n| Overnight lending rate | Ceiling for interbank overnight | Infrequent |\n| Deposit rate cap | Maximum rate banks can pay on deposits | Infrequent |\n\n: SBV Policy Rates {#tbl-sbv-rates}\n\n**Advantages**: Stable (changes infrequently), reflects the monetary policy stance, available for the entire sample period.\n\n**Limitations**: Not a traded return (i.e., no investor can actually earn the policy rate). Represents an administrative target, not a market-clearing price. Responds to macroeconomic conditions with a lag.\n\n### Savings Deposit Rates\n\nCommercial banks offer term deposits at rates subject to SBV caps. Short-term (1-month or 3-month) deposit rates are sometimes used as informal risk-free proxies in practitioner contexts.\n\n**Advantages**: Represent an investable return for small investors, widely available.\n\n**Limitations**: Subject to bank credit risk, vary across banks, caps create a ceiling that may not reflect true equilibrium rates, not standardized for research use.\n\n### Summary Comparison\n\n\n## Constructing the Risk-Free Rate Series\n\nWe now construct alternative monthly risk-free rate series and examine their properties.\n\n### Loading and Cleaning Rate Data\n\n::: {#load-rf-data .cell execution_count=3}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\n# Assume rf_data contains: date, rate_type, rate_annual (annualized, in %)\nrf_raw = pd.read_parquet(\"data/risk_free_rates.parquet\")\n\n# Preview available rate types\nprint(\"Available rate types:\")\nprint(rf_raw[\"rate_type\"].value_counts())\n```\n:::\n\n\n::: {#fig-rf-raw-series .cell execution_count=4}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8, 4.5))\n\ncolors = {\n    \"govt_bond_1y\": \"#2C73D2\",\n    \"interbank_overnight\": \"#FF6B6B\",\n    \"sbv_refinancing\": \"#5DCEAF\",\n    \"tbill_3m\": \"#FFB347\",\n    \"deposit_1m\": \"#B19CD9\"\n}\n\nfor rate_type, color in colors.items():\n    subset = rf_raw[rf_raw[\"rate_type\"] == rate_type].sort_values(\"date\")\n    if len(subset) > 0:\n        ax.plot(\n            subset[\"date\"], subset[\"rate_annual\"],\n            label=rate_type.replace(\"_\", \" \").title(),\n            color=color, linewidth=1.2, alpha=0.85\n        )\n\nax.set_ylabel(\"Annualized Rate (%)\")\nax.set_xlabel(\"\")\nax.legend(frameon=False, fontsize=9, loc=\"upper right\")\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n### Frequency Alignment\n\nAsset pricing tests require monthly risk-free rates. Raw data may arrive at daily, weekly, or irregular frequencies. We use the following conversion logic:\n\n**Daily to monthly**: Take the average of daily rates within each month, then convert from annualized to monthly.\n\n**Irregular to monthly**: For series with gaps (e.g., treasury bills), forward-fill the most recent observation, then average within each month.\n\n**Annualized to monthly**: Under simple compounding, $r_f^{monthly} = r_f^{annual} / 12$. Under continuous compounding, $r_f^{monthly} = r_f^{annual} / 12$ (since continuous rates are additive). We use simple compounding for consistency with the convention that stock returns are computed as arithmetic returns.\n\n::: {#construct-monthly-rf .cell execution_count=5}\n``` {.python .cell-code}\n# Construct monthly risk-free rates from each proxy\n\ndef construct_monthly_rf(rf_raw, rate_type, method=\"mean\"):\n    \"\"\"\n    Convert raw rate data to monthly frequency.\n\n    Parameters\n    ----------\n    rf_raw : pd.DataFrame\n        Raw rate data with columns: date, rate_type, rate_annual\n    rate_type : str\n        Which rate proxy to use\n    method : str\n        Aggregation method: 'mean', 'last', or 'first'\n\n    Returns\n    -------\n    pd.DataFrame\n        Monthly risk-free rate with columns: date, rf_monthly\n    \"\"\"\n    subset = (\n        rf_raw[rf_raw[\"rate_type\"] == rate_type]\n        .sort_values(\"date\")\n        .set_index(\"date\")\n    )\n\n    # Forward-fill gaps (for irregular series)\n    subset = subset.resample(\"D\").ffill()\n\n    # Aggregate to monthly\n    if method == \"mean\":\n        monthly = subset.resample(\"ME\")[\"rate_annual\"].mean()\n    elif method == \"last\":\n        monthly = subset.resample(\"ME\")[\"rate_annual\"].last()\n    else:\n        monthly = subset.resample(\"ME\")[\"rate_annual\"].first()\n\n    monthly = monthly.reset_index()\n    monthly.columns = [\"date\", \"rf_annual\"]\n\n    # Convert annualized rate (%) to monthly decimal\n    monthly[\"rf_monthly\"] = monthly[\"rf_annual\"] / 100 / 12\n\n    return monthly[[\"date\", \"rf_monthly\", \"rf_annual\"]]\n\n# Construct series for each proxy\nrf_proxies = {}\nfor proxy in [\"govt_bond_1y\", \"interbank_overnight\", \"sbv_refinancing\"]:\n    rf_proxies[proxy] = construct_monthly_rf(rf_raw, proxy)\n    rf_proxies[proxy][\"proxy\"] = proxy\n\nrf_all = pd.concat(rf_proxies.values(), ignore_index=True)\n```\n:::\n\n\n### Handling Missing Data and Structural Breaks\n\nVietnamese rate data may contain gaps due to market closures, reporting changes, or the introduction of new instruments. We handle these systematically:\n\n::: {#check-missing .cell execution_count=6}\n``` {.python .cell-code}\n# Check coverage for each proxy\ncoverage = (\n    rf_all\n    .groupby(\"proxy\")\n    .agg(\n        start_date=(\"date\", \"min\"),\n        end_date=(\"date\", \"max\"),\n        n_months=(\"rf_monthly\", \"count\"),\n        n_missing=(\"rf_monthly\", lambda x: x.isna().sum()),\n        avg_rate_pct=(\"rf_annual\", \"mean\")\n    )\n    .round(2)\n)\n\nprint(coverage)\n```\n:::\n\n\nFor periods where the primary proxy is unavailable, we construct a blended series using a priority hierarchy:\n\n::: {#construct-blended-rf .cell execution_count=7}\n``` {.python .cell-code}\ndef construct_blended_rf(rf_proxies, priority=None):\n    \"\"\"\n    Construct a blended monthly risk-free rate using proxy priority.\n\n    Priority order (default):\n    1. Treasury bills (shortest maturity, sovereign)\n    2. Interbank overnight (short maturity, high frequency)\n    3. 1-year government bond (sovereign, regular)\n    4. SBV refinancing rate (fallback)\n    \"\"\"\n    if priority is None:\n        priority = [\n            \"tbill_3m\",\n            \"interbank_overnight\",\n            \"govt_bond_1y\",\n            \"sbv_refinancing\"\n        ]\n\n    # Create full date range\n    all_dates = pd.date_range(\n        start=min(df[\"date\"].min() for df in rf_proxies.values()),\n        end=max(df[\"date\"].max() for df in rf_proxies.values()),\n        freq=\"ME\"\n    )\n\n    blended = pd.DataFrame({\"date\": all_dates})\n    blended[\"rf_monthly\"] = np.nan\n    blended[\"source\"] = \"\"\n\n    for proxy in priority:\n        if proxy in rf_proxies:\n            proxy_df = rf_proxies[proxy][[\"date\", \"rf_monthly\"]].rename(\n                columns={\"rf_monthly\": f\"rf_{proxy}\"}\n            )\n            blended = blended.merge(proxy_df, on=\"date\", how=\"left\")\n\n            # Fill missing values from this proxy\n            mask = blended[\"rf_monthly\"].isna() & blended[f\"rf_{proxy}\"].notna()\n            blended.loc[mask, \"rf_monthly\"] = blended.loc[mask, f\"rf_{proxy}\"]\n            blended.loc[mask, \"source\"] = proxy\n\n            blended = blended.drop(columns=[f\"rf_{proxy}\"])\n\n    return blended\n\nrf_blended = construct_blended_rf(rf_proxies)\n```\n:::\n\n\n::: {#tbl-blended-source .cell tbl-cap='Data Source Composition of Blended Risk-Free Rate Series' execution_count=8}\n``` {.python .cell-code}\nsource_comp = (\n    rf_blended\n    .groupby(\"source\")\n    .agg(\n        n_months=(\"date\", \"count\"),\n        pct=(\"date\", lambda x: len(x) / len(rf_blended) * 100)\n    )\n    .round(1)\n    .sort_values(\"n_months\", ascending=False)\n)\n\nsource_comp\n```\n:::\n\n\n### Properties of the Constructed Series\n\n::: {#tbl-rf-summary-stats .cell tbl-cap='Summary Statistics of Monthly Risk-Free Rate Proxies' execution_count=9}\n``` {.python .cell-code}\nrf_wide = rf_all.pivot_table(\n    index=\"date\", columns=\"proxy\", values=\"rf_monthly\"\n)\n\nsummary = rf_wide.describe(percentiles=[0.10, 0.25, 0.50, 0.75, 0.90]).T\nsummary = summary[[\"mean\", \"std\", \"min\", \"10%\", \"50%\", \"90%\", \"max\"]]\nsummary.columns = [\n    \"Mean\", \"Std\", \"Min\", \"P10\", \"Median\", \"P90\", \"Max\"\n]\n\n# Convert to annualized percentage for interpretability\n(summary * 12 * 100).round(2)\n```\n:::\n\n\n::: {#fig-rf-monthly-comparison .cell execution_count=10}\n``` {.python .cell-code}\nfig, axes = plt.subplots(2, 1, figsize=(8, 6), sharex=True)\n\n# Level\nfor proxy, color in [\n    (\"govt_bond_1y\", \"#2C73D2\"),\n    (\"interbank_overnight\", \"#FF6B6B\"),\n    (\"sbv_refinancing\", \"#5DCEAF\")\n]:\n    subset = rf_proxies[proxy].sort_values(\"date\")\n    axes[0].plot(\n        subset[\"date\"], subset[\"rf_monthly\"] * 100,\n        label=proxy.replace(\"_\", \" \").title(),\n        color=color, linewidth=1\n    )\naxes[0].set_ylabel(\"Monthly Rate (%)\")\naxes[0].legend(frameon=False, fontsize=9)\naxes[0].spines[\"top\"].set_visible(False)\naxes[0].spines[\"right\"].set_visible(False)\n\n# Pairwise spread: govt bond - interbank\nmerged = rf_proxies[\"govt_bond_1y\"][[\"date\", \"rf_monthly\"]].merge(\n    rf_proxies[\"interbank_overnight\"][[\"date\", \"rf_monthly\"]],\n    on=\"date\", suffixes=(\"_bond\", \"_interbank\")\n)\nmerged[\"spread\"] = (merged[\"rf_monthly_bond\"] - merged[\"rf_monthly_interbank\"]) * 100\n\naxes[1].fill_between(\n    merged[\"date\"], merged[\"spread\"], 0,\n    where=merged[\"spread\"] > 0, alpha=0.4, color=\"#2C73D2\", label=\"Bond > Interbank\"\n)\naxes[1].fill_between(\n    merged[\"date\"], merged[\"spread\"], 0,\n    where=merged[\"spread\"] <= 0, alpha=0.4, color=\"#FF6B6B\", label=\"Bond < Interbank\"\n)\naxes[1].axhline(0, color=\"black\", linewidth=0.5)\naxes[1].set_ylabel(\"Spread (% monthly)\")\naxes[1].set_xlabel(\"\")\naxes[1].legend(frameon=False, fontsize=9)\naxes[1].spines[\"top\"].set_visible(False)\naxes[1].spines[\"right\"].set_visible(False)\n\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\nThe spread between proxies is informative. A consistently positive spread (bond yield \\> interbank rate) reflects the term premium embedded in the 1-year bond. Periods where the interbank rate spikes above the bond yield typically correspond to liquidity crunches in the banking system.\n\n### Correlation Across Proxies\n\n::: {#tbl-rf-correlation .cell tbl-cap='Pairwise Correlation of Monthly Risk-Free Rate Proxies' execution_count=11}\n``` {.python .cell-code}\nrf_corr = rf_wide.corr().round(3)\nrf_corr.index = [x.replace(\"_\", \" \").title() for x in rf_corr.index]\nrf_corr.columns = [x.replace(\"_\", \" \").title() for x in rf_corr.columns]\nrf_corr\n```\n:::\n\n\nHigh correlation (\\> 0.8) between proxies suggests that the level and direction of interest rate movements are captured similarly by all proxies. Low correlation would indicate that the choice of proxy introduces substantial idiosyncratic variation into excess returns.\n\n## Excess Return Construction\n\nWith the risk-free rate series in hand, we now construct excess returns for individual stocks and for the market portfolio.\n\n### Matching Conventions\n\nExcess return construction requires strict consistency across three dimensions (@tbl-rf-consistency).\n\n| Dimension | Requirement | Common Error |\n|----------------------|------------------------|--------------------------|\n| Currency | Same currency for $r_i$ and $r_f$ | Using USD rate for VND-denominated returns |\n| Frequency | Same holding period | Using annualized $r_f$ with monthly $r_i$ |\n| Compounding | Same convention | Mixing log and arithmetic returns |\n\n: Consistency Requirements for Excess Returns {#tbl-rf-consistency}\n\n::: {#construct-excess-returns .cell execution_count=12}\n``` {.python .cell-code}\n# Load monthly stock returns\nstock_returns = pd.read_parquet(\"data/monthly_returns.parquet\")\n# Assume columns: symbol, date (month-end), ret\n\n# Merge with risk-free rate\n# Use the blended series as the baseline\nrf_for_merge = rf_blended[[\"date\", \"rf_monthly\"]].rename(\n    columns={\"rf_monthly\": \"rf\"}\n)\n\nstock_returns = stock_returns.merge(rf_for_merge, on=\"date\", how=\"left\")\n\n# Compute excess returns\nstock_returns[\"ret_excess\"] = stock_returns[\"ret\"] - stock_returns[\"rf\"]\n```\n:::\n\n\n### Market Excess Return\n\n::: {#compute-mktrf .cell execution_count=13}\n``` {.python .cell-code}\n# Value-weighted market return\nmarket_monthly = (\n    stock_returns\n    .groupby(\"date\")\n    .apply(\n        lambda g: np.average(\n            g[\"ret\"].dropna(),\n            weights=g[\"mktcap\"].loc[g[\"ret\"].dropna().index]\n        ) if g[\"ret\"].dropna().shape[0] > 0 else np.nan,\n        include_groups=False\n    )\n    .reset_index(name=\"rm\")\n)\n\nmarket_monthly = market_monthly.merge(rf_for_merge, on=\"date\", how=\"left\")\nmarket_monthly[\"mktrf\"] = market_monthly[\"rm\"] - market_monthly[\"rf\"]\n```\n:::\n\n\n::: {#fig-mktrf-timeseries .cell execution_count=14}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(8, 3.5))\n\nax.bar(\n    market_monthly[\"date\"], market_monthly[\"mktrf\"] * 100,\n    color=np.where(market_monthly[\"mktrf\"] >= 0, \"#2C73D2\", \"#FF6B6B\"),\n    width=25, alpha=0.8\n)\nax.axhline(0, color=\"black\", linewidth=0.5)\nax.set_ylabel(\"Market Excess Return (%)\")\nax.set_xlabel(\"\")\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n## Sensitivity Analysis: How Much Does the Proxy Choice Matter?\n\nThis is the central empirical question of the chapter. If different risk-free proxies produce essentially the same downstream results, the choice is inconsequential. If they produce different results, researchers must justify their choice and report robustness.\n\n### Effect on the Equity Premium\n\n::: {#tbl-equity-premium-sensitivity .cell tbl-cap='Annualized Equity Premium Under Alternative Risk-Free Proxies' execution_count=15}\n``` {.python .cell-code}\nresults = []\nfor proxy_name, proxy_df in rf_proxies.items():\n    rf_merge = proxy_df[[\"date\", \"rf_monthly\"]].rename(\n        columns={\"rf_monthly\": \"rf_proxy\"}\n    )\n    merged = market_monthly[[\"date\", \"rm\"]].merge(rf_merge, on=\"date\", how=\"inner\")\n    merged[\"mktrf_proxy\"] = merged[\"rm\"] - merged[\"rf_proxy\"]\n\n    n_months = merged[\"mktrf_proxy\"].count()\n    mean_monthly = merged[\"mktrf_proxy\"].mean()\n    std_monthly = merged[\"mktrf_proxy\"].std()\n    sharpe = mean_monthly / std_monthly if std_monthly > 0 else np.nan\n    t_stat = mean_monthly / (std_monthly / np.sqrt(n_months))\n\n    results.append({\n        \"Proxy\": proxy_name.replace(\"_\", \" \").title(),\n        \"N Months\": n_months,\n        \"Mean (% ann.)\": round(mean_monthly * 12 * 100, 2),\n        \"Std (% ann.)\": round(std_monthly * np.sqrt(12) * 100, 2),\n        \"Sharpe (ann.)\": round(sharpe * np.sqrt(12), 3),\n        \"t-stat\": round(t_stat, 2)\n    })\n\npd.DataFrame(results).style.hide(axis=\"index\")\n```\n:::\n\n\n### Effect on Factor Premiums\n\n::: {#tbl-factor-premium-sensitivity .cell tbl-cap='Factor Premium Sensitivity to Risk-Free Proxy (Annualized %)' execution_count=16}\n``` {.python .cell-code}\n# Load or construct factor returns\n# Assume factors_monthly has: date, smb, hml (these are long-short, rf-independent)\n# Only MKTRF changes with the proxy\n\nfactors_monthly = pd.read_parquet(\"data/factors_monthly.parquet\")\n\nfor proxy_name, proxy_df in rf_proxies.items():\n    rf_merge = proxy_df[[\"date\", \"rf_monthly\"]].rename(\n        columns={\"rf_monthly\": \"rf_proxy\"}\n    )\n    factors_merged = factors_monthly.merge(rf_merge, on=\"date\", how=\"inner\")\n    factors_merged = factors_merged.merge(\n        market_monthly[[\"date\", \"rm\"]], on=\"date\", how=\"inner\"\n    )\n    factors_merged[f\"mktrf_{proxy_name}\"] = (\n        factors_merged[\"rm\"] - factors_merged[\"rf_proxy\"]\n    )\n\n    mean_mktrf = factors_merged[f\"mktrf_{proxy_name}\"].mean() * 12 * 100\n    mean_smb = factors_merged[\"smb\"].mean() * 12 * 100\n    mean_hml = factors_merged[\"hml\"].mean() * 12 * 100\n\n    print(\n        f\"{proxy_name:>25s}: MKTRF = {mean_mktrf:6.2f}%, \"\n        f\"SMB = {mean_smb:6.2f}%, HML = {mean_hml:6.2f}%\"\n    )\n```\n:::\n\n\nNote that SMB and HML are constructed as long-short portfolio returns and should be identical regardless of the risk-free proxy. Only MKTRF differs. However, if the researcher uses the risk-free rate to compute individual stock excess returns before sorting into factor portfolios, small differences in sorting may arise.\n\n### Effect on Alpha Estimates\n\nThe choice of risk-free proxy affects alpha estimates for any portfolio evaluated against a factor model. We illustrate this by estimating the alpha of a momentum portfolio under each proxy.\n\n::: {#tbl-alpha-sensitivity .cell tbl-cap='Momentum Portfolio Alpha Sensitivity to Risk-Free Proxy' execution_count=17}\n``` {.python .cell-code}\nimport statsmodels.api as sm\n\n# Assume momentum_ret contains: date, mom_ret (raw return of WML portfolio)\nmomentum_ret = pd.read_parquet(\"data/momentum_returns.parquet\")\n\nalpha_results = []\nfor proxy_name, proxy_df in rf_proxies.items():\n    rf_merge = proxy_df[[\"date\", \"rf_monthly\"]].rename(\n        columns={\"rf_monthly\": \"rf_proxy\"}\n    )\n\n    merged = (\n        momentum_ret\n        .merge(rf_merge, on=\"date\", how=\"inner\")\n        .merge(market_monthly[[\"date\", \"rm\"]], on=\"date\", how=\"inner\")\n        .merge(factors_monthly[[\"date\", \"smb\", \"hml\"]], on=\"date\", how=\"inner\")\n    )\n\n    merged[\"mom_excess\"] = merged[\"mom_ret\"] - merged[\"rf_proxy\"]\n    merged[\"mktrf\"] = merged[\"rm\"] - merged[\"rf_proxy\"]\n\n    X = sm.add_constant(merged[[\"mktrf\", \"smb\", \"hml\"]])\n    y = merged[\"mom_excess\"]\n    model = sm.OLS(y, X).fit(cov_type=\"HAC\", cov_kwds={\"maxlags\": 6})\n\n    alpha_results.append({\n        \"Proxy\": proxy_name.replace(\"_\", \" \").title(),\n        \"Alpha (% monthly)\": round(model.params[\"const\"] * 100, 3),\n        \"t-stat\": round(model.tvalues[\"const\"], 2),\n        \"R²\": round(model.rsquared, 3)\n    })\n\npd.DataFrame(alpha_results).style.hide(axis=\"index\")\n```\n:::\n\n\n### Effect on Valuation\n\nTo illustrate the valuation impact, consider a simple DCF exercise where the cost of equity is estimated via the CAPM.\n\n::: {#tbl-valuation-sensitivity .cell tbl-cap='Cost of Equity and Terminal Value Sensitivity to Risk-Free Proxy' execution_count=18}\n``` {.python .cell-code}\n# Example: firm with beta = 1.0, expected CF = 1 billion VND, growth = 3%\nbeta_example = 1.0\ncf = 1e9  # VND\ngrowth = 0.03\n\nvaluation_results = []\nfor proxy_name, proxy_df in rf_proxies.items():\n    rf_ann = proxy_df[\"rf_annual\"].dropna().iloc[-12:].mean() / 100  # Latest year avg\n\n    rf_merge = proxy_df[[\"date\", \"rf_monthly\"]].rename(\n        columns={\"rf_monthly\": \"rf_proxy\"}\n    )\n    mkt_merged = market_monthly[[\"date\", \"rm\"]].merge(\n        rf_merge, on=\"date\", how=\"inner\"\n    )\n    mkt_merged[\"mktrf\"] = mkt_merged[\"rm\"] - mkt_merged[\"rf_proxy\"]\n    erp = mkt_merged[\"mktrf\"].mean() * 12  # Annualized equity premium\n\n    cost_equity = rf_ann + beta_example * erp\n    terminal_value = cf / (cost_equity - growth) if cost_equity > growth else np.nan\n\n    valuation_results.append({\n        \"Proxy\": proxy_name.replace(\"_\", \" \").title(),\n        \"Rf (% ann.)\": round(rf_ann * 100, 2),\n        \"ERP (% ann.)\": round(erp * 100, 2),\n        \"Cost of Equity (%)\": round(cost_equity * 100, 2),\n        \"Terminal Value (B VND)\": round(terminal_value / 1e9, 1) if terminal_value else \"N/A\"\n    })\n\npd.DataFrame(valuation_results).style.hide(axis=\"index\")\n```\n:::\n\n\n::: callout-important\n## Key Finding\n\nEven modest differences in the risk-free rate (50-150 basis points across proxies) can produce terminal value differences of 10-30%. Researchers and practitioners must document their risk-free rate choice explicitly and report sensitivity to alternatives.\n:::\n\n## Term Structure Considerations\n\nWhen longer-horizon discount rates are needed (e.g., for multi-year DCF or cost of capital estimation), the risk-free rate should be maturity-matched. This requires constructing a yield curve from available government bond data.\n\n### Yield Curve Estimation\n\n@gurkaynak2007us develop a parametric approach to yield curve estimation using the @nelson1987parsimonious and @svensson1994estimating models. The Nelson-Siegel model parameterizes the instantaneous forward rate as:\n\n$$\nf(\\tau) = \\beta_0 + \\beta_1 \\exp\\left(-\\frac{\\tau}{\\lambda}\\right) + \\beta_2 \\frac{\\tau}{\\lambda} \\exp\\left(-\\frac{\\tau}{\\lambda}\\right)\n$$ {#eq-nelson-siegel}\n\nwhere $\\tau$ is the maturity, $\\beta_0$ is the long-run level, $\\beta_1$ determines the slope, $\\beta_2$ determines the curvature, and $\\lambda$ controls the location of the hump.\n\nThe corresponding yield is:\n\n$$\ny(\\tau) = \\beta_0 + \\beta_1 \\frac{1 - \\exp(-\\tau/\\lambda)}{\\tau/\\lambda} + \\beta_2 \\left[\\frac{1 - \\exp(-\\tau/\\lambda)}{\\tau/\\lambda} - \\exp(-\\tau/\\lambda)\\right]\n$$ {#eq-ns-yield}\n\n::: {#nelson-siegel-estimation .cell execution_count=19}\n``` {.python .cell-code}\nfrom scipy.optimize import minimize\n\ndef nelson_siegel_yield(tau, beta0, beta1, beta2, lam):\n    \"\"\"Nelson-Siegel yield curve model.\"\"\"\n    tau_lam = tau / lam\n    factor1 = (1 - np.exp(-tau_lam)) / tau_lam\n    factor2 = factor1 - np.exp(-tau_lam)\n    return beta0 + beta1 * factor1 + beta2 * factor2\n\ndef fit_nelson_siegel(maturities, yields):\n    \"\"\"Fit Nelson-Siegel model to observed yields.\"\"\"\n    def objective(params):\n        beta0, beta1, beta2, lam = params\n        if lam <= 0:\n            return 1e10\n        fitted = nelson_siegel_yield(maturities, beta0, beta1, beta2, lam)\n        return np.sum((yields - fitted) ** 2)\n\n    result = minimize(\n        objective,\n        x0=[yields[-1], yields[0] - yields[-1], 0, 2.0],\n        method=\"Nelder-Mead\",\n        options={\"maxiter\": 10000}\n    )\n    return result.x\n\n# Example: fit to latest available government bond yields\n# Assume govt_yields contains: date, maturity_years, yield_pct\ngovt_yields = pd.read_parquet(\"data/govt_bond_yields.parquet\")\n\nlatest_date = govt_yields[\"date\"].max()\nlatest_yields = govt_yields[govt_yields[\"date\"] == latest_date].sort_values(\"maturity_years\")\n\nmaturities = latest_yields[\"maturity_years\"].values\nyields = latest_yields[\"yield_pct\"].values\n\nparams = fit_nelson_siegel(maturities, yields)\nbeta0, beta1, beta2, lam = params\n```\n:::\n\n\n::: {#fig-yield-curve .cell execution_count=20}\n``` {.python .cell-code}\ntau_fine = np.linspace(0.25, 30, 200)\nfitted_yields = nelson_siegel_yield(tau_fine, *params)\n\nfig, ax = plt.subplots(figsize=(7, 4))\nax.scatter(\n    maturities, yields, color=\"#FF6B6B\", s=60, zorder=5,\n    label=\"Observed yields\", edgecolors=\"white\"\n)\nax.plot(\n    tau_fine, fitted_yields, color=\"#2C73D2\", linewidth=2,\n    label=\"Nelson-Siegel fit\"\n)\nax.set_xlabel(\"Maturity (Years)\")\nax.set_ylabel(\"Yield (%)\")\nax.legend(frameon=False)\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nplt.tight_layout()\nplt.show()\n\nprint(f\"Nelson-Siegel parameters:\")\nprint(f\"  β₀ (level)     = {beta0:.4f}\")\nprint(f\"  β₁ (slope)     = {beta1:.4f}\")\nprint(f\"  β₂ (curvature) = {beta2:.4f}\")\nprint(f\"  λ (decay)      = {lam:.4f}\")\n```\n:::\n\n\n::: callout-tip\nThe Nelson-Siegel yield curve allows extraction of a risk-free rate at any maturity. For monthly asset pricing, evaluate the curve at $\\tau = 1/12$ (one month). For DCF valuation with a 10-year horizon, evaluate at $\\tau = 10$. This maturity-matching approach is superior to using a single proxy for all purposes.\n:::\n\n### Extracting the Short-Rate from the Yield Curve\n\n::: {#extract-short-rate .cell execution_count=21}\n``` {.python .cell-code}\n# Extract 1-month rate from Nelson-Siegel curve at each date\ndef extract_ns_short_rate(govt_yields, target_maturity=1/12):\n    \"\"\"\n    For each date, fit Nelson-Siegel and extract the yield\n    at the target maturity.\n    \"\"\"\n    dates = govt_yields[\"date\"].unique()\n    short_rates = []\n\n    for d in dates:\n        obs = govt_yields[govt_yields[\"date\"] == d].sort_values(\"maturity_years\")\n        if len(obs) < 3:  # Need at least 3 points to fit\n            short_rates.append({\"date\": d, \"rf_ns\": np.nan})\n            continue\n\n        try:\n            params = fit_nelson_siegel(\n                obs[\"maturity_years\"].values,\n                obs[\"yield_pct\"].values\n            )\n            rf_ns = nelson_siegel_yield(target_maturity, *params)\n            short_rates.append({\"date\": d, \"rf_ns\": rf_ns})\n        except Exception:\n            short_rates.append({\"date\": d, \"rf_ns\": np.nan})\n\n    return pd.DataFrame(short_rates)\n\nns_short_rates = extract_ns_short_rate(govt_yields)\n```\n:::\n\n\n## Real vs. Nominal Risk-Free Rates\n\nFor certain applications, particularly long-horizon valuation and real return analysis, the real (inflation-adjusted) risk-free rate is more appropriate than the nominal rate. The Fisher equation relates them:\n\n$$\nr_f^{real} \\approx r_f^{nominal} - \\pi^{e}\n$$ {#eq-fisher}\n\nwhere $\\pi^e$ is expected inflation. In practice, we can use realized CPI inflation as a proxy for expected inflation (under the assumption of rational expectations, or as an ex-post adjustment).\n\n::: {#compute-real-rf .cell execution_count=22}\n``` {.python .cell-code}\n# Load CPI data\n# Assume cpi_data contains: date, cpi_index (or inflation_mom for month-over-month)\ncpi_data = pd.read_parquet(\"data/cpi_monthly.parquet\")\ncpi_data = cpi_data.sort_values(\"date\")\ncpi_data[\"inflation_monthly\"] = cpi_data[\"cpi_index\"].pct_change()\n\nrf_real = rf_blended[[\"date\", \"rf_monthly\"]].merge(\n    cpi_data[[\"date\", \"inflation_monthly\"]], on=\"date\", how=\"inner\"\n)\nrf_real[\"rf_real\"] = rf_real[\"rf_monthly\"] - rf_real[\"inflation_monthly\"]\n```\n:::\n\n\n::: {#fig-real-vs-nominal .cell execution_count=23}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(8, 4))\nax.plot(\n    rf_real[\"date\"], rf_real[\"rf_monthly\"] * 100,\n    color=\"#2C73D2\", label=\"Nominal\", linewidth=1\n)\nax.plot(\n    rf_real[\"date\"], rf_real[\"rf_real\"] * 100,\n    color=\"#FF6B6B\", label=\"Real\", linewidth=1\n)\nax.axhline(0, color=\"black\", linewidth=0.5, linestyle=\"--\")\nax.set_ylabel(\"Monthly Rate (%)\")\nax.set_xlabel(\"\")\nax.legend(frameon=False)\nax.spines[\"top\"].set_visible(False)\nax.spines[\"right\"].set_visible(False)\nplt.tight_layout()\nplt.show()\n```\n:::\n\n\n::: callout-note\nIn periods of high inflation, the real risk-free rate can be substantially negative. This has implications for real excess return computation and for interpreting the equity premium in real terms. A negative real risk-free rate implies that nominal government securities do not preserve purchasing power, which strengthens the case for equity investment from a real-return perspective.\n:::\n\n## International Comparison\n\nIt is instructive to compare Vietnam's risk-free rate environment with that of other emerging and developed markets to contextualize the magnitudes involved.\n\n\nVietnam's risk-free rate environment is characterized by relatively high nominal rates (reflecting inflation and growth dynamics), limited availability of very-short-maturity sovereign instruments, and greater reliance on interbank rates as the operational proxy. This is broadly similar to other ASEAN frontier markets but contrasts sharply with developed Asian markets, where deep government securities markets provide clean short-term benchmarks.\n\n## Best Practices Checklist\n\nBased on the analysis in this chapter, we summarize the recommended practices for risk-free rate construction in Vietnamese financial research:\n\n\n## Saving the Risk-Free Rate for Downstream Use\n\nThe final step is to save the constructed risk-free rate series for use in subsequent chapters.\n\n::: {#save-rf-series .cell execution_count=26}\n``` {.python .cell-code}\n# Save all variants for flexibility\nrf_output = rf_blended[[\"date\", \"rf_monthly\", \"source\"]].copy()\nrf_output[\"rf_annual_pct\"] = rf_output[\"rf_monthly\"] * 12 * 100\n\n# Also save individual proxies\nfor proxy_name, proxy_df in rf_proxies.items():\n    col_name = f\"rf_{proxy_name}\"\n    rf_output = rf_output.merge(\n        proxy_df[[\"date\", \"rf_monthly\"]].rename(\n            columns={\"rf_monthly\": col_name}\n        ),\n        on=\"date\",\n        how=\"left\"\n    )\n\n# Save to parquet for use in later chapters\nrf_output.to_parquet(\"data/risk_free_rate.parquet\", index=False)\n\nprint(f\"Risk-free rate series saved: {len(rf_output)} months\")\nprint(f\"Date range: {rf_output['date'].min()} to {rf_output['date'].max()}\")\nprint(f\"\\nColumns: {list(rf_output.columns)}\")\n```\n:::\n\n\n::: callout-tip\nBy saving the risk-free rate as a separate, well-documented file, all downstream chapters can merge it consistently. This avoids the common pitfall of reconstructing the risk-free rate differently in different analyses within the same study.\n:::\n\n## Summary\n\nThis chapter has established that risk-free rate construction is a first-order modeling decision in Vietnamese financial research, not a technical afterthought. The key takeaways are:\n\n1.  **No perfect proxy exists** in Vietnam. The interbank overnight rate, 1-year government bond yield, and SBV policy rate each have distinct strengths and limitations. A blended series using a documented priority hierarchy provides the most robust baseline.\n\n2.  **The choice of proxy matters quantitatively**. Different proxies can shift the estimated equity premium by 50-200 basis points annually, alter portfolio alphas, and change DCF terminal values by 10-30%.\n\n3.  **Frequency alignment and compounding conventions** must be handled with care. Converting annualized rates to monthly requires specifying the compounding convention. Gaps in the data require documented interpolation.\n\n4.  **The Nelson-Siegel yield curve model** enables the extraction of any-maturity risk-free rate from sparse government bond data, which is particularly valuable for maturity-matched discount rate estimation.\n\n5.  **Sensitivity analysis is mandatory**. Any study that reports results under a single risk-free proxy without reporting robustness to alternatives has an unquantified source of specification uncertainty.\n\n<!-- ## Exercises\n\n1.  **Proxy substitution test**: Re-estimate the Fama-French three-factor model for the Vietnamese market using each of the three risk-free proxies. Report the market premium, SMB, and HML under each specification. Are the cross-sectional patterns in factor loadings sensitive to the proxy choice?\n\n2.  **Breakpoint analysis**: Identify structural breaks in the interbank overnight rate series using the @bai2003critical sequential break detection procedure. Do these breaks correspond to known monetary policy regime changes (e.g., SBV rate adjustments, regulatory changes)?\n\n3.  **Inflation-adjusted equity premium**: Compute the real equity premium by subtracting realized CPI inflation from both the market return and the nominal risk-free rate. Compare the Sharpe ratio of the market portfolio in nominal vs. real terms.\n\n4.  **Yield curve dynamics**: Estimate the Nelson-Siegel model at monthly frequency and track the time series of $\\beta_0$ (level), $\\beta_1$ (slope), and $\\beta_2$ (curvature). Do these factors predict future stock market returns or macroeconomic variables, following @Ang2006 @ang2006does?\n\n5.  **Currency-adjusted risk-free rate**: For foreign investors, the relevant risk-free rate includes currency hedging costs. Construct a USD-hedged risk-free rate using the VND/USD forward premium (covered interest parity) and compare it to the local-currency risk-free rate. How does this affect the equity premium from a foreign investor's perspective?\n\n6.  **Deposit rate ceiling effects**: During periods when the SBV imposes binding deposit rate ceilings, the observed deposit rate may be below the market-clearing rate. Identify such periods and test whether the deposit-rate-based risk-free proxy produces systematically different excess returns compared to the interbank rate during ceiling-binding vs. non-binding periods. -->\n\n",
    "supporting": [
      "04_risk_free_rate_construction_files/figure-pdf"
    ],
    "filters": []
  }
}