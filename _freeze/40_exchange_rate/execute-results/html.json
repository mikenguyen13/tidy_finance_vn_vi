{
  "hash": "5cf43dcfe4d4835cbfd28281be2fcf7a",
  "result": {
    "engine": "jupyter",
    "markdown": "# Exchange Rate Dynamics\n\n\nIn quantitative finance, the precision of currency data is the bedrock of international asset pricing and risk management. This chapter demonstrates the capabilities of the **DataCore** platform, specifically the `datacore.exchange_rates` table, which serves as a centralized repository for global spot rates.\n\nWe will execute a complete data pipeline: extracting raw spot rates for the **Chinese Yuan (CNY)** to **US Dollar (USD)** pair, transforming them into log returns, and performing a volatility analysis.\n\n## Pipeline Architecture\n\nThe following diagram illustrates the data flow from the DataCore server to the final analytical output.\n\n```{mermaid}\n%%| fig-align: center\n%%| fig-cap: \"DataCore ETL Process Flow\"\ngraph LR\n    subgraph Server[\"DataCore Infrastructure\"]\n        A[(\"datacore.exchange_rates\")]\n    end\n    \n    subgraph Client[\"Local Environment\"]\n        B[(\"SQL Connection\")]\n        C{Data Processing}\n        D[(\"Statistical Output\")]\n        E[(\"Visualization\")]\n    end\n\n    A -->|SQL Query| B\n    B -->|Pandas DataFrame| C\n    C -->|Log Transformation| D\n    C -->|Rolling Window| D\n    D -->|Matplotlib/Seaborn| E\n    \n    style A fill:#2c3e50,stroke:#fff,color:#fff\n    style C fill:#e74c3c,stroke:#fff,color:#fff\n    style E fill:#18bc9c,stroke:#fff,color:#fff\n\n```\n\n---\n\n# Data Extraction\n\nThe DataCore schema is designed for high-throughput querying. We utilize a targeted SQL query to minimize latency, filtering for the specific currency pair at the server level.\n\n\n\n## Query Optimization\n\nFiltering within the SQL statement (using `WHERE`) is approximately 10x faster than fetching the full table and filtering in memory with Python.\n\n::: {#db-connection .cell execution_count=2}\n``` {.python .cell-code}\n# Establish connection to the institutional database\nconn = db_connector.Connection()\n```\n:::\n\n\n::: {#data-query .cell execution_count=3}\n``` {.python .cell-code}\n# Define the extraction logic\nquery = \"\"\"\nSELECT \n    date,\n    from_currency,\n    to_currency,\n    rate as fx_rate\nFROM \n    datacore.exchange_rates\nWHERE \n    from_currency = 'CNY' \n    AND to_currency = 'USD'\nORDER BY \n    date ASC\n\"\"\"\n\n# Execute query and parse dates\ndf_fx = conn.raw_sql(query, date_cols=['date'])\n\n# Set temporal index\ndf_fx.set_index('date', inplace=True)\n\n# Display interactive table (paged)\ndf_fx.head(10)\n```\n:::\n\n\n---\n\n# Quantitative Transformation\n\nTo prepare the data for risk modeling, we convert raw spot rates into **Logarithmic Returns**. Log returns are preferred in financial time series analysis due to their time-additivity and statistical stationarity.\n\n## Mathematical Formulation\n\nThe log return $r_t$ at time $t$ is defined as:\n\n$$\nr_t = \\ln (P_t) - \\ln(P_{t-1} = \\ln (\\frac{P_t}{P_{t-1}}))\n$$\n\nWhere $P_t$ represents the spot exchange rate.\n\n\nWe also compute a **30-Day Rolling Volatility** measure to identify periods of market stress.\n\n::: {#feature-engineering .cell execution_count=4}\n``` {.python .cell-code}\n# 1. Calculate Log Returns\ndf_fx['log_return'] = np.log(df_fx['fx_rate'] / df_fx['fx_rate'].shift(1))\n\n# 2. Calculate 30-Day Rolling Standard Deviation (Volatility)\n# We scale by sqrt(252) to annualize the daily volatility\ndf_fx['volatility_30d'] = df_fx['log_return'].rolling(window=30).std() * np.sqrt(252)\n\n# 3. Clean Missing Data (First row will be NaN)\ndf_fx.dropna(inplace=True)\n\n# Preview transformed data\ndf_fx[['fx_rate', 'log_return', 'volatility_30d']].tail()\n```\n:::\n\n\n---\n\n# Visual Analytics\n\nWe utilize a tabbed interface to present multiple dimensions of the data without cluttering the report.\n\n\n## Trend Analysis\n\nThe historical evolution of the spot rate reveals long-term macroeconomic trends.\n\n::: {#fig-trend .cell execution_count=5}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(12, 6))\n\nsns.lineplot(\n    data=df_fx, \n    x=df_fx.index, \n    y='fx_rate', \n    linewidth=2.5, \n    color=\"#2c3e50\", \n    ax=ax\n)\n\nax.set_title('CNY/USD Spot Rate', fontsize=18, fontweight='bold', pad=20)\nax.set_ylabel('Rate (USD)', fontsize=14)\nax.set_xlabel('')\nax.fill_between(df_fx.index, df_fx['fx_rate'], alpha=0.1, color=\"#2c3e50\")\n\nplt.show()\n```\n:::\n\n\n## Volatility Regime\n\nThis chart highlights periods of high market uncertainty (high volatility) versus periods of stability.\n\n::: {#fig-volatility .cell execution_count=6}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(12, 6))\n\nsns.lineplot(\n    data=df_fx, \n    x=df_fx.index, \n    y='volatility_30d', \n    linewidth=1.5, \n    color=\"#e74c3c\", \n    ax=ax\n)\n\nax.set_title('Market Volatility Regimes (30-Day Rolling)', fontsize=18, fontweight='bold', pad=20)\nax.set_ylabel('Annualized Volatility', fontsize=14)\nax.set_xlabel('')\n\n# Highlight crisis threshold\nax.axhline(y=0.05, color='black', linestyle='--', label='High Volatility Threshold')\nax.legend()\n\nplt.show()\n```\n:::\n\n\n## Distribution\n\nThe histogram of returns allows us to check for \"fat tails\" (kurtosis), which indicate a higher probability of extreme events than a normal distribution predicts.\n\n::: {#fig-distribution .cell execution_count=7}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(12, 6))\n\nsns.histplot(\n    data=df_fx, \n    x='log_return', \n    kde=True, \n    bins=50, \n    color=\"#18bc9c\", \n    edgecolor='white',\n    alpha=0.8\n)\n\nax.set_title('Return Distribution', fontsize=18, fontweight='bold', pad=20)\nax.set_xlabel('Daily Log Return', fontsize=14)\nax.set_ylabel('Frequency', fontsize=14)\n\nplt.show()\n```\n:::\n\n\n# Conclusion\n\nThis analysis confirms the utility of **DataCore** for financial modeling. By accessing high-fidelity data via `datacore.exchange_rates`, we successfully identified distinct volatility regimes in the CNY/USD currency pair.\n\n",
    "supporting": [
      "40_exchange_rate_files"
    ],
    "filters": [],
    "includes": {}
  }
}