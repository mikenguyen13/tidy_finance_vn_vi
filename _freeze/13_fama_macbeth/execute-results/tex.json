{
  "hash": "eb7fdea2bb80c4cb17f0669d71f52ccd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Fama-MacBeth Regressions\"\nformat:\n  html:\n    code-fold: false\n    number-sections: true\njupyter: python3\n---\n\nIn this chapter, we delve into the implementation of the @Fama1973 regression approach, a cornerstone of empirical asset pricing. While portfolio sorts provide a robust, non-parametric view of the relationship between characteristics and returns, they struggle when we need to control for multiple factors simultaneously. For instance, in the Vietnamese stock market (HOSE and HNX), small-cap stocks often exhibit high illiquidity. Does the \"Size effect\" exist because small stocks are risky, or simply because they are illiquid? Fama-MacBeth (FM) regressions allow us to disentangle these effects in a linear framework.\n\nWe will implement a version of the FM procedure, accounting for:\n1.  **Weighted Least Squares (WLS):** To prevent micro-cap stocks, which are prevalent and volatile in Vietnam, from dominating the estimates.\n2.  **Newey-West Adjustments:** To handle the serial correlation often observed in Vietnamese market risk premiums.\n3.  **Shanken Correction:** To mathematically adjust for the \"Errors-in-Variables\" bias arising from estimated betas.\n\n## The Econometric Framework\n\nThe Fama-MacBeth procedure is essentially a two-step filter that separates the cross-sectional variation in returns from the time-series variation.\n\n### Intuition: Why not Panel OLS?\n\nA naive approach would be to pool all data ($N$ stocks $\\times$ $T$ months) and run a single Ordinary Least Squares (OLS) regression:\n\n$$ \nr_{i,t+1} = \\alpha + \\beta_{i,t} \\lambda + \\epsilon_{i,t+1} \n$$\n\nHowever, this assumes that the error terms $\\epsilon_{i,t+1}$ are independent across firms. In reality, stock returns are highly cross-sectionally correlated (if the VN-Index crashes, most stocks fall together). A pooled OLS would underestimate the standard errors, leading to \"false positive\" discoveries of risk factors. Fama-MacBeth solves this by running $T$ separate cross-sectional regressions, effectively treating each month as a single independent observation of the risk premium.\n\n### Mathematical Derivation\n\n#### Step 1: Cross-Sectional Regressions\n\nFor each month $t$, we estimate the premium $\\lambda_{k,t}$ for $K$ factors. Let $r_{i,t+1}$ be the excess return of asset $i$ at time $t+1$. Let $\\boldsymbol{\\beta}_{i,t}$ be a vector of $K$ characteristics (e.g., Market Beta, Book-to-Market, Size) known at time $t$.\n\nThe model for a specific month $t$ is:\n$$ \n\\mathbf{r}_{t+1} = \\mathbf{X}_t \\boldsymbol{\\lambda}_{t+1} + \\boldsymbol{\\alpha}_{t+1} + \\boldsymbol{\\epsilon}_{t+1} \n$$\n\nWhere:\n* $\\mathbf{r}_{t+1}$ is an $N \\times 1$ vector of returns.\n* $\\mathbf{X}_t$ is an $N \\times (K+1)$ matrix of factor exposures (including a column of ones for the intercept).\n* $\\boldsymbol{\\lambda}_{t+1}$ is the vector of risk premiums realized in month $t+1$.\n\nTo use **Weighted Least Squares (WLS)**, We define a weighting matrix $\\mathbf{W}_t$ (typically diagonal with market capitalizations). The estimator for month $t$ is:\n$$ \n\\hat{\\boldsymbol{\\lambda}}_{t+1} = (\\mathbf{X}_t^\\top \\mathbf{W}_t \\mathbf{X}_t)^{-1} \\mathbf{X}_t^\\top \\mathbf{W}_t \\mathbf{r}_{t+1} \n$$\n\n\n#### Step 2: Time-Series Aggregation\n\nWe now have a time-series of $T$ estimates: $\\hat{\\lambda}_1, \\hat{\\lambda}_2, \\dots, \\hat{\\lambda}_T$. The final estimate of the risk premium is the time-series average:\n$$ \n\\hat{\\lambda}_k = \\frac{1}{T} \\sum_{t=1}^T \\hat{\\lambda}_{k,t} \n$$\n\nThe standard error is derived from the standard deviation of these monthly estimates:\n$$ \n\\sigma(\\hat{\\lambda}_k) = \\sqrt{\\frac{1}{T^2} \\sum_{t=1}^T (\\hat{\\lambda}_{k,t} - \\hat{\\lambda}_k)^2} \n$$\n\n\n## The \"Errors-in-Variables\" (EIV) Problem\nA critical subtlety often ignored in basic applications is that the betas used in Step 1 are not true values, they are estimates from a prior rolling window (Step 0). This measurement error biases the second-pass $\\lambda$ estimates (typically downwards) and understates the standard errors.\n\n@Shanken1992 provides a correction factor $c$. If we use standard portfolio betas, the variance of the estimator must be inflated:\n$$ \n\\sigma^2_{Shanken}(\\hat{\\lambda}) = \\sigma^2_{FM}(\\hat{\\lambda}) \\times (1 + \\hat{\\lambda}^\\top \\Sigma_f^{-1} \\hat{\\lambda}) \n$$\n\nWhere $\\Sigma_f$ is the covariance matrix of the factors. This correction is particularly relevant for the Vietnamese market where factor volatilities are high, making the term $(1 + \\dots)$ significantly larger than 1.\n\n## Data Preparation\n\nWe utilize data from our local SQLite database. In Vietnam, the fiscal year typically ends in December, and audited reports are required by April. To ensure no look-ahead bias, we lag accounting data (Book Equity) to match returns starting in July (a 6-month conservative lag, similar to Fama-French, but adapted for Vietnamese reporting delays).\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport sqlite3\nimport statsmodels.formula.api as smf\nimport statsmodels.api as sm\nfrom pandas.tseries.offsets import MonthEnd\n\n# Connect to the Vietnamese data\ntidy_finance = sqlite3.connect(database=\"data/tidy_finance_python.sqlite\")\n\n# Load Monthly Prices (HOSE & HNX)\nprices_monthly = pd.read_sql_query(\n  sql=\"SELECT symbol, date, ret_excess, mktcap, mktcap_lag FROM prices_monthly\",\n  con=tidy_finance,\n  parse_dates={\"date\"}\n)\n\n# Load Book Equity (derived from Vietnamese Financial Statements)\ncomp_vn = pd.read_sql_query(\n  sql=\"SELECT datadate, symbol, be FROM comp_vn\",\n  con=tidy_finance,\n  parse_dates={\"datadate\"}\n)\n\n# Load Rolling Market Betas (Pre-calculated in Chapter 'Beta Estimation')\nbeta_monthly = pd.read_sql_query(\n  sql=\"SELECT symbol, date, beta FROM beta_monthly WHERE return_type = 'monthly'\",\n  con=tidy_finance,\n  parse_dates={\"date\"}\n)\n```\n:::\n\n\nWe construct our testing characteristics:\n\n1. **(Market Beta):** The sensitivity to the VN-Index.\n2. **Size (ln(ME)):** The natural log of market capitalization.\n3. **Value (BM):** The ratio of Book Equity to Market Equity.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n# Prepare Characteristics\ncharacteristics = (\n    comp_vn\n    # Align reporting date to month end\n    .assign(date=lambda x: pd.to_datetime(x[\"datadate\"]) + MonthEnd(0))\n    # Merge with price data to get Market Cap at fiscal year end\n    .merge(prices_monthly, on=[\"symbol\", \"date\"], how=\"left\")\n    .merge(beta_monthly, on=[\"symbol\", \"date\"], how=\"left\")\n    .assign(\n        # Compute Book-to-Market\n        bm=lambda x: x[\"be\"] / x[\"mktcap\"],\n        log_mktcap=lambda x: np.log(x[\"mktcap\"]),\n        # Create sorting date: Financials valid from July of year t+1\n        sorting_date=lambda x: x[\"date\"] + pd.DateOffset(months=6) + MonthEnd(0),\n    )\n    .get([\"symbol\", \"bm\", \"beta\", \"sorting_date\"]) \n    .dropna()\n)\n\ncharacteristics.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>symbol</th>\n      <th>bm</th>\n      <th>beta</th>\n      <th>sorting_date</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>8729</th>\n      <td>VTV</td>\n      <td>7.034945e+08</td>\n      <td>0.689815</td>\n      <td>2017-06-30</td>\n    </tr>\n    <tr>\n      <th>8732</th>\n      <td>MTG</td>\n      <td>2.670306e+09</td>\n      <td>0.885717</td>\n      <td>2017-06-30</td>\n    </tr>\n    <tr>\n      <th>8739</th>\n      <td>MKV</td>\n      <td>6.505031e+08</td>\n      <td>0.015128</td>\n      <td>2017-06-30</td>\n    </tr>\n    <tr>\n      <th>8742</th>\n      <td>MCP</td>\n      <td>6.657350e+08</td>\n      <td>0.047316</td>\n      <td>2017-06-30</td>\n    </tr>\n    <tr>\n      <th>8747</th>\n      <td>MTH</td>\n      <td>9.690267e+08</td>\n      <td>0.099839</td>\n      <td>2017-06-30</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Merge back to monthly return panel\ndata_fm = (prices_monthly\n  .merge(characteristics, \n         left_on=[\"symbol\", \"date\"], \n         right_on=[\"symbol\", \"sorting_date\"], \n         how=\"left\")\n#   .merge(beta_monthly, on=[\"symbol\", \"date\"], how=\"left\")\n  .sort_values([\"symbol\", \"date\"])\n)\n\n# Forward fill characteristics for 12 months (valid until next report)\ndata_fm[[\"bm\"]] = data_fm.groupby(\"symbol\")[[\"bm\"]].ffill(limit=12)\n\n# Log Market Cap is updated monthly\ndata_fm[\"log_mktcap\"] = np.log(data_fm[\"mktcap\"])\n\n# Lead returns: We use characteristics at t to predict return at t+1\ndata_fm[\"ret_excess_lead\"] = data_fm.groupby(\"symbol\")[\"ret_excess\"].shift(-1)\n\n# Cleaning: Remove rows with missing future returns or characteristics\ndata_fm = data_fm.dropna(subset=[\"ret_excess_lead\", \"beta\", \"log_mktcap\", \"bm\"])\n\nprint(data_fm.head())\n\nprint(f\"Data ready: {len(data_fm):,} observations from {data_fm.date.min().date()} to {data_fm.date.max().date()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    symbol       date  ret_excess       mktcap   mktcap_lag            bm  \\\n163    AAA 2017-06-30    0.129454  2078.455619  1834.816104  7.929854e+08   \n175    AAA 2018-06-30   -0.067690  2758.426126  2948.159140  8.161755e+08   \n187    AAA 2019-06-30    0.030469  3141.519560  3038.799575  1.389438e+09   \n199    AAA 2020-06-30   -0.035462  2311.250278  2387.972279  1.497272e+09   \n211    AAA 2021-06-30    0.275355  5423.280296  4241.283308  1.456989e+09   \n\n         beta sorting_date  log_mktcap  ret_excess_lead  \n163  1.084724   2017-06-30    7.639380        -0.051090  \n175  0.757288   2018-06-30    7.922416        -0.095926  \n187  0.479600   2019-06-30    8.052462        -0.027856  \n199  0.840952   2020-06-30    7.745544        -0.098769  \n211  0.932948   2021-06-30    8.598456        -0.175128  \nData ready: 5,066 observations from 2017-06-30 to 2023-06-30\n```\n:::\n:::\n\n\n## Step 1: Cross-Sectional Regressions with WLS\n\n@Hou2020 argue that micro-cap stocks distorts inference because they have high transaction costs and idiosyncratic volatility. In Vietnam, this is exacerbated by \"penny stock\" speculation.\n\nWe implement **Weighted Least Squares (WLS)** where weights are the market capitalization of the prior month. This tests if the factors are priced in the *investable* universe, not just the equal-weighted average of tiny stocks.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef run_cross_section(df):\n    # Standardize inputs for numerical stability\n    # Note: We do NOT standardize the dependent variable (returns)\n    # We standardize regressors to interpret coefficients as \"per 1 SD change\" if desired,\n    # BUT for pure risk premium estimation, we usually keep raw units.\n    # Here we use raw units to interpret lambda as % return per unit of characteristic.\n    \n    # Define Weighted Least Squares\n    model = smf.wls(\n        formula=\"ret_excess_lead ~ beta + log_mktcap + bm\",\n        data=df,\n        weights=df[\"mktcap_lag\"] # Weight by size\n    )\n    results = model.fit()\n    \n    return results.params\n\n# Apply to every month\nrisk_premiums = (data_fm\n  .groupby(\"date\")\n  .apply(run_cross_section)\n  .reset_index()\n)\n\nprint(risk_premiums.head())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        date  Intercept      beta  log_mktcap            bm\n0 2017-06-30  -0.097219 -0.026392    0.007891  2.497397e-11\n1 2018-06-30  -0.013960  0.011414   -0.000506  9.531488e-12\n2 2019-06-30  -0.088764  0.027848    0.008125 -1.061931e-11\n3 2020-06-30   0.007088 -0.086277    0.001930 -1.845476e-11\n4 2021-06-30   0.082599 -0.001406   -0.008388 -5.346800e-11\n```\n:::\n:::\n\n\n## Step 2: Time-Series Aggregation & Hypothesis Testing\n\nWe now possess the time-series of risk premiums. We calculate the arithmetic mean and the -statistics.\n\nCrucially, we use **Newey-West (HAC)** standard errors. Risk premiums in Vietnam often exhibit autocorrelation (momentum in factor performance). A simple standard error formula would be invalid.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef calculate_fama_macbeth_stats(df, lags=6):\n    summary = []\n    \n    for col in [\"Intercept\", \"beta\", \"log_mktcap\", \"bm\"]:\n        series = df[col]\n        \n        # 1. Point Estimate (Average Risk Premium)\n        mean_premium = series.mean()\n        \n        # 2. Newey-West Standard Error\n        # We regress the series on a constant (ones) to get the SE of the mean\n        exog = sm.add_constant(np.ones(len(series)))\n        nw_model = sm.OLS(series, exog).fit(\n            cov_type='HAC', cov_kwds={'maxlags': lags}\n        )\n\n        se = nw_model.bse.iloc[0]\n        t_stat = nw_model.tvalues.iloc[0]\n        \n        summary.append({\n            \"Factor\": col,\n            \"Premium (%)\": mean_premium * 100,\n            \"Std Error\": se * 100,\n            \"t-statistic\": t_stat,\n            \"Significance\": \"*\" if abs(t_stat) > 1.96 else \"\"\n        })\n        \n    return pd.DataFrame(summary)\n\nprice_of_risk = calculate_fama_macbeth_stats(risk_premiums)\nprint(price_of_risk.round(4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Factor  Premium (%)  Std Error  t-statistic Significance\n0   Intercept      -1.1205     2.0597      -0.5440             \n1        beta      -0.7404     0.6101      -1.2136             \n2  log_mktcap       0.0676     0.1853       0.3651             \n3          bm      -0.0000     0.0000      -0.0751             \n```\n:::\n:::\n\n\n### Visualizing the Time-Varying Risk Premium\n\nOne major advantage of the FM approach is that we can inspect the volatility of the risk premiums over time. In Vietnam, we expect the \"Size\" premium to be highly volatile during periods of retail liquidity injection (e.g., 2020-2021).\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as mtick\n\n# Calculate cumulative returns of the factors (as if they were tradable portfolios)\ncumulative_premiums = (risk_premiums\n    .set_index(\"date\")\n    .drop(columns=[\"Intercept\"])\n    .cumsum()\n)\n\nfig, ax = plt.subplots(figsize=(10, 6))\ncumulative_premiums.plot(ax=ax, linewidth=2)\nax.set_title(\"Cumulative Risk Premiums in Vietnam (Fama-MacBeth)\", fontsize=14)\nax.set_ylabel(\"Cumulative Coefficient Return\")\nax.legend(title=\"Factor\")\nax.grid(True, alpha=0.3)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Cumulative Risk Premiums in Vietnam.](13_fama_macbeth_files/figure-pdf/fig-cumulative-premiums-output-1.pdf){#fig-cumulative-premiums fig-alt='A line plot displaying the time series of cumulative risk premiums for three factors: beta, log_mktcap, and bm in the Vietnamese market. The x-axis represents time, and the y-axis represents the cumulative coefficient returns.' fig-pos='H'}\n:::\n:::\n\n\n1. **Market Beta:** In many empirical studies (including the US), the market beta premium is often insignificant or even negative (the \"Betting Against Beta\" anomaly). In Vietnam, if the -stat is , it implies the CAPM does not explain the cross-section of returns.\n2. **Size (Log Mktcap):** A negative coefficient confirms the \"Size Effect\"—smaller firms have higher expected returns. However, using WLS often weakens this result compared to OLS, suggesting the size premium is concentrated in micro-caps.\n3. **Value (BM):** A positive coefficient confirms the Value premium. In Vietnam, value stocks (high B/M) often outperform growth stocks, particularly in the manufacturing and banking sectors.\n\nFigure @fig-cumulative-premiums plots the cumulative sum of the monthly Fama MacBeth risk premium estimates for beta, size, and value. Because these lines cumulate estimated cross sectional prices of risk rather than actual portfolio returns, the figure should be interpreted as showing the time variation and persistence of estimated premia, not investable performance.\n\nThe beta premium displays a clear regime shift around 2020, with a sharp decline that only partially reverses afterward. This pattern suggests that the pricing of systematic risk in Vietnam is unstable over short samples and may be heavily influenced by episodic market conditions such as the post COVID retail trading boom. The size premium is comparatively smoother but small in magnitude, indicating only weak and time varying evidence that firm size is priced in the cross section during this period. The value premium remains close to zero throughout, implying little consistent cross sectional reward to high book to market firms in this sample window.\n\nOverall, the figure highlights that estimated risk premia in the Vietnamese market are highly time varying and sensitive to specific macro and market regimes, reinforcing the need for caution when drawing conclusions from short samples.\n\n## Sanity Checks\n### Time-Series Volatility Check\n\nFama-MacBeth relies on the assumption that the risk premium varies over time. If your `bm` premium is truly near zero every month, the method fails.\n\n**Action:** Plot the time series of the estimated coefficients . You want to see \"noise\" around a mean. If you see a flat line or a single massive spike, your data is corrupted.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# Plot the time series of the BM risk premium\nfig, ax = plt.subplots(figsize=(10, 5))\nrisk_premiums[\"bm\"].plot(ax=ax, title=\"Monthly Value Premium (BM) Coefficient\")\nax.axhline(0, color=\"black\", linestyle=\"--\")\nax.set_ylabel(\"Slope Coefficient\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](13_fama_macbeth_files/figure-pdf/cell-8-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n### The \"Predicted vs. Realized\" Scatter Plot\n\nThe ultimate test of an asset pricing model is whether it can price the test assets. If you group your stocks into portfolios (e.g., 25 portfolios sorted by Size and Beta), the model's predicted return should match the actual average return.\n\n**Action:** Compare the model's prediction against reality.\n\n1. Calculate the average realized return for each stock .\n2. Calculate the predicted return: .\n3. Scatter plot them. They should align along the 45-degree line.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# Calculate average characteristics for each stock\nstock_means = data_fm.groupby(\"symbol\")[[\"ret_excess_lead\", \"beta\", \"log_mktcap\", \"bm\"]].mean()\n\n# Calculate Predicted Return using your Shanken results\n# Note: Ensure you grab the 'Premium (%)' divided by 100 if it was scaled\n# Or use the raw mean from risk_premiums\nlambda_beta = risk_premiums[\"beta\"].mean()\nlambda_size = risk_premiums[\"log_mktcap\"].mean()\nlambda_bm = risk_premiums[\"bm\"].mean()\nconst = risk_premiums[\"Intercept\"].mean()\n\nstock_means[\"predicted_ret\"] = (\n    const +\n    stock_means[\"beta\"] * lambda_beta + \n    stock_means[\"log_mktcap\"] * lambda_size + \n    stock_means[\"bm\"] * lambda_bm\n)\n\n# Plot\nfig, ax = plt.subplots(figsize=(8, 8))\nax.scatter(stock_means[\"predicted_ret\"], stock_means[\"ret_excess_lead\"], alpha=0.3)\nax.plot([0, 0.05], [0, 0.05], color='r', linestyle='--') # 45-degree line\nax.set_xlabel(\"Predicted Average Return\")\nax.set_ylabel(\"Realized Average Return\")\nax.set_title(\"Model Fit: Predicted vs Realized\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](13_fama_macbeth_files/figure-pdf/cell-9-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nThe scatter plot compares each stock’s average realized excess return to the return predicted by the estimated risk premia and its characteristics. If the model priced assets well, the points would cluster around the 45 degree line. Instead, the cloud is centered near zero on the horizontal axis, while realized returns vary widely on the vertical axis. The fitted line is nearly flat, indicating that differences in predicted returns explain very little of the variation in realized returns across stocks.\n\nThis pattern implies that, over this sample period, the estimated factor premia have weak cross sectional explanatory power at the individual stock level. Such weak fit is common in emerging markets and in short samples, where idiosyncratic volatility, thin trading, and episodic market regimes dominate the cross section of returns. It also reflects the well known fact that Fama MacBeth tests tend to have low power when applied to individual securities rather than diversified portfolios.\n\n### Correlation of Characteristics (Multicollinearity)\n\nIn Vietnam, large-cap stocks (high `log_mktcap`) are often the ones with high Book-to-Market ratios (banks/utilities) or specific Betas. If your factors are highly correlated, the Fama-MacBeth coefficients will be unstable and insignificant (low t-stats), even if the factors actually matter.\n\n**Action:** Check the cross-sectional correlation.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Check correlation of the characteristics\ncorr_matrix = data_fm[[\"beta\", \"log_mktcap\", \"bm\"]].corr()\nprint(corr_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                beta  log_mktcap        bm\nbeta        1.000000    0.283778 -0.009795\nlog_mktcap  0.283778    1.000000 -0.203279\nbm         -0.009795   -0.203279  1.000000\n```\n:::\n:::\n\n\n**Interpretation:**\n\n* If correlation > 0.7 (absolute value), the regression struggles to distinguish between the two factors.\n* For example, if `Size` and `Liquidity` are -0.8 correlated, the model cannot tell which one is driving the return, often resulting in both having insignificant t-stats.\n\n",
    "supporting": [
      "13_fama_macbeth_files/figure-pdf"
    ],
    "filters": []
  }
}