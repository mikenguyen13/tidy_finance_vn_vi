{
  "hash": "d0a5e1e8cca8a358203c1c8bd856fde7",
  "result": {
    "engine": "jupyter",
    "markdown": "# Momentum Strategies\n\nMomentum is one of the most robust and pervasive anomalies in financial economics. Stocks that have performed well over the past three to twelve months tend to continue performing well over the subsequent three to twelve months, and stocks that have performed poorly tend to continue underperforming. This pattern, first documented by @jegadeesh1993returns, has been replicated across virtually every equity market, asset class, and time period examined, earning it a central place in the canon of empirical asset pricing.\n\nIn this chapter, we provide an implementation of momentum strategies following the methodology of @jegadeesh1993returns. We construct momentum portfolios based on past cumulative returns, evaluate their performance across different formation and holding period combinations, and examine whether the momentum premium exists in the Vietnamese equity market..\n\n## Theoretical Background\n\n### The Momentum Effect\n\nThe momentum effect refers to the tendency of assets with high recent returns to continue generating high returns, and assets with low recent returns to continue generating low returns. More formally, if we define the cumulative return of stock $i$ over the past $J$ months as\n\n$$\nR_{i,t-J:t-1} = \\prod_{s=t-J}^{t-1} (1 + r_{i,s}) - 1\n$$ {#eq-cumret}\n\nthen momentum predicts a positive cross-sectional relationship between $R_{i,t-J:t-1}$ and future returns $r_{i,t}$. That is, stocks in the top decile of past returns (winners) should outperform stocks in the bottom decile (losers) in subsequent months.\n\nThe @jegadeesh1993returns framework parameterizes momentum strategies by two key dimensions:\n\n1.  **Formation period** ($J$): The number of months over which past returns are computed to rank stocks. Typical values range from 3 to 12 months.\n2.  **Holding period** ($K$): The number of months for which the momentum portfolios are held after formation. Typical values also range from 3 to 12 months.\n\nA strategy is therefore characterized by the pair $(J, K)$. For example, a $(6, 6)$ strategy ranks stocks based on their cumulative returns over the past 6 months and holds the resulting portfolios for 6 months.\n\n### Overlapping Portfolios and Calendar-Time Returns\n\nA critical implementation detail in @jegadeesh1993returns is the use of overlapping portfolios. In each month $t$, a new set of portfolios is formed based on the most recent $J$-month returns. However, portfolios formed in months $t-1$, $t-2$, $\\ldots$, $t-K+1$ are still within their holding periods and therefore remain active. The return of the momentum strategy in month $t$ is thus the equally weighted average across all $K$ active cohorts:\n\n$$\nr_{p,t} = \\frac{1}{K} \\sum_{k=0}^{K-1} r_{p,t}^{(t-k)}\n$$ {#eq-overlapping}\n\nwhere $r_{p,t}^{(t-k)}$ denotes the return in month $t$ of the portfolio formed in month $t-k$. This overlapping portfolio approach serves two purposes. First, it reduces the impact of any single formation date on the strategy's performance. Second, it produces a monthly return series that can be analyzed using standard time-series methods, even when the holding period $K$ exceeds one month.\n\n### Theoretical Explanations\n\nThe academic literature offers two broad classes of explanations for the momentum effect.\n\n1.  **Behavioral explanations** attribute momentum to systematic cognitive biases among investors. @daniel1998investor propose a model based on investor overconfidence and biased self-attribution: investors overweight private signals and attribute confirming outcomes to their own skill, leading to initial underreaction followed by delayed overreaction. @hong1999unified develop a model in which information diffuses gradually across heterogeneous investors, generating underreaction to firm-specific news. @barberis1998model formalize a model combining conservatism bias (slow updating of beliefs in response to new evidence) and representativeness heuristic (extrapolation of recent trends).\n2.  **Risk-based explanations** argue that momentum profits represent compensation for systematic risk that varies over time. @johnson2002rational show that momentum can arise in a rational framework if expected returns are stochastic and time-varying. @grundy2001understanding document that momentum portfolios have substantial time-varying factor exposures, suggesting that at least part of the momentum premium reflects dynamic risk. However, standard risk models such as the Fama-French three-factor model have generally struggled to explain momentum returns, which motivated the development of explicit momentum factors such as the Winners-Minus-Losers (WML) factor in @carhart1997persistence.\n\n### Momentum in Emerging Markets\n\nThe behavior of momentum in emerging markets differs substantially from developed markets, and understanding these differences is essential for interpreting our Vietnamese market results.\n\n@rouwenhorst1998international provides early evidence that momentum profits exist in European markets. @chan2000profitability extend the analysis to international equity markets and find that momentum profits are present in most developed markets but are weaker or absent in several Asian markets. @chui2010individualism offer a cultural explanation, documenting that momentum profits are positively related to a country's degree of individualism as measured by @hofstede2001culture. Countries with collectivist cultures, including many in East and Southeast Asia, tend to exhibit weaker momentum effects.\n\nSeveral market microstructure features common in emerging markets may attenuate momentum:\n\n-   **Trading band limits** constrain daily price movements, potentially slowing the adjustment process that generates momentum. Vietnam's HOSE imposes a $\\pm 7\\%$ daily limit, while HNX allows $\\pm 10\\%$.\n-   **Lower liquidity and higher transaction costs** can erode momentum profits, as documented by @lesmond2004illusory.\n-   **Foreign ownership limits** segment the investor base, potentially altering the information diffusion dynamics that underlie momentum.\n-   **Shorter market history** limits the statistical power available to detect the effect.\n\nThese considerations motivate our careful empirical analysis of whether, and to what extent, momentum manifests in Vietnamese equities.\n\n## Setting Up the Environment\n\nWe begin by loading the necessary Python packages. The core packages include `pandas` for data manipulation, `numpy` for numerical operations, and `sqlite3` for database connectivity. We also import `plotnine` for creating publication-quality figures and `scipy` for statistical tests.\n\n::: {#cc988f36 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport sqlite3\nfrom datetime import datetime\nfrom itertools import product\n\nfrom plotnine import *\nfrom mizani.formatters import comma_format, percent_format\nfrom scipy import stats\n```\n:::\n\n\nWe connect to our SQLite database, which stores the cleaned datasets prepared in [Accessing and Managing Financial Data](accessing-and-managing-financial-data.qmd) and [DataCore Data](datacore-data.qmd).\n\n::: {#0d48e849 .cell execution_count=2}\n``` {.python .cell-code}\ntidy_finance = sqlite3.connect(\n    database=\"data/tidy_finance_python.sqlite\"\n)\n```\n:::\n\n\n## Data Preparation\n\n### Loading Monthly Stock Returns\n\nWe load the monthly stock price data from our database. The `prices_monthly` table contains adjusted returns, market capitalizations, and other variables for all stocks listed on HOSE and HNX.\n\n::: {#0ae4e650 .cell execution_count=3}\n``` {.python .cell-code}\nprices_monthly = pd.read_sql_query(\n    # can add \"exchange\" variable\n    sql=\"\"\"\n        SELECT symbol, date, ret, ret_excess, mktcap, mktcap_lag, risk_free\n        FROM prices_monthly\n    \"\"\",\n    con=tidy_finance,\n    parse_dates={\"date\"}\n).dropna()\n\nprint(f\"Total monthly observations: {len(prices_monthly):,}\")\nprint(f\"Unique stocks: {prices_monthly['symbol'].nunique():,}\")\nprint(f\"Date range: {prices_monthly['date'].min().date()} \"\n      f\"to {prices_monthly['date'].max().date()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal monthly observations: 165,499\nUnique stocks: 1,457\nDate range: 2010-02-28 to 2023-12-31\n```\n:::\n:::\n\n\n### Inspecting the Data\n\nBefore proceeding with portfolio construction, we examine the key variables in our dataset. @tbl-data-summary presents the summary statistics for the main variables used in momentum portfolio construction.\n\n::: {#tbl-data-summary .cell tbl-cap='Summary statistics for monthly stock return data. The table reports the count, mean, standard deviation, minimum, 25th percentile, median, 75th percentile, and maximum for monthly returns (ret), excess returns (ret_excess), and market capitalization (mktcap, in billion VND).' execution_count=4}\n``` {.python .cell-code}\nsummary_stats = (prices_monthly\n    [[\"ret\", \"ret_excess\", \"mktcap\"]]\n    .describe()\n    .T\n    .round(4)\n)\nsummary_stats\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>count</th>\n      <th>mean</th>\n      <th>std</th>\n      <th>min</th>\n      <th>25%</th>\n      <th>50%</th>\n      <th>75%</th>\n      <th>max</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>ret</th>\n      <td>165499.0</td>\n      <td>0.0042</td>\n      <td>0.1862</td>\n      <td>-0.9900</td>\n      <td>-0.0703</td>\n      <td>0.0000</td>\n      <td>0.0553</td>\n      <td>12.7500</td>\n    </tr>\n    <tr>\n      <th>ret_excess</th>\n      <td>165499.0</td>\n      <td>0.0008</td>\n      <td>0.1862</td>\n      <td>-0.9933</td>\n      <td>-0.0736</td>\n      <td>-0.0033</td>\n      <td>0.0519</td>\n      <td>12.7467</td>\n    </tr>\n    <tr>\n      <th>mktcap</th>\n      <td>165499.0</td>\n      <td>2183.1646</td>\n      <td>13983.9977</td>\n      <td>0.3536</td>\n      <td>60.3728</td>\n      <td>180.6224</td>\n      <td>660.0000</td>\n      <td>463886.6454</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe also examine the cross-sectional distribution of stocks over time, which is important for understanding whether we have sufficient breadth for decile portfolio construction.\n\n::: {#cell-fig-stock-count .cell execution_count=5}\n``` {.python .cell-code}\nstock_counts = (prices_monthly\n    .groupby(\"date\")[\"symbol\"]\n    .nunique()\n    .reset_index()\n    .rename(columns={\"symbol\": \"n_stocks\"})\n)\n\nplot_stock_counts = (\n    ggplot(stock_counts, aes(x=\"date\", y=\"n_stocks\")) +\n    geom_line(color=\"#1f77b4\") +\n    labs(\n        x=\"\", y=\"Number of stocks\",\n        title=\"Cross-Sectional Breadth Over Time\"\n    ) +\n    theme_minimal() +\n    theme(figure_size=(10, 5))\n)\nplot_stock_counts\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![Number of stocks with available return data over time. The figure shows the monthly cross-section of stocks available for momentum portfolio construction. A minimum number of stocks is needed to form meaningful decile portfolios.](13_momemtum_files/figure-html/fig-stock-count-output-1.png){#fig-stock-count width=960 height=480 fig-alt='A line chart showing the number of stocks with available monthly returns over time, generally increasing from a small number in the early 2000s to several hundred in recent years.'}\n:::\n:::\n\n\n### Loading Factor Data\n\nWe also load the Fama-French factor returns for risk-adjusted performance evaluation. These factors were constructed in [Fama-French Factors](fama-french-factors.qmd).\n\n::: {#3f5f26ad .cell execution_count=6}\n``` {.python .cell-code}\nfactors_ff3_monthly = pd.read_sql_query(\n    sql=\"SELECT date, mkt_excess, smb, hml, risk_free FROM factors_ff3_monthly\",\n    con=tidy_finance,\n    parse_dates={\"date\"}\n)\n\nprint(f\"Factor observations: {len(factors_ff3_monthly):,}\")\nprint(f\"Date range: {factors_ff3_monthly['date'].min().date()} \"\n      f\"to {factors_ff3_monthly['date'].max().date()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFactor observations: 150\nDate range: 2011-07-31 to 2023-12-31\n```\n:::\n:::\n\n\n### Data Quality Filters\n\nMomentum strategies require continuous return histories for the formation period. We apply several filters to ensure data quality:\n\n1.  **Minimum price filter**: We exclude penny stocks with prices below 1,000 VND, which are subject to extreme microstructure noise.\n2.  **Return availability**: We require non-missing returns for the entire formation period.\n3.  **Market capitalization**: We require positive lagged market capitalization for portfolio weighting.\n\n::: {#1d6d3d7d .cell execution_count=7}\n``` {.python .cell-code}\n# Filter for stocks with positive market cap and non-missing returns\nprices_clean = (prices_monthly\n    .dropna(subset=[\"ret\", \"mktcap\"])\n    .query(\"mktcap > 0\")\n    .sort_values([\"symbol\", \"date\"])\n    .reset_index(drop=True)\n)\n\nprint(f\"Observations after filtering: {len(prices_clean):,}\")\nprint(f\"Stocks after filtering: {prices_clean['symbol'].nunique():,}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nObservations after filtering: 165,499\nStocks after filtering: 1,457\n```\n:::\n:::\n\n\n## Momentum Portfolio Construction\n\n### Computing Formation Period Returns\n\nThe first step in constructing momentum portfolios is to compute cumulative returns over the formation period. For a formation period of $J$ months, we compute the cumulative return for each stock $i$ at the end of month $t$ as specified in @eq-cumret.\n\nWe implement this using a rolling product of gross returns. A key detail is that we require non-missing returns for all $J$ months in the formation window. If any monthly return is missing, the cumulative return is set to missing, and the stock is excluded from portfolio formation in that month.\n\n::: {#8403799f .cell execution_count=8}\n``` {.python .cell-code}\ndef compute_formation_returns(data, J):\n    \"\"\"\n    Compute J-month cumulative returns for momentum portfolio formation.\n    \n    Parameters\n    ----------\n    data : pd.DataFrame\n        Panel data with columns 'symbol', 'date', 'ret'.\n    J : int\n        Formation period length in months (typically 3-12).\n    \n    Returns\n    -------\n    pd.DataFrame\n        Original data augmented with 'cum_return' column.\n    \"\"\"\n    df = data.sort_values([\"symbol\", \"date\"]).copy()\n    \n    # Compute rolling J-month cumulative return\n    # Using gross returns: (1+r1)*(1+r2)*...*(1+rJ) - 1\n    df[\"gross_ret\"] = 1 + df[\"ret\"]\n    \n    df[\"cum_return\"] = (\n        df.groupby(\"symbol\")[\"gross_ret\"]\n        .rolling(window=J, min_periods=J)\n        .apply(np.prod, raw=True)\n        .reset_index(level=0, drop=True)\n        - 1\n    )\n    \n    df = df.drop(columns=[\"gross_ret\"])\n    \n    return df\n```\n:::\n\n\nLet us apply this function for our baseline case with $J = 6$ months:\n\n::: {#b3f801aa .cell execution_count=9}\n``` {.python .cell-code}\nJ = 6  # Formation period: 6 months\n\nprices_with_cumret = compute_formation_returns(prices_clean, J)\n\n# Check the result\nprint(f\"Observations with valid {J}-month cumulative returns: \"\n      f\"{prices_with_cumret['cum_return'].notna().sum():,}\")\nprint(f\"\\nCumulative return distribution:\")\nprint(prices_with_cumret[\"cum_return\"].describe().round(4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nObservations with valid 6-month cumulative returns: 158,227\n\nCumulative return distribution:\ncount    158227.0000\nmean          0.0171\nstd           0.5053\nmin          -0.9999\n25%          -0.2196\n50%          -0.0400\n75%           0.1404\nmax          35.7136\nName: cum_return, dtype: float64\n```\n:::\n:::\n\n\n### Assigning Momentum Decile Portfolios\n\nEach month, we sort all stocks with valid cumulative returns into decile portfolios based on their past $J$-month performance. Portfolio 1 contains the bottom decile (losers) and portfolio 10 contains the top decile (winners).\n\n::: {#628ef240 .cell execution_count=10}\n`````` {.python .cell-code}\ndef assign_momentum_portfolios(data, n_portfolios=10):\n    \"\"\"\n    Assign stocks to momentum portfolios based on formation-period returns.\n\n    For each cross-section (month), stocks are sorted into \n    n_portfolios quantile groups according to their cumulative return.\n    \n    Portfolio 1 = lowest past returns (Losers)\n    Portfolio n_portfolios = highest past returns (Winners)\n\n    This implementation uses `groupby().transform()` rather than \n    `groupby().apply()` to preserve the original DataFrame structure \n    and avoid index mutation issues.\n\n    Parameters\n    ----------\n    data : pd.DataFrame\n        Panel data containing at minimum:\n        - 'symbol' : stock identifier\n        - 'date' : formation month\n        - 'cum_return' : cumulative return over formation window\n\n    n_portfolios : int, optional\n        Number of portfolios to form (default = 10 for deciles).\n\n    Returns\n    -------\n    pd.DataFrame\n        Original data augmented with:\n        - 'momr' : integer momentum rank (1 to n_portfolios)\n    \"\"\"\n\n    # Drop observations without formation-period returns\n    # These cannot be ranked into portfolios\n    df = data.dropna(subset=[\"cum_return\"]).copy()\n\n    def safe_qcut(x):\n        \"\"\"\n        Assign quantile portfolio labels within a single cross-section.\n\n        Uses pd.qcut to create approximately equal-sized portfolios.\n        If too few unique return values exist (which can happen in \n        small markets or illiquid samples), fall back to rank-based \n        binning to ensure portfolios are still formed.\n        \"\"\"\n        try:\n            # Standard quantile sorting\n            return pd.qcut(\n                x,\n                q=n_portfolios,\n                labels=range(1, n_portfolios + 1),\n                duplicates=\"drop\"  # prevents crash if quantile edges duplicate\n            )\n        except ValueError:\n            # Fallback: rank then evenly cut into bins\n            return pd.cut(\n                x.rank(method=\"first\"),\n                bins=n_portfolios,\n                labels=range(1, n_portfolios + 1)\n            )\n\n    # Cross-sectional portfolio assignment:\n    # For each month, compute portfolio ranks based on cum_return.\n    # transform ensures:\n    # - original row order preserved\n    # - no index mutation\n    # - no loss of 'date' column\n    df[\"momr\"] = (\n        df.groupby(\"date\")[\"cum_return\"]\n          .transform(safe_qcut)\n          .astype(int)\n    )\n\n    return df\n``````\n:::\n\n\n::: {#4753cee8 .cell execution_count=11}\n``` {.python .cell-code}\nportfolios = assign_momentum_portfolios(prices_with_cumret)\n\nprint(f\"Stocks assigned to portfolios: {len(portfolios):,}\")\nprint(f\"\\nPortfolio distribution (should be approximately equal):\")\nprint(portfolios.groupby(\"momr\")[\"symbol\"].count().to_frame(\"count\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStocks assigned to portfolios: 158,227\n\nPortfolio distribution (should be approximately equal):\n      count\nmomr       \n1     15894\n2     15815\n3     16021\n4     15759\n5     15738\n6     16568\n7     15288\n8     15582\n9     15697\n10    15865\n```\n:::\n:::\n\n\n### Defining Holding Period Dates\n\nAfter forming portfolios at the end of month $t$, we hold them from the beginning of month $t+1$ through the end of month $t+K$. This one-month gap between the formation period and the start of the holding period is standard in the literature and avoids the well-documented short-term reversal effect at the one-month horizon [@jegadeesh1990evidence].\n\n::: {#7125926d .cell execution_count=12}\n``` {.python .cell-code}\nK = 6  # Holding period: 6 months\n\nportfolios_with_dates = portfolios.copy()\nportfolios_with_dates = portfolios_with_dates.rename(\n    columns={\"date\": \"form_date\"}\n)\n\n# Define holding period start and end dates\nportfolios_with_dates[\"hdate1\"] = (\n    portfolios_with_dates[\"form_date\"] + pd.offsets.MonthBegin(1)\n)\nportfolios_with_dates[\"hdate2\"] = (\n    portfolios_with_dates[\"form_date\"] + pd.offsets.MonthEnd(K)\n)\n\nprint(portfolios_with_dates[\n    [\"symbol\", \"form_date\", \"cum_return\", \"momr\", \"hdate1\", \"hdate2\"]\n].head(10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   symbol  form_date  cum_return  momr     hdate1     hdate2\n5     A32 2019-04-30   -0.061599     4 2019-05-01 2019-10-31\n6     A32 2019-05-31   -0.213675     2 2019-06-01 2019-11-30\n7     A32 2019-06-30   -0.308720     2 2019-07-01 2019-12-31\n8     A32 2019-07-31   -0.249936     2 2019-08-01 2020-01-31\n9     A32 2019-08-31    0.061986     8 2019-09-01 2020-02-29\n10    A32 2019-09-30    0.030751     8 2019-10-01 2020-03-31\n11    A32 2019-10-31    0.030751     8 2019-11-01 2020-04-30\n12    A32 2019-11-30    0.032486     8 2019-12-01 2020-05-31\n13    A32 2019-12-31    0.180073     9 2020-01-01 2020-06-30\n14    A32 2020-01-31    0.412322    10 2020-02-01 2020-07-31\n```\n:::\n:::\n\n\n### Computing Portfolio Holding Period Returns\n\nWe now compute the returns of each portfolio during its holding period. For each stock-formation date combination, we merge in the actual returns realized during the holding window. This produces a panel of stock returns indexed by formation date, holding date, and momentum portfolio rank.\n\n::: {#18f5d66d .cell execution_count=13}\n``` {.python .cell-code}\n# Merge: for each portfolio assignment, get all returns during holding period\nportfolio_returns = portfolios_with_dates.merge(\n    prices_clean[[\"symbol\", \"date\", \"ret\"]].rename(\n        columns={\"ret\": \"hret\", \"date\": \"hdate\"}\n    ),\n    on=\"symbol\",\n    how=\"inner\"\n)\n\n# Keep only returns within the holding period\nportfolio_returns = portfolio_returns.query(\n    \"hdate >= hdate1 and hdate <= hdate2\"\n)\n\nprint(f\"Portfolio-holding period observations: {len(portfolio_returns):,}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPortfolio-holding period observations: 918,072\n```\n:::\n:::\n\n\n### Computing Equally Weighted Portfolio Returns\n\nThe @jegadeesh1993returns methodology uses equally weighted portfolios. For each holding month, each momentum decile has $K$ active cohorts (one formed in each of the past $K$ months). We first compute the equally weighted return within each cohort, then average across cohorts to get the final monthly portfolio return.\n\n::: {#e4cf4b64 .cell execution_count=14}\n``` {.python .cell-code}\n# Step 1: Average return within each cohort (form_date × momr × hdate)\ncohort_returns = (portfolio_returns\n    .groupby([\"hdate\", \"momr\", \"form_date\"])\n    .agg(cohort_ret=(\"hret\", \"mean\"))\n    .reset_index()\n)\n\n# Step 2: Average across cohorts for each momentum portfolio × month\newret = (cohort_returns\n    .groupby([\"hdate\", \"momr\"])\n    .agg(\n        ewret=(\"cohort_ret\", \"mean\"),\n        ewret_std=(\"cohort_ret\", \"std\"),\n        n_cohorts=(\"cohort_ret\", \"count\")\n    )\n    .reset_index()\n    .rename(columns={\"hdate\": \"date\"})\n)\n\nprint(f\"Monthly portfolio return observations: {len(ewret):,}\")\nprint(f\"Date range: {ewret['date'].min().date()} to {ewret['date'].max().date()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMonthly portfolio return observations: 1,610\nDate range: 2010-08-31 to 2023-12-31\n```\n:::\n:::\n\n\nWe should verify that we have the expected number of active cohorts per month. Once the strategy has been running for at least $K$ months, each momentum decile should have exactly $K$ active cohorts.\n\n::: {#cell-fig-cohort-count .cell execution_count=15}\n``` {.python .cell-code}\ncohort_check = (ewret\n    .groupby(\"date\")[\"n_cohorts\"]\n    .mean()\n    .reset_index()\n    .rename(columns={\"n_cohorts\": \"avg_cohorts\"})\n)\n\nplot_cohorts = (\n    ggplot(cohort_check, aes(x=\"date\", y=\"avg_cohorts\")) +\n    geom_line(color=\"#1f77b4\") +\n    geom_hline(yintercept=K, linetype=\"dashed\", color=\"red\") +\n    labs(\n        x=\"\", y=\"Average number of cohorts\",\n        title=f\"Active Cohorts per Portfolio (K={K})\"\n    ) +\n    theme_minimal() +\n    theme(figure_size=(10, 4))\n)\nplot_cohorts\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n![Number of active cohorts per momentum portfolio over time. After an initial ramp-up period of K months, each portfolio should have exactly K active cohorts contributing to its monthly return.](13_momemtum_files/figure-html/fig-cohort-count-output-1.png){#fig-cohort-count width=960 height=384 fig-alt='A line chart showing the number of active cohorts per momentum portfolio over time, ramping up from 1 to K during the initial months and then remaining stable at K.'}\n:::\n:::\n\n\n## Baseline Results: J=6, K=6 Strategy\n\n### Summary Statistics by Momentum Decile\n\nWe now examine the average monthly returns for each momentum decile portfolio. @tbl-momentum-deciles presents the mean, $t$-statistic, and $p$-value for each of the ten portfolios.\n\n::: {#tbl-momentum-deciles .cell tbl-cap='Average monthly returns of momentum decile portfolios for the J=6, K=6 strategy. Portfolio 1 contains past losers and portfolio 10 contains past winners. The table reports the number of months, mean monthly return, t-statistic, and p-value for each decile.' execution_count=16}\n``` {.python .cell-code}\ndef compute_portfolio_stats(group):\n    \"\"\"Compute mean, t-stat, and p-value for a return series.\"\"\"\n    n = len(group)\n    mean_ret = group.mean()\n    std_ret = group.std()\n    t_stat = mean_ret / (std_ret / np.sqrt(n)) if std_ret > 0 else np.nan\n    p_val = 2 * (1 - stats.t.cdf(abs(t_stat), df=n-1)) if not np.isnan(t_stat) else np.nan\n    return pd.Series({\n        \"N\": n,\n        \"Mean (%)\": mean_ret * 100,\n        \"Std (%)\": std_ret * 100,\n        \"t-stat\": t_stat,\n        \"p-value\": p_val\n    })\n\nmomentum_stats = (ewret\n    .groupby(\"momr\")[\"ewret\"]\n    .apply(compute_portfolio_stats)\n    .unstack()\n    .round(4)\n)\n\nmomentum_stats\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>N</th>\n      <th>Mean (%)</th>\n      <th>Std (%)</th>\n      <th>t-stat</th>\n      <th>p-value</th>\n    </tr>\n    <tr>\n      <th>momr</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1</th>\n      <td>161.0</td>\n      <td>1.4190</td>\n      <td>6.5319</td>\n      <td>2.7565</td>\n      <td>0.0065</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>161.0</td>\n      <td>0.6602</td>\n      <td>5.9895</td>\n      <td>1.3985</td>\n      <td>0.1639</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>161.0</td>\n      <td>0.3658</td>\n      <td>5.5080</td>\n      <td>0.8427</td>\n      <td>0.4007</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>161.0</td>\n      <td>0.1623</td>\n      <td>5.0085</td>\n      <td>0.4112</td>\n      <td>0.6815</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>161.0</td>\n      <td>0.0111</td>\n      <td>4.7561</td>\n      <td>0.0297</td>\n      <td>0.9763</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>161.0</td>\n      <td>0.0408</td>\n      <td>4.6864</td>\n      <td>0.1104</td>\n      <td>0.9122</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>161.0</td>\n      <td>-0.0674</td>\n      <td>4.8881</td>\n      <td>-0.1749</td>\n      <td>0.8614</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>161.0</td>\n      <td>-0.2066</td>\n      <td>4.9208</td>\n      <td>-0.5329</td>\n      <td>0.5949</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>161.0</td>\n      <td>-0.2228</td>\n      <td>5.3013</td>\n      <td>-0.5332</td>\n      <td>0.5946</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>161.0</td>\n      <td>-0.6812</td>\n      <td>5.7131</td>\n      <td>-1.5130</td>\n      <td>0.1323</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### The Long-Short Momentum Portfolio\n\nThe key test of the momentum effect is whether the spread between winners and losers—the long-short momentum portfolio—generates statistically significant positive returns. We construct this spread portfolio by going long the top decile (portfolio 10) and short the bottom decile (portfolio 1).\n\n::: {#76f1a769 .cell execution_count=17}\n``` {.python .cell-code}\n# Pivot to wide format\newret_wide = ewret.pivot(\n    index=\"date\", columns=\"momr\", values=\"ewret\"\n).reset_index()\n\newret_wide.columns = [\"date\"] + [f\"port{i}\" for i in range(1, 11)]\n\n# Compute long-short return\newret_wide[\"winners\"] = ewret_wide[\"port10\"]\newret_wide[\"losers\"] = ewret_wide[\"port1\"]\newret_wide[\"long_short\"] = ewret_wide[\"winners\"] - ewret_wide[\"losers\"]\n```\n:::\n\n\n::: {#tbl-long-short .cell tbl-cap='Performance of the momentum long-short strategy (J=6, K=6). Winners is the top decile, Losers is the bottom decile, and Long-Short is Winners minus Losers. The table reports the number of months, mean monthly return, t-statistic, and p-value.' execution_count=18}\n``` {.python .cell-code}\nls_stats = pd.DataFrame()\nfor col in [\"winners\", \"losers\", \"long_short\"]:\n    series = ewret_wide[col].dropna()\n    n = len(series)\n    mean_val = series.mean()\n    std_val = series.std()\n    t_val = mean_val / (std_val / np.sqrt(n))\n    p_val = 2 * (1 - stats.t.cdf(abs(t_val), df=n-1))\n    ls_stats[col] = [n, mean_val * 100, std_val * 100, t_val, p_val]\n\nls_stats.index = [\"N\", \"Mean (%)\", \"Std (%)\", \"t-stat\", \"p-value\"]\nls_stats.columns = [\"Winners\", \"Losers\", \"Long-Short\"]\nls_stats = ls_stats.round(4)\nls_stats\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Winners</th>\n      <th>Losers</th>\n      <th>Long-Short</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>N</th>\n      <td>161.0000</td>\n      <td>161.0000</td>\n      <td>161.0000</td>\n    </tr>\n    <tr>\n      <th>Mean (%)</th>\n      <td>-0.6812</td>\n      <td>1.4190</td>\n      <td>-2.1002</td>\n    </tr>\n    <tr>\n      <th>Std (%)</th>\n      <td>5.7131</td>\n      <td>6.5319</td>\n      <td>4.8969</td>\n    </tr>\n    <tr>\n      <th>t-stat</th>\n      <td>-1.5130</td>\n      <td>2.7565</td>\n      <td>-5.4420</td>\n    </tr>\n    <tr>\n      <th>p-value</th>\n      <td>0.1323</td>\n      <td>0.0065</td>\n      <td>0.0000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Cumulative Returns\n\nThe time-series evolution of cumulative returns provides visual evidence of the momentum strategy's performance. @fig-cumret-winners-losers shows the cumulative returns of the winner and loser portfolios, while @fig-cumret-long-short shows the cumulative return of the long-short momentum strategy.\n\n::: {#73e6a4ef .cell execution_count=19}\n``` {.python .cell-code}\n# Compute cumulative returns\newret_wide = ewret_wide.sort_values(\"date\").reset_index(drop=True)\n\nfor col in [\"winners\", \"losers\", \"long_short\"]:\n    ewret_wide[f\"cumret_{col}\"] = (1 + ewret_wide[col]).cumprod() - 1\n```\n:::\n\n\n::: {#cell-fig-cumret-winners-losers .cell execution_count=20}\n``` {.python .cell-code}\ncumret_plot_data = (ewret_wide\n    [[\"date\", \"cumret_winners\", \"cumret_losers\"]]\n    .melt(id_vars=\"date\", var_name=\"portfolio\", value_name=\"cumret\")\n)\ncumret_plot_data[\"portfolio\"] = cumret_plot_data[\"portfolio\"].map({\n    \"cumret_winners\": \"Winners (P10)\",\n    \"cumret_losers\": \"Losers (P1)\"\n})\n\nplot_cumret = (\n    ggplot(cumret_plot_data, \n           aes(x=\"date\", y=\"cumret\", color=\"portfolio\")) +\n    geom_line(size=1) +\n    scale_y_continuous(labels=percent_format()) +\n    scale_color_manual(values=[\"#d62728\", \"#1f77b4\"]) +\n    labs(\n        x=\"\", y=\"Cumulative return\",\n        color=\"Portfolio\",\n        title=\"Cumulative Returns: Winners vs. Losers\"\n    ) +\n    theme_minimal() +\n    theme(\n        figure_size=(10, 6),\n        legend_position=\"bottom\"\n    )\n)\nplot_cumret\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n![Cumulative returns of momentum winner and loser portfolios. The winner portfolio (blue) contains stocks in the top decile of past 6-month returns, and the loser portfolio (red) contains stocks in the bottom decile. The spread between the two lines reflects the cumulative momentum premium.](13_momemtum_files/figure-html/fig-cumret-winners-losers-output-1.png){#fig-cumret-winners-losers width=960 height=576 fig-alt='A line chart showing cumulative returns of the winner and loser momentum portfolios over time. The winner portfolio generally accumulates higher returns than the loser portfolio, though both exhibit substantial variation.'}\n:::\n:::\n\n\n::: {#cell-fig-cumret-long-short .cell execution_count=21}\n``` {.python .cell-code}\nplot_ls = (\n    ggplot(ewret_wide, aes(x=\"date\", y=\"cumret_long_short\")) +\n    geom_line(size=1, color=\"#2ca02c\") +\n    geom_hline(yintercept=0, linetype=\"dashed\", color=\"gray\") +\n    scale_y_continuous(labels=percent_format()) +\n    labs(\n        x=\"\", y=\"Cumulative return\",\n        title=\"Cumulative Return: Long-Short Momentum Strategy\"\n    ) +\n    theme_minimal() +\n    theme(figure_size=(10, 6))\n)\nplot_ls\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n![Cumulative return of the momentum long-short strategy (Winners minus Losers). Upward-sloping periods indicate momentum profits; sharp drawdowns often coincide with market reversals or crisis episodes.](13_momemtum_files/figure-html/fig-cumret-long-short-output-1.png){#fig-cumret-long-short width=960 height=576 fig-alt='A line chart showing the cumulative return of the long-short momentum strategy over time, exhibiting periods of accumulation interspersed with sharp drawdowns.'}\n:::\n:::\n\n\n### Monthly Return Distribution\n\nBeyond the mean, the full distribution of monthly long-short returns provides insight into the risk profile of the momentum strategy. @fig-return-distribution shows the histogram of monthly returns.\n\n::: {#cell-fig-return-distribution .cell execution_count=22}\n``` {.python .cell-code}\nmean_ls = ewret_wide[\"long_short\"].mean()\n\nplot_dist = (\n    ggplot(ewret_wide, aes(x=\"long_short\")) +\n    geom_histogram(bins=50, fill=\"#1f77b4\", alpha=0.7) +\n    geom_vline(xintercept=mean_ls, linetype=\"dashed\", color=\"red\") +\n    scale_x_continuous(labels=percent_format()) +\n    labs(\n        x=\"Monthly long-short return\",\n        y=\"Frequency\",\n        title=\"Distribution of Monthly Momentum Returns\"\n    ) +\n    theme_minimal() +\n    theme(figure_size=(10, 5))\n)\nplot_dist\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n![Distribution of monthly long-short momentum returns. The histogram shows the frequency distribution of monthly Winners-minus-Losers returns. The vertical dashed line indicates the mean monthly return.](13_momemtum_files/figure-html/fig-return-distribution-output-1.png){#fig-return-distribution width=960 height=480 fig-alt='A histogram of monthly long-short momentum returns, approximately centered near zero or slightly positive, with tails extending in both directions.'}\n:::\n:::\n\n\n## Extending to Multiple Formation and Holding Periods\n\n### The J × K Grid\n\n@jegadeesh1993returns evaluate momentum strategies across a comprehensive grid of formation periods $J \\in \\{3, 6, 9, 12\\}$ and holding periods $K \\in \\{3, 6, 9, 12\\}$. This produces 16 different strategy specifications, allowing us to assess the robustness of the momentum effect across different horizons.\n\nWe now implement a function that computes the full momentum strategy for any given $(J, K)$ pair, wrapping the steps developed above into a single reusable pipeline.\n\n::: {#588a9401 .cell execution_count=23}\n``` {.python .cell-code}\nfrom joblib import Parallel, delayed\nimport time\n\ndef momentum_strategy(data, J, K, n_portfolios=10):\n    \"\"\"\n    Implement the full Jegadeesh-Titman momentum strategy.\n    \n    Parameters\n    ----------\n    data : pd.DataFrame\n        Panel of stock returns with columns: symbol, date, ret.\n    J : int\n        Formation period in months.\n    K : int\n        Holding period in months.\n    n_portfolios : int\n        Number of portfolios (default: 10 for deciles).\n    \n    Returns\n    -------\n    pd.DataFrame\n        Monthly returns for each momentum portfolio and the long-short spread.\n    \"\"\"\n    # Step 1: Compute formation period cumulative returns\n    df = data.sort_values([\"symbol\", \"date\"]).copy()\n    df[\"gross_ret\"] = 1 + df[\"ret\"]\n    df[\"cum_return\"] = (\n        df.groupby(\"symbol\")[\"gross_ret\"]\n        .rolling(window=J, min_periods=J)\n        .apply(np.prod, raw=True)\n        .reset_index(level=0, drop=True)\n        - 1\n    )\n    df = df.drop(columns=[\"gross_ret\"]).dropna(subset=[\"cum_return\"])\n    \n    # Step 2: Assign to momentum portfolios using transform\n    df[\"momr\"] = df.groupby(\"date\", observed=True)[\"cum_return\"].transform(\n        lambda x: pd.qcut(\n            x,\n            q=n_portfolios,\n            labels=range(1, n_portfolios + 1),\n            duplicates=\"drop\"\n        )\n    ).astype('Int64')\n    \n    # If any NaNs in momr, fill with rank-based assignment\n    mask = df[\"momr\"].isna()\n    if mask.any():\n        df.loc[mask, \"momr\"] = df.loc[mask].groupby(\"date\")[\"cum_return\"].transform(\n            lambda x: pd.qcut(\n                x.rank(method=\"first\"),\n                q=min(n_portfolios, len(x.unique())),\n                labels=False,\n                duplicates=\"drop\"\n            )\n        ).astype('Int64') + 1\n    \n    # Step 3: Define holding period dates\n    df = df.rename(columns={\"date\": \"form_date\"})\n    df[\"hdate1\"] = df[\"form_date\"] + pd.offsets.MonthBegin(1)\n    df[\"hdate2\"] = df[\"form_date\"] + pd.offsets.MonthEnd(K)\n    \n    # Step 4: Merge with holding period returns\n    port_ret = df[[\"symbol\", \"form_date\", \"momr\", \"hdate1\", \"hdate2\"]].merge(\n        data[[\"symbol\", \"date\", \"ret\"]].rename(\n            columns={\"ret\": \"hret\", \"date\": \"hdate\"}\n        ),\n        on=\"symbol\",\n        how=\"inner\"\n    )\n    \n    # Use boolean indexing\n    port_ret = port_ret[\n        (port_ret[\"hdate\"] >= port_ret[\"hdate1\"]) & \n        (port_ret[\"hdate\"] <= port_ret[\"hdate2\"])\n    ]\n    \n    # Step 5: Compute equally weighted returns (two-stage averaging)\n    cohort_ret = (port_ret\n        .groupby([\"hdate\", \"momr\", \"form_date\"])\n        .agg(cohort_ret=(\"hret\", \"mean\"))\n        .reset_index()\n    )\n    \n    monthly_ret = (cohort_ret\n        .groupby([\"hdate\", \"momr\"])\n        .agg(ewret=(\"cohort_ret\", \"mean\"))\n        .reset_index()\n        .rename(columns={\"hdate\": \"date\"})\n    )\n    \n    # Step 6: Compute long-short spread\n    wide = monthly_ret.pivot(\n        index=\"date\", columns=\"momr\", values=\"ewret\"\n    ).reset_index()\n    \n    # Handle variable number of portfolios\n    n_cols = len(wide.columns) - 1\n    wide.columns = [\"date\"] + [f\"port{i}\" for i in range(1, n_cols + 1)]\n    wide[\"winners\"] = wide[f\"port{n_cols}\"]\n    wide[\"losers\"] = wide[\"port1\"]\n    wide[\"long_short\"] = wide[\"winners\"] - wide[\"losers\"]\n    \n    return monthly_ret, wide\n```\n:::\n\n\n### Running the Full Grid\n\nWe now run the momentum strategy for all 16 $(J, K)$ combinations. This is computationally intensive, so we store the key summary statistics for each specification.\n\n#### Sequential Calculation\n\n::: {#momemtum-calculation-squential .cell execution_count=24}\n``` {.python .cell-code}\nJ_values = [3, 6, 9, 12]\nK_values = [3, 6, 9, 12]\n\nresults_grid = []\n\nfor J_val, K_val in product(J_values, K_values):\n    print(f\"Computing J={J_val}, K={K_val}...\", end=\" \")\n    \n    try:\n        _, wide_result = momentum_strategy(prices_clean, J_val, K_val)\n        \n        for portfolio_name in [\"winners\", \"losers\", \"long_short\"]:\n            series = wide_result[portfolio_name].dropna()\n            n = len(series)\n            mean_ret = series.mean()\n            std_ret = series.std()\n            t_stat = mean_ret / (std_ret / np.sqrt(n)) if std_ret > 0 else np.nan\n            p_val = (2 * (1 - stats.t.cdf(abs(t_stat), df=n-1)) \n                     if not np.isnan(t_stat) else np.nan)\n            \n            results_grid.append({\n                \"J\": J_val,\n                \"K\": K_val,\n                \"portfolio\": portfolio_name,\n                \"n_months\": n,\n                \"mean_ret\": mean_ret,\n                \"std_ret\": std_ret,\n                \"t_stat\": t_stat,\n                \"p_value\": p_val\n            })\n        \n        print(\"Done.\")\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nresults_df = pd.DataFrame(results_grid)\n```\n:::\n\n\n#### Parallel Calculation\n\n::: {#2ecf2e86 .cell execution_count=25}\n``` {.python .cell-code}\ndef compute_single_strategy(data, J, K):\n    \"\"\"\n    Compute statistics for a single (J, K) strategy.\n    Returns a list of result dicts, one per portfolio.\n    \"\"\"\n    try:\n        _, wide_result = momentum_strategy(data, J, K)\n        \n        results = []\n        for portfolio_name in [\"winners\", \"losers\", \"long_short\"]:\n            series = wide_result[portfolio_name].dropna()\n            n = len(series)\n            mean_ret = series.mean()\n            std_ret = series.std()\n            t_stat = mean_ret / (std_ret / np.sqrt(n)) if std_ret > 0 else np.nan\n            p_val = (2 * (1 - stats.t.cdf(abs(t_stat), df=n-1)) \n                     if not np.isnan(t_stat) else np.nan)\n            \n            results.append({\n                \"J\": J,\n                \"K\": K,\n                \"portfolio\": portfolio_name,\n                \"n_months\": n,\n                \"mean_ret\": mean_ret,\n                \"std_ret\": std_ret,\n                \"t_stat\": t_stat,\n                \"p_value\": p_val\n            })\n        return results\n    except Exception as e:\n        print(f\"Error in J={J}, K={K}: {e}\")\n        return []\n```\n:::\n\n\n::: {#9ba734a0 .cell execution_count=26}\n``` {.python .cell-code}\nJ_values = [3, 6, 9, 12]\nK_values = [3, 6, 9, 12]\n\n# Create list of (J, K) pairs\nparams = list(product(J_values, K_values))\n\nprint(f\"Running {len(params)} momentum strategies in parallel with 4 cores...\")\nstart_time = time.time()\n\n# Parallel execution with 4 workers\nresults_list = Parallel(n_jobs=4, verbose=10)(\n    delayed(compute_single_strategy)(prices_clean, J, K)\n    for J, K in params\n)\n\n# Flatten results\nresults_grid = [item for sublist in results_list for item in sublist]\nresults_df = pd.DataFrame(results_grid)\n\nelapsed = time.time() - start_time\nprint(f\"\\nCompleted in {elapsed:.2f} seconds\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning 16 momentum strategies in parallel with 4 cores...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n[Parallel(n_jobs=4)]: Using backend LokyBackend with 4 concurrent workers.\n[Parallel(n_jobs=4)]: Done   5 tasks      | elapsed:    8.9s\n[Parallel(n_jobs=4)]: Done  11 out of  16 | elapsed:   14.6s remaining:    6.6s\n[Parallel(n_jobs=4)]: Done  13 out of  16 | elapsed:   19.4s remaining:    4.5s\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCompleted in 20.20 seconds\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n[Parallel(n_jobs=4)]: Done  16 out of  16 | elapsed:   20.1s finished\n```\n:::\n:::\n\n\n::: {#3e8bdbc4 .cell execution_count=27}\n``` {.python .cell-code}\n# Summary statistics\nprint(\"\\nResults Summary by Formation Period:\")\nprint(results_df.groupby(\"J\").agg({\n    \"mean_ret\": \"mean\",\n    \"std_ret\": \"mean\",\n    \"t_stat\": [\"mean\", lambda x: (x.abs() > 1.96).sum()],\n    \"n_months\": \"first\"\n}).round(6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nResults Summary by Formation Period:\n    mean_ret   std_ret    t_stat            n_months\n        mean      mean      mean <lambda_0>    first\nJ                                                   \n6  -0.004661  0.055672 -1.517507          9      161\n9  -0.003265  0.056520 -1.071904          9      158\n12 -0.002759  0.058194 -0.931273          9      155\n```\n:::\n:::\n\n\n### Winners Portfolio Returns\n\n@tbl-winners-grid presents the average monthly returns of the winner portfolio (portfolio 10) across all $(J, K)$ combinations.\n\n::: {#tbl-winners-grid .cell tbl-cap='Average monthly returns (%) of the winner portfolio across formation periods (J) and holding periods (K). t-statistics are reported in parentheses.' execution_count=28}\n``` {.python .cell-code}\nwinners_grid = (results_df\n    .query(\"portfolio == 'winners'\")\n    .assign(\n        display=lambda x: (\n            x[\"mean_ret\"].apply(lambda v: f\"{v*100:.2f}\") + \n            \"\\n(\" + x[\"t_stat\"].apply(lambda v: f\"{v:.2f}\") + \")\"\n        )\n    )\n    .pivot(index=\"J\", columns=\"K\", values=\"display\")\n)\nwinners_grid.columns = [f\"K={k}\" for k in winners_grid.columns]\nwinners_grid.index = [f\"J={j}\" for j in winners_grid.index]\nwinners_grid\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>K=3</th>\n      <th>K=6</th>\n      <th>K=9</th>\n      <th>K=12</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>J=6</th>\n      <td>-1.18\\n(-2.65)</td>\n      <td>-0.68\\n(-1.51)</td>\n      <td>-0.55\\n(-1.23)</td>\n      <td>-0.39\\n(-0.87)</td>\n    </tr>\n    <tr>\n      <th>J=9</th>\n      <td>-1.00\\n(-2.36)</td>\n      <td>-0.51\\n(-1.22)</td>\n      <td>-0.28\\n(-0.68)</td>\n      <td>-0.16\\n(-0.39)</td>\n    </tr>\n    <tr>\n      <th>J=12</th>\n      <td>-0.88\\n(-2.09)</td>\n      <td>-0.39\\n(-0.91)</td>\n      <td>-0.24\\n(-0.56)</td>\n      <td>-0.14\\n(-0.34)</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Losers Portfolio Returns\n\n@tbl-losers-grid presents the corresponding results for the loser portfolio.\n\n::: {#tbl-losers-grid .cell tbl-cap='Average monthly returns (%) of the loser portfolio across formation periods (J) and holding periods (K). t-statistics are reported in parentheses.' execution_count=29}\n``` {.python .cell-code}\nlosers_grid = (results_df\n    .query(\"portfolio == 'losers'\")\n    .assign(\n        display=lambda x: (\n            x[\"mean_ret\"].apply(lambda v: f\"{v*100:.2f}\") + \n            \"\\n(\" + x[\"t_stat\"].apply(lambda v: f\"{v:.2f}\") + \")\"\n        )\n    )\n    .pivot(index=\"J\", columns=\"K\", values=\"display\")\n)\nlosers_grid.columns = [f\"K={k}\" for k in losers_grid.columns]\nlosers_grid.index = [f\"J={j}\" for j in losers_grid.index]\nlosers_grid\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>K=3</th>\n      <th>K=6</th>\n      <th>K=9</th>\n      <th>K=12</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>J=6</th>\n      <td>1.87\\n(3.49)</td>\n      <td>1.42\\n(2.76)</td>\n      <td>1.10\\n(2.19)</td>\n      <td>0.99\\n(1.99)</td>\n    </tr>\n    <tr>\n      <th>J=9</th>\n      <td>1.94\\n(3.51)</td>\n      <td>1.38\\n(2.56)</td>\n      <td>1.21\\n(2.31)</td>\n      <td>1.15\\n(2.22)</td>\n    </tr>\n    <tr>\n      <th>J=12</th>\n      <td>1.57\\n(2.71)</td>\n      <td>1.29\\n(2.28)</td>\n      <td>1.19\\n(2.13)</td>\n      <td>1.15\\n(2.09)</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Long-Short Momentum Returns\n\n@tbl-ls-grid presents the most important results: the average monthly returns of the long-short momentum portfolio across all specifications.\n\n::: {#tbl-ls-grid .cell tbl-cap='Average monthly returns (%) of the momentum long-short portfolio (Winners minus Losers) across formation periods (J) and holding periods (K). t-statistics are reported in parentheses. This table replicates the format of Table 1 in Jegadeesh and Titman (1993).' execution_count=30}\n``` {.python .cell-code}\nls_grid = (results_df\n    .query(\"portfolio == 'long_short'\")\n    .assign(\n        display=lambda x: (\n            x[\"mean_ret\"].apply(lambda v: f\"{v*100:.2f}\") + \n            \"\\n(\" + x[\"t_stat\"].apply(lambda v: f\"{v:.2f}\") + \")\"\n        )\n    )\n    .pivot(index=\"J\", columns=\"K\", values=\"display\")\n)\nls_grid.columns = [f\"K={k}\" for k in ls_grid.columns]\nls_grid.index = [f\"J={j}\" for j in ls_grid.index]\nls_grid\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>K=3</th>\n      <th>K=6</th>\n      <th>K=9</th>\n      <th>K=12</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>J=6</th>\n      <td>-3.04\\n(-7.38)</td>\n      <td>-2.10\\n(-5.44)</td>\n      <td>-1.65\\n(-4.94)</td>\n      <td>-1.37\\n(-4.61)</td>\n    </tr>\n    <tr>\n      <th>J=9</th>\n      <td>-2.94\\n(-6.41)</td>\n      <td>-1.89\\n(-4.55)</td>\n      <td>-1.49\\n(-3.98)</td>\n      <td>-1.31\\n(-3.87)</td>\n    </tr>\n    <tr>\n      <th>J=12</th>\n      <td>-2.45\\n(-5.42)</td>\n      <td>-1.68\\n(-3.92)</td>\n      <td>-1.43\\n(-3.60)</td>\n      <td>-1.30\\n(-3.55)</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Visualizing the Momentum Premium Across Specifications\n\n@fig-momentum-heatmap provides a visual summary of the long-short momentum premium across all $(J, K)$ combinations.\n\n::: {#cell-fig-momentum-heatmap .cell execution_count=31}\n``` {.python .cell-code}\nls_heatmap_data = (results_df\n    .query(\"portfolio == 'long_short'\")\n    .assign(\n        mean_pct=lambda x: x[\"mean_ret\"] * 100,\n        significant=lambda x: x[\"p_value\"] < 0.05,\n        label=lambda x: x.apply(\n            lambda row: f\"{row['mean_ret']*100:.2f}{'*' if row['p_value'] < 0.05 else ''}\", \n            axis=1\n        )\n    )\n)\n\nplot_heatmap = (\n    ggplot(ls_heatmap_data, \n           aes(x=\"K.astype(str)\", y=\"J.astype(str)\", fill=\"mean_pct\")) +\n    geom_tile(color=\"white\", size=2) +\n    geom_text(aes(label=\"label\"), size=10, color=\"white\") +\n    scale_fill_gradient2(\n        low=\"#d62728\", mid=\"#f7f7f7\", high=\"#1f77b4\", midpoint=0,\n        name=\"Monthly\\nReturn (%)\"\n    ) +\n    labs(\n        x=\"Holding Period (K months)\",\n        y=\"Formation Period (J months)\",\n        title=\"Momentum Premium Across J×K Specifications\"\n    ) +\n    theme_minimal() +\n    theme(figure_size=(8, 6))\n)\nplot_heatmap\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n![Heatmap of average monthly long-short momentum returns (%) across formation periods (J) and holding periods (K). Darker shades indicate higher momentum profits. Asterisks denote statistical significance at the 5% level.](13_momemtum_files/figure-html/fig-momentum-heatmap-output-1.png){#fig-momentum-heatmap width=768 height=576 fig-alt='A heatmap with formation period J on the y-axis and holding period K on the x-axis, with cell colors indicating the magnitude of the momentum premium.'}\n:::\n:::\n\n\n## Risk-Adjusted Performance\n\n### CAPM Alpha\n\nA natural question is whether the momentum premium is explained by exposure to the market factor. We estimate the CAPM alpha of the long-short momentum portfolio by regressing its returns on the market excess return:\n\n$$\nr_{\\text{WML},t} = \\alpha + \\beta \\cdot r_{\\text{MKT},t} + \\epsilon_t\n$$ {#eq-capm-alpha}\n\n::: {#bc178970 .cell execution_count=32}\n``` {.python .cell-code}\n# Merge momentum returns with factor data (baseline J=6, K=6)\newret_factors = (ewret_wide\n    [[\"date\", \"winners\", \"losers\", \"long_short\"]]\n    .merge(factors_ff3_monthly, on=\"date\", how=\"inner\")\n)\n\n# CAPM regression for long-short portfolio\nfrom statsmodels.formula.api import ols as ols_formula\nimport statsmodels.api as sm\n\nX_capm = sm.add_constant(ewret_factors[\"mkt_excess\"])\ny_ls = ewret_factors[\"long_short\"]\n\ncapm_model = sm.OLS(y_ls, X_capm).fit(cov_type=\"HAC\", cov_kwds={\"maxlags\": 6})\n\nprint(\"CAPM Regression: Long-Short Momentum Returns\")\nprint(\"=\" * 60)\nprint(f\"Alpha (monthly):  {capm_model.params['const']*100:.4f}% \"\n      f\"(t={capm_model.tvalues['const']:.2f})\")\nprint(f\"Market Beta:      {capm_model.params['mkt_excess']:.4f} \"\n      f\"(t={capm_model.tvalues['mkt_excess']:.2f})\")\nprint(f\"R-squared:        {capm_model.rsquared:.4f}\")\nprint(f\"N observations:   {capm_model.nobs:.0f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCAPM Regression: Long-Short Momentum Returns\n============================================================\nAlpha (monthly):  -2.2703% (t=-5.05)\nMarket Beta:      -0.1779 (t=-1.75)\nR-squared:        0.0470\nN observations:   150\n```\n:::\n:::\n\n\n### Fama-French Three-Factor Alpha\n\nWe extend the risk adjustment to the Fama-French three-factor model, which includes the size (SMB) and value (HML) factors in addition to the market factor:\n\n$$\nr_{\\text{WML},t} = \\alpha + \\beta_1 \\cdot r_{\\text{MKT},t} + \\beta_2 \\cdot \\text{SMB}_t + \\beta_3 \\cdot \\text{HML}_t + \\epsilon_t\n$$ {#eq-ff3-alpha}\n\n::: {#tbl-ff3-regression .cell tbl-cap='Fama-French three-factor regression for the momentum long-short portfolio. The dependent variable is the monthly return of the Winners-minus-Losers portfolio. Alpha is the intercept, representing the risk-adjusted abnormal return. HAC standard errors with 6 lags are used.' execution_count=33}\n``` {.python .cell-code}\nX_ff3 = sm.add_constant(\n    ewret_factors[[\"mkt_excess\", \"smb\", \"hml\"]]\n)\ny_ls = ewret_factors[\"long_short\"]\n\nff3_model = sm.OLS(y_ls, X_ff3).fit(cov_type=\"HAC\", cov_kwds={\"maxlags\": 6})\n\n# Display results as a clean table\nff3_results = pd.DataFrame({\n    \"Coefficient\": ff3_model.params,\n    \"Std Error\": ff3_model.bse,\n    \"t-stat\": ff3_model.tvalues,\n    \"p-value\": ff3_model.pvalues\n}).round(4)\n\nff3_results.index = [\"Alpha\", \"MKT\", \"SMB\", \"HML\"]\nff3_results\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Coefficient</th>\n      <th>Std Error</th>\n      <th>t-stat</th>\n      <th>p-value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Alpha</th>\n      <td>-0.0234</td>\n      <td>0.0041</td>\n      <td>-5.7189</td>\n      <td>0.0000</td>\n    </tr>\n    <tr>\n      <th>MKT</th>\n      <td>-0.1269</td>\n      <td>0.1558</td>\n      <td>-0.8145</td>\n      <td>0.4154</td>\n    </tr>\n    <tr>\n      <th>SMB</th>\n      <td>0.1123</td>\n      <td>0.1882</td>\n      <td>0.5969</td>\n      <td>0.5506</td>\n    </tr>\n    <tr>\n      <th>HML</th>\n      <td>0.0716</td>\n      <td>0.1414</td>\n      <td>0.5065</td>\n      <td>0.6125</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#518c6c35 .cell execution_count=34}\n``` {.python .cell-code}\nprint(f\"\\nR-squared: {ff3_model.rsquared:.4f}\")\nprint(f\"Adjusted R-squared: {ff3_model.rsquared_adj:.4f}\")\nprint(f\"Alpha (annualized): {ff3_model.params['const'] * 12 * 100:.2f}%\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nR-squared: 0.0553\nAdjusted R-squared: 0.0359\nAlpha (annualized): -28.02%\n```\n:::\n:::\n\n\n### Interpretation of Risk Exposures\n\nThe factor loadings from the three-factor regression reveal the risk characteristics of the momentum strategy in the Vietnamese market. Several patterns are commonly observed:\n\n1.  **Market beta**: Momentum portfolios typically have moderate market exposure. In the U.S., @grundy2001understanding document that the market beta of the long-short portfolio is close to zero on average but highly time-varying, spiking during market reversals.\n\n2.  **Size exposure (SMB)**: Momentum strategies often load positively on the size factor, reflecting the tendency for smaller stocks to exhibit stronger momentum patterns.\n\n3.  **Value exposure (HML)**: The long-short momentum portfolio typically loads negatively on HML, indicating that winners tend to be growth stocks while losers tend to be value stocks. This creates a natural tension between momentum and value strategies.\n\n## Momentum and Market States\n\n### Conditional Performance\n\nAn important finding in the momentum literature is that momentum profits vary with market conditions. @cooper2004market document that momentum strategies perform well following market gains (UP markets) but experience severe losses following market declines (DOWN markets). This asymmetry is particularly relevant for emerging markets, which experience more extreme market states.\n\nWe define market states based on the cumulative market return over the prior 12 months:\n\n$$\n\\text{Market State}_t = \\begin{cases} \\text{UP} & \\text{if } \\prod_{s=t-12}^{t-1}(1 + r_{m,s}) - 1 > 0 \\\\ \\text{DOWN} & \\text{otherwise} \\end{cases}\n$$ {#eq-market-state}\n\n::: {#b790fe9d .cell execution_count=35}\n``` {.python .cell-code}\n# Compute 12-month lagged market return\nmarket_returns = factors_ff3_monthly[[\"date\", \"mkt_excess\"]].copy()\nmarket_returns = market_returns.sort_values(\"date\")\nmarket_returns[\"mkt_cum_12m\"] = (\n    (1 + market_returns[\"mkt_excess\"])\n    .rolling(window=12, min_periods=12)\n    .apply(np.prod, raw=True)\n    - 1\n)\nmarket_returns[\"market_state\"] = np.where(\n    market_returns[\"mkt_cum_12m\"] > 0, \"UP\", \"DOWN\"\n)\n\n# Merge with momentum returns\newret_states = ewret_wide[[\"date\", \"long_short\"]].merge(\n    market_returns[[\"date\", \"market_state\"]], on=\"date\", how=\"inner\"\n).dropna()\n```\n:::\n\n\n::: {#tbl-market-states .cell tbl-cap='Momentum long-short returns conditional on market states. UP markets are defined as periods where the cumulative market return over the prior 12 months is positive; DOWN markets are periods with negative prior 12-month returns.' execution_count=36}\n``` {.python .cell-code}\nstate_stats = []\nfor state in [\"UP\", \"DOWN\"]:\n    subset = ewret_states.query(f\"market_state == '{state}'\")[\"long_short\"]\n    n = len(subset)\n    mean_ret = subset.mean()\n    std_ret = subset.std()\n    t_stat = mean_ret / (std_ret / np.sqrt(n)) if std_ret > 0 else np.nan\n    p_val = 2 * (1 - stats.t.cdf(abs(t_stat), df=n-1)) if not np.isnan(t_stat) else np.nan\n    state_stats.append({\n        \"Market State\": state,\n        \"N Months\": n,\n        \"Mean (%)\": mean_ret * 100,\n        \"Std (%)\": std_ret * 100,\n        \"t-stat\": t_stat,\n        \"p-value\": p_val\n    })\n\nstate_stats_df = pd.DataFrame(state_stats).round(4)\nstate_stats_df\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Market State</th>\n      <th>N Months</th>\n      <th>Mean (%)</th>\n      <th>Std (%)</th>\n      <th>t-stat</th>\n      <th>p-value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>UP</td>\n      <td>39</td>\n      <td>-1.1972</td>\n      <td>4.5814</td>\n      <td>-1.6320</td>\n      <td>0.1109</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>DOWN</td>\n      <td>111</td>\n      <td>-2.4050</td>\n      <td>4.8669</td>\n      <td>-5.2063</td>\n      <td>0.0000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#cell-fig-momentum-states .cell execution_count=37}\n``` {.python .cell-code}\nplot_states = (\n    ggplot(ewret_states, aes(x=\"market_state\", y=\"long_short\", \n                              fill=\"market_state\")) +\n    geom_boxplot(alpha=0.7) +\n    geom_hline(yintercept=0, linetype=\"dashed\", color=\"gray\") +\n    scale_y_continuous(labels=percent_format()) +\n    scale_fill_manual(values={\"UP\": \"#1f77b4\", \"DOWN\": \"#d62728\"}) +\n    labs(\n        x=\"Market State (Prior 12-Month Return)\",\n        y=\"Monthly Long-Short Return\",\n        title=\"Momentum Returns by Market State\"\n    ) +\n    theme_minimal() +\n    theme(\n        figure_size=(8, 6),\n        legend_position=\"none\"\n    )\n)\nplot_states\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n![Distribution of monthly momentum returns by market state. The box plots show the distribution of long-short momentum returns separately for UP and DOWN market states, defined by the sign of the prior 12-month cumulative market return.](13_momemtum_files/figure-html/fig-momentum-states-output-1.png){#fig-momentum-states width=768 height=576 fig-alt='Side-by-side box plots comparing the distribution of momentum returns in UP versus DOWN market states.'}\n:::\n:::\n\n\n## Momentum Crashes\n\n### Understanding Momentum Drawdowns\n\nOne of the most important risk characteristics of momentum strategies is their susceptibility to sudden, severe losses—known as momentum crashes. @daniel2016momentum document that momentum strategies experience infrequent but extreme losses, typically during market rebounds following bear markets. These crashes occur because the loser portfolio, which has been short, is heavily loaded with high-beta stocks that surge when markets reverse.\n\nWe identify the worst drawdowns of the momentum strategy and examine their market context.\n\n::: {#tbl-worst-months .cell tbl-cap='Ten worst months for the momentum long-short strategy. The table reports the date, long-short return, winner return, loser return, and concurrent market return for the ten months with the largest momentum losses.' execution_count=38}\n``` {.python .cell-code}\nworst_months = (ewret_wide\n    [[\"date\", \"long_short\", \"winners\", \"losers\"]]\n    .merge(factors_ff3_monthly[[\"date\", \"mkt_excess\"]], on=\"date\", how=\"left\")\n    .sort_values(\"long_short\")\n    .head(10)\n    .assign(\n        long_short_pct=lambda x: (x[\"long_short\"] * 100).round(2),\n        winners_pct=lambda x: (x[\"winners\"] * 100).round(2),\n        losers_pct=lambda x: (x[\"losers\"] * 100).round(2),\n        mkt_pct=lambda x: (x[\"mkt_excess\"] * 100).round(2)\n    )\n    [[\"date\", \"long_short_pct\", \"winners_pct\", \"losers_pct\", \"mkt_pct\"]]\n    .rename(columns={\n        \"date\": \"Date\",\n        \"long_short_pct\": \"L/S (%)\",\n        \"winners_pct\": \"Winners (%)\",\n        \"losers_pct\": \"Losers (%)\",\n        \"mkt_pct\": \"Market (%)\"\n    })\n)\nworst_months\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Date</th>\n      <th>L/S (%)</th>\n      <th>Winners (%)</th>\n      <th>Losers (%)</th>\n      <th>Market (%)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>153</th>\n      <td>2023-05-31</td>\n      <td>-16.39</td>\n      <td>-2.69</td>\n      <td>13.70</td>\n      <td>2.78</td>\n    </tr>\n    <tr>\n      <th>39</th>\n      <td>2013-11-30</td>\n      <td>-14.26</td>\n      <td>4.24</td>\n      <td>18.50</td>\n      <td>2.57</td>\n    </tr>\n    <tr>\n      <th>20</th>\n      <td>2012-04-30</td>\n      <td>-13.68</td>\n      <td>1.51</td>\n      <td>15.19</td>\n      <td>4.88</td>\n    </tr>\n    <tr>\n      <th>78</th>\n      <td>2017-02-28</td>\n      <td>-13.56</td>\n      <td>2.10</td>\n      <td>15.67</td>\n      <td>1.49</td>\n    </tr>\n    <tr>\n      <th>107</th>\n      <td>2019-07-31</td>\n      <td>-13.15</td>\n      <td>-2.46</td>\n      <td>10.69</td>\n      <td>1.61</td>\n    </tr>\n    <tr>\n      <th>140</th>\n      <td>2022-04-30</td>\n      <td>-11.71</td>\n      <td>-17.57</td>\n      <td>-5.87</td>\n      <td>-11.19</td>\n    </tr>\n    <tr>\n      <th>149</th>\n      <td>2023-01-31</td>\n      <td>-11.53</td>\n      <td>1.37</td>\n      <td>12.90</td>\n      <td>6.96</td>\n    </tr>\n    <tr>\n      <th>28</th>\n      <td>2012-12-31</td>\n      <td>-11.52</td>\n      <td>4.03</td>\n      <td>15.54</td>\n      <td>-1.61</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>2010-08-31</td>\n      <td>-11.31</td>\n      <td>-25.03</td>\n      <td>-13.72</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>10</th>\n      <td>2011-06-30</td>\n      <td>-10.44</td>\n      <td>-3.15</td>\n      <td>7.29</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Maximum Drawdown Analysis\n\nThe maximum drawdown provides a measure of the worst peak-to-trough decline experienced by the strategy. This metric is particularly relevant for practitioners evaluating the risk of momentum strategies.\n\n::: {#836f4d0b .cell execution_count=39}\n``` {.python .cell-code}\n# Compute running maximum and drawdown\newret_wide[\"cum_wealth\"] = (1 + ewret_wide[\"long_short\"]).cumprod()\newret_wide[\"running_max\"] = ewret_wide[\"cum_wealth\"].cummax()\newret_wide[\"drawdown\"] = (\n    ewret_wide[\"cum_wealth\"] / ewret_wide[\"running_max\"] - 1\n)\n\nmax_dd = ewret_wide[\"drawdown\"].min()\nmax_dd_date = ewret_wide.loc[ewret_wide[\"drawdown\"].idxmin(), \"date\"]\n\nprint(f\"Maximum drawdown: {max_dd*100:.2f}%\")\nprint(f\"Date of maximum drawdown: {max_dd_date.date()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaximum drawdown: -97.08%\nDate of maximum drawdown: 2023-10-31\n```\n:::\n:::\n\n\n::: {#cell-fig-drawdown .cell execution_count=40}\n``` {.python .cell-code}\nplot_dd = (\n    ggplot(ewret_wide, aes(x=\"date\", y=\"drawdown\")) +\n    geom_area(fill=\"#d62728\", alpha=0.5) +\n    geom_line(color=\"#d62728\", size=0.5) +\n    scale_y_continuous(labels=percent_format()) +\n    labs(\n        x=\"\", y=\"Drawdown\",\n        title=\"Momentum Strategy Drawdown\"\n    ) +\n    theme_minimal() +\n    theme(figure_size=(10, 5))\n)\nplot_dd\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n![Drawdown of the momentum long-short strategy over time. The chart shows the percentage decline from the previous peak in cumulative wealth. Deeper drawdowns represent more severe momentum crashes.](13_momemtum_files/figure-html/fig-drawdown-output-1.png){#fig-drawdown width=960 height=480 fig-alt='A time series chart showing the drawdown of the momentum strategy, with several deep troughs corresponding to momentum crash episodes.'}\n:::\n:::\n\n\n## Value-Weighted Momentum Portfolios\n\nThe baseline @jegadeesh1993returns implementation uses equally weighted portfolios. However, equally weighted returns can be dominated by small, illiquid stocks that may be difficult to trade in practice. Value-weighted portfolios, where each stock's contribution is proportional to its market capitalization, provide a more investable benchmark and are more representative of the returns that large investors could actually achieve.\n\n::: {#b12140dc .cell execution_count=41}\n``` {.python .cell-code}\ndef momentum_strategy_vw(data, J, K, n_portfolios=10):\n    \"\"\"\n    Value-weighted momentum strategy implementation.\n    \n    Same as the equally-weighted version but uses lagged market \n    capitalization as weights when computing portfolio returns.\n    \n    Parameters\n    ----------\n    data : pd.DataFrame\n        Panel with columns: symbol, date, ret, mktcap_lag.\n    J : int\n        Formation period in months.\n    K : int\n        Holding period in months.\n    n_portfolios : int\n        Number of portfolios.\n    \n    Returns\n    -------\n    pd.DataFrame\n        Monthly value-weighted portfolio returns.\n    \"\"\"\n    # Step 1: Formation period returns\n    df = data.sort_values([\"symbol\", \"date\"]).copy()\n    df[\"gross_ret\"] = 1 + df[\"ret\"]\n    df[\"cum_return\"] = (\n        df.groupby(\"symbol\")[\"gross_ret\"]\n        .rolling(window=J, min_periods=J)\n        .apply(np.prod, raw=True)\n        .reset_index(level=0, drop=True)\n        - 1\n    )\n    df = df.drop(columns=[\"gross_ret\"]).dropna(subset=[\"cum_return\"])\n    \n    # Step 2: Portfolio assignment using transform (fast)\n    df[\"momr\"] = df.groupby(\"date\", observed=True)[\"cum_return\"].transform(\n        lambda x: pd.qcut(\n            x,\n            q=n_portfolios,\n            labels=range(1, n_portfolios + 1),\n            duplicates=\"drop\"\n        )\n    ).astype('Int64')\n    \n    # Fill NaNs with rank-based assignment\n    mask = df[\"momr\"].isna()\n    if mask.any():\n        df.loc[mask, \"momr\"] = df.loc[mask].groupby(\"date\")[\"cum_return\"].transform(\n            lambda x: pd.qcut(\n                x.rank(method=\"first\"),\n                q=min(n_portfolios, len(x.unique())),\n                labels=False,\n                duplicates=\"drop\"\n            )\n        ).astype('Int64') + 1\n    \n    # Step 3: Holding period\n    df = df.rename(columns={\"date\": \"form_date\"})\n    df[\"hdate1\"] = df[\"form_date\"] + pd.offsets.MonthBegin(1)\n    df[\"hdate2\"] = df[\"form_date\"] + pd.offsets.MonthEnd(K)\n    \n    # Step 4: Merge with holding period returns AND weights\n    port_ret = df[\n        [\"symbol\", \"form_date\", \"momr\", \"hdate1\", \"hdate2\"]\n    ].merge(\n        data[[\"symbol\", \"date\", \"ret\", \"mktcap_lag\"]].rename(\n            columns={\"ret\": \"hret\", \"date\": \"hdate\"}\n        ),\n        on=\"symbol\",\n        how=\"inner\"\n    )\n    \n    # Use boolean indexing instead of query (faster)\n    port_ret = port_ret[\n        (port_ret[\"hdate\"] >= port_ret[\"hdate1\"]) & \n        (port_ret[\"hdate\"] <= port_ret[\"hdate2\"])\n    ]\n    port_ret = port_ret.dropna(subset=[\"mktcap_lag\"])\n    port_ret = port_ret[port_ret[\"mktcap_lag\"] > 0]\n    \n    # Step 5: Value-weighted returns within each cohort\n    def vw_mean(group):\n        weights = group[\"mktcap_lag\"]\n        if weights.sum() == 0:\n            return np.nan\n        return np.average(group[\"hret\"], weights=weights)\n    \n    cohort_ret = (port_ret\n        .groupby([\"hdate\", \"momr\", \"form_date\"])\n        .apply(vw_mean, include_groups=False)\n        .reset_index(name=\"cohort_ret\")\n    )\n    \n    monthly_ret = (cohort_ret\n        .groupby([\"hdate\", \"momr\"])\n        .agg(vwret=(\"cohort_ret\", \"mean\"))\n        .reset_index()\n        .rename(columns={\"hdate\": \"date\"})\n    )\n    \n    # Step 6: Long-short\n    wide = monthly_ret.pivot(\n        index=\"date\", columns=\"momr\", values=\"vwret\"\n    ).reset_index()\n    \n    # Handle variable number of portfolios\n    n_cols = len(wide.columns) - 1\n    wide.columns = [\"date\"] + [f\"port{i}\" for i in range(1, n_cols + 1)]\n    wide[\"winners\"] = wide[f\"port{n_cols}\"]\n    wide[\"losers\"] = wide[\"port1\"]\n    wide[\"long_short\"] = wide[\"winners\"] - wide[\"losers\"]\n    \n    return monthly_ret, wide\n```\n:::\n\n\n::: {#c629974a .cell execution_count=42}\n``` {.python .cell-code}\n# Run value-weighted J=6, K=6 strategy\n_, vw_results = momentum_strategy_vw(prices_clean, J=6, K=6)\n\nprint(\"Value-Weighted Momentum Strategy (J=6, K=6)\")\nprint(\"=\" * 50)\nprint(\"\\nPortfolio Statistics:\")\nprint(vw_results[[\"winners\", \"losers\", \"long_short\"]].describe().round(4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValue-Weighted Momentum Strategy (J=6, K=6)\n==================================================\n\nPortfolio Statistics:\n        winners    losers  long_short\ncount  161.0000  161.0000    161.0000\nmean    -0.0129    0.0006     -0.0135\nstd      0.0763    0.0713      0.0653\nmin     -0.2519   -0.2178     -0.3813\n25%     -0.0540   -0.0397     -0.0465\n50%     -0.0067    0.0010     -0.0126\n75%      0.0354    0.0443      0.0173\nmax      0.1765    0.2498      0.2498\n```\n:::\n:::\n\n\n::: {#tbl-ew-vs-vw .cell tbl-cap='Comparison of equally weighted (EW) and value-weighted (VW) momentum strategies for J=6, K=6. The table reports mean monthly returns, t-statistics, and p-values for winners, losers, and long-short portfolios under both weighting schemes.' execution_count=43}\n``` {.python .cell-code}\ncomparison = []\nfor scheme, df in [(\"EW\", ewret_wide), (\"VW\", vw_results)]:\n    for col in [\"winners\", \"losers\", \"long_short\"]:\n        series = df[col].dropna()\n        n = len(series)\n        mean_ret = series.mean()\n        std_ret = series.std()\n        t_stat = mean_ret / (std_ret / np.sqrt(n))\n        p_val = 2 * (1 - stats.t.cdf(abs(t_stat), df=n-1))\n        comparison.append({\n            \"Weighting\": scheme,\n            \"Portfolio\": col.replace(\"_\", \" \").title(),\n            \"Mean (%)\": round(mean_ret * 100, 4),\n            \"Std (%)\": round(std_ret * 100, 4),\n            \"t-stat\": round(t_stat, 2),\n            \"p-value\": round(p_val, 4)\n        })\n\npd.DataFrame(comparison)\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Weighting</th>\n      <th>Portfolio</th>\n      <th>Mean (%)</th>\n      <th>Std (%)</th>\n      <th>t-stat</th>\n      <th>p-value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>EW</td>\n      <td>Winners</td>\n      <td>-0.6812</td>\n      <td>5.7131</td>\n      <td>-1.51</td>\n      <td>0.1323</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>EW</td>\n      <td>Losers</td>\n      <td>1.4190</td>\n      <td>6.5319</td>\n      <td>2.76</td>\n      <td>0.0065</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>EW</td>\n      <td>Long Short</td>\n      <td>-2.1002</td>\n      <td>4.8969</td>\n      <td>-5.44</td>\n      <td>0.0000</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>VW</td>\n      <td>Winners</td>\n      <td>-1.2943</td>\n      <td>7.6274</td>\n      <td>-2.15</td>\n      <td>0.0328</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>VW</td>\n      <td>Losers</td>\n      <td>0.0589</td>\n      <td>7.1275</td>\n      <td>0.10</td>\n      <td>0.9166</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>VW</td>\n      <td>Long Short</td>\n      <td>-1.3533</td>\n      <td>6.5312</td>\n      <td>-2.63</td>\n      <td>0.0094</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#cell-fig-ew-vs-vw .cell execution_count=44}\n``` {.python .cell-code}\nvw_results = vw_results.sort_values(\"date\")\nvw_results[\"cumret_ls_vw\"] = (1 + vw_results[\"long_short\"]).cumprod() - 1\n\new_data = (ewret_wide[[\"date\", \"long_short\"]]\n    .rename(columns={\"long_short\": \"cumret\"})\n    .assign(scheme=\"Equally Weighted\")\n)\new_data[\"cumret\"] = (1 + ew_data[\"cumret\"]).cumprod() - 1\n\nvw_data = (vw_results[[\"date\", \"cumret_ls_vw\"]]\n    .rename(columns={\"cumret_ls_vw\": \"cumret\"})\n    .assign(scheme=\"Value Weighted\")\n)\n\new_vs_vw = pd.concat([ew_data, vw_data], ignore_index=True)\n\nplot_ew_vw = (\n    ggplot(ew_vs_vw, aes(x=\"date\", y=\"cumret\", color=\"scheme\")) +\n    geom_line(size=1) +\n    scale_y_continuous(labels=percent_format()) +\n    scale_color_manual(values=[\"#1f77b4\", \"#ff7f0e\"]) +\n    labs(\n        x=\"\", y=\"Cumulative return\",\n        color=\"Weighting Scheme\",\n        title=\"EW vs. VW Momentum Long-Short Strategy\"\n    ) +\n    theme_minimal() +\n    theme(\n        figure_size=(10, 6),\n        legend_position=\"bottom\"\n    )\n)\nplot_ew_vw\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n![Cumulative returns of equally weighted (EW) versus value-weighted (VW) long-short momentum strategies. Differences between the two lines reflect the impact of firm size on momentum profitability.](13_momemtum_files/figure-html/fig-ew-vs-vw-output-1.png){#fig-ew-vs-vw width=960 height=576 fig-alt='A line chart comparing the cumulative returns of EW and VW momentum long-short strategies over time.'}\n:::\n:::\n\n\n## Daily Momentum Analysis\n\nWhile momentum strategies are typically evaluated at the monthly frequency following @jegadeesh1993returns, analyzing daily return patterns provides additional insights into the dynamics of momentum profits. Daily data allows us to examine how momentum profits accrue within the holding period, measure intra-month volatility of the strategy, and compute more precise risk measures.\n\n### Loading Daily Data\n\n::: {#7daf309e .cell execution_count=45}\n``` {.python .cell-code}\nprices_daily = pd.read_sql_query(\n    sql=(\"SELECT symbol, date, ret, ret_excess, mktcap_lag \"\n         \"FROM prices_daily\"),\n    con=tidy_finance,\n    parse_dates={\"date\"}\n)\n\nprint(f\"Daily observations: {len(prices_daily):,}\")\nprint(f\"Unique stocks: {prices_daily['symbol'].nunique():,}\")\nprint(f\"Date range: {prices_daily['date'].min().date()} \"\n      f\"to {prices_daily['date'].max().date()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDaily observations: 3,462,157\nUnique stocks: 1,459\nDate range: 2010-01-05 to 2023-12-29\n```\n:::\n:::\n\n\n### Daily Returns of Monthly Momentum Portfolios\n\nRather than forming momentum portfolios at the daily frequency (which would require daily rebalancing and is impractical), we use the monthly portfolio assignments and track their daily returns. This gives us the daily return series of the monthly momentum strategy.\n\n::: {#e62d3271 .cell execution_count=46}\n``` {.python .cell-code}\n# # # Use the monthly portfolio assignments from the J=6 baseline\nmonthly_assignments = portfolios_with_dates[\n    [\"symbol\", \"form_date\", \"momr\", \"hdate1\", \"hdate2\"]\n].copy()\n\n# Merge with daily returns\ndaily_mom_returns = monthly_assignments.merge(\n    prices_daily[[\"symbol\", \"date\", \"ret\"]].rename(\n        columns={\"ret\": \"dret\", \"date\": \"ddate\"}\n    ),\n    on=\"symbol\",\n    how=\"inner\"\n)\n\n# Use boolean indexing instead of query\ndaily_mom_returns = daily_mom_returns[\n    (daily_mom_returns[\"ddate\"] >= daily_mom_returns[\"hdate1\"]) & \n    (daily_mom_returns[\"ddate\"] <= daily_mom_returns[\"hdate2\"])\n]\n\nprint(f\"Daily portfolio return observations: {len(daily_mom_returns):,}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDaily portfolio return observations: 19,112,536\n```\n:::\n:::\n\n\n::: {#4364c55b .cell execution_count=47}\n``` {.python .cell-code}\n# Compute daily equally weighted portfolio returns\n# Stage 1: Average within each cohort\ndaily_cohort_ret = (daily_mom_returns\n    .groupby([\"ddate\", \"momr\", \"form_date\"])\n    .agg(cohort_ret=(\"dret\", \"mean\"))\n    .reset_index()\n)\n\n# Stage 2: Average across cohorts\ndaily_ewret = (daily_cohort_ret\n    .groupby([\"ddate\", \"momr\"])\n    .agg(ewret=(\"cohort_ret\", \"mean\"))\n    .reset_index()\n    .rename(columns={\"ddate\": \"date\"})\n)\n\n# Compute daily long-short returns\ndaily_wide = daily_ewret.pivot(\n    index=\"date\", columns=\"momr\", values=\"ewret\"\n).reset_index()\ndaily_wide.columns = [\"date\"] + [f\"port{i}\" for i in range(1, 11)]\ndaily_wide[\"winners\"] = daily_wide[\"port10\"]\ndaily_wide[\"losers\"] = daily_wide[\"port1\"]\ndaily_wide[\"long_short\"] = daily_wide[\"winners\"] - daily_wide[\"losers\"]\n\nprint(f\"Daily long-short return observations: {len(daily_wide):,}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDaily long-short return observations: 3,352\n```\n:::\n:::\n\n\n### Daily Cumulative Returns\n\n::: {#cell-fig-daily-cumret .cell execution_count=48}\n``` {.python .cell-code}\ndaily_wide = daily_wide.sort_values(\"date\")\ndaily_wide[\"cumret_ls\"] = (1 + daily_wide[\"long_short\"]).cumprod() - 1\n\nplot_daily_cumret = (\n    ggplot(daily_wide, aes(x=\"date\", y=\"cumret_ls\")) +\n    geom_line(size=0.5, color=\"#2ca02c\") +\n    geom_hline(yintercept=0, linetype=\"dashed\", color=\"gray\") +\n    scale_y_continuous(labels=percent_format()) +\n    labs(\n        x=\"\", y=\"Cumulative return\",\n        title=\"Daily Cumulative Return: Momentum Long-Short Strategy\"\n    ) +\n    theme_minimal() +\n    theme(figure_size=(10, 6))\n)\nplot_daily_cumret\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n![Cumulative daily returns of the momentum long-short strategy. This figure shows the same strategy as the monthly analysis but tracked at daily frequency, revealing intra-month dynamics and the precise timing of momentum gains and losses.](13_momemtum_files/figure-html/fig-daily-cumret-output-1.png){#fig-daily-cumret width=960 height=576 fig-alt='A line chart showing the cumulative daily returns of the momentum long-short strategy, with finer granularity than the monthly version.'}\n:::\n:::\n\n\n### Annualized Risk Metrics from Daily Data\n\nDaily data enables more precise estimation of risk metrics through higher-frequency sampling.\n\n::: {#tbl-daily-risk .cell tbl-cap='Annualized risk metrics for the momentum long-short strategy computed from daily returns. Volatility is annualized using the square root of 252 rule. The Sharpe ratio, maximum drawdown, skewness, and kurtosis provide a comprehensive risk profile.' execution_count=49}\n``` {.python .cell-code}\ndaily_ls = daily_wide[\"long_short\"].dropna()\n\n# Annualized metrics\nann_mean = daily_ls.mean() * 252\nann_vol = daily_ls.std() * np.sqrt(252)\nsharpe = ann_mean / ann_vol if ann_vol > 0 else np.nan\n\n# Drawdown\ndaily_wealth = (1 + daily_ls).cumprod()\ndaily_running_max = daily_wealth.cummax()\ndaily_dd = (daily_wealth / daily_running_max - 1).min()\n\n# Higher moments\nskew = daily_ls.skew()\nkurt = daily_ls.kurtosis()\n\n# VaR and CVaR\nvar_95 = daily_ls.quantile(0.05)\ncvar_95 = daily_ls[daily_ls <= var_95].mean()\n\nrisk_metrics = pd.DataFrame({\n    \"Metric\": [\n        \"Annualized Mean Return\",\n        \"Annualized Volatility\", \n        \"Sharpe Ratio\",\n        \"Maximum Drawdown\",\n        \"Skewness\",\n        \"Excess Kurtosis\",\n        \"Daily VaR (5%)\",\n        \"Daily CVaR (5%)\"\n    ],\n    \"Value\": [\n        f\"{ann_mean*100:.2f}%\",\n        f\"{ann_vol*100:.2f}%\",\n        f\"{sharpe:.2f}\",\n        f\"{daily_dd*100:.2f}%\",\n        f\"{skew:.2f}\",\n        f\"{kurt:.2f}\",\n        f\"{var_95*100:.2f}%\",\n        f\"{cvar_95*100:.2f}%\"\n    ]\n})\nrisk_metrics\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Metric</th>\n      <th>Value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Annualized Mean Return</td>\n      <td>-26.90%</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Annualized Volatility</td>\n      <td>15.01%</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Sharpe Ratio</td>\n      <td>-1.79</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Maximum Drawdown</td>\n      <td>-97.62%</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Skewness</td>\n      <td>-11.23</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>Excess Kurtosis</td>\n      <td>378.11</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>Daily VaR (5%)</td>\n      <td>-1.33%</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>Daily CVaR (5%)</td>\n      <td>-2.10%</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Realized Volatility of Momentum Returns\n\nUsing daily returns, we can compute the monthly realized volatility of the momentum strategy and examine how it varies over time.\n\n::: {#cell-fig-realized-vol .cell execution_count=50}\n``` {.python .cell-code}\ndaily_wide[\"year_month\"] = daily_wide[\"date\"].dt.to_period(\"M\")\n\nrealized_vol = (daily_wide\n    .groupby(\"year_month\")[\"long_short\"]\n    .std()\n    .reset_index()\n    .rename(columns={\"long_short\": \"realized_vol\"})\n)\nrealized_vol[\"date\"] = realized_vol[\"year_month\"].dt.to_timestamp()\nrealized_vol[\"realized_vol_ann\"] = realized_vol[\"realized_vol\"] * np.sqrt(252)\n\nplot_rvol = (\n    ggplot(realized_vol, aes(x=\"date\", y=\"realized_vol_ann\")) +\n    geom_line(color=\"#d62728\", size=0.8) +\n    scale_y_continuous(labels=percent_format()) +\n    labs(\n        x=\"\", y=\"Annualized Realized Volatility\",\n        title=\"Realized Volatility of Momentum Strategy\"\n    ) +\n    theme_minimal() +\n    theme(figure_size=(10, 5))\n)\nplot_rvol\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n![Monthly realized volatility of the momentum long-short strategy, computed from daily returns within each month. Higher values indicate periods of greater uncertainty in momentum profits, often coinciding with market stress.](13_momemtum_files/figure-html/fig-realized-vol-output-1.png){#fig-realized-vol width=960 height=480 fig-alt='A time series chart of monthly realized volatility, showing spikes during periods of market stress.'}\n:::\n:::\n\n\n## Saving Results to the Database\n\nWe save the momentum portfolio returns to our database for use in subsequent chapters, including factor model construction and portfolio optimization.\n\n::: {#c6fd892b .cell execution_count=51}\n``` {.python .cell-code}\n# Save monthly equally weighted momentum portfolio returns\newret_to_save = ewret[[\"date\", \"momr\", \"ewret\"]].copy()\newret_to_save.to_sql(\n    name=\"momentum_portfolios_monthly\",\n    con=tidy_finance,\n    if_exists=\"replace\",\n    index=False\n)\nprint(f\"Saved {len(ewret_to_save):,} monthly momentum portfolio observations.\")\n\n# Save the long-short return series\nmomentum_factor = ewret_wide[[\"date\", \"long_short\"]].dropna().copy()\nmomentum_factor = momentum_factor.rename(columns={\"long_short\": \"wml\"})\nmomentum_factor.to_sql(\n    name=\"momentum_factor_monthly\",\n    con=tidy_finance,\n    if_exists=\"replace\",\n    index=False\n)\nprint(f\"Saved {len(momentum_factor):,} monthly WML factor observations.\")\n\n# Save the daily long-short return series\ndaily_momentum_factor = daily_wide[[\"date\", \"long_short\"]].dropna().copy()\ndaily_momentum_factor = daily_momentum_factor.rename(\n    columns={\"long_short\": \"wml\"}\n)\ndaily_momentum_factor.to_sql(\n    name=\"momentum_factor_daily\",\n    con=tidy_finance,\n    if_exists=\"replace\",\n    index=False\n)\nprint(f\"Saved {len(daily_momentum_factor):,} daily WML factor observations.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSaved 1,610 monthly momentum portfolio observations.\nSaved 161 monthly WML factor observations.\nSaved 3,352 daily WML factor observations.\n```\n:::\n:::\n\n\n## Practical Considerations\n\n### Transaction Costs\n\nMomentum strategies involve substantial portfolio turnover, as stocks enter and exit the extreme decile portfolios each month. @korajczyk2004momentum examine whether momentum profits survive transaction costs and find that profitability declines significantly for large institutional investors, though smaller portfolios can still capture meaningful returns.\n\nIn the Vietnamese market, transaction costs include:\n\n-   **Brokerage commissions**: Typically 0.15%–0.25% of transaction value for institutional investors.\n-   **Exchange fees**: Approximately 0.03% per trade.\n-   **Market impact**: Particularly relevant for smaller, less liquid stocks that dominate the extreme momentum portfolios. Vietnam's lower liquidity compared to developed markets may amplify this cost.\n-   **Trading band limits**: The $\\pm 7\\%$ daily price limit on HOSE can prevent immediate execution of trades, introducing tracking error relative to the theoretical portfolio.\n\n### Implementation Lag\n\nOur baseline implementation assumes that portfolios can be formed and rebalanced instantaneously at the end of each month. In practice, there is a lag between observing the formation period returns and executing the portfolio trades. The one-month gap between the formation period and the start of the holding period (@jegadeesh1990evidence) partially addresses this concern, but practitioners should consider additional implementation delays.\n\n### Survivorship Bias\n\nOur dataset from DataCore includes both active and delisted stocks, which mitigates survivorship bias. However, the treatment of delisted stocks can affect momentum results. Stocks that are delisted during the holding period may generate extreme returns (both positive for acquisitions and negative for failures). We retain delisted returns as reported in the database, which is consistent with the treatment in @jegadeesh1993returns.\n\n### Small Sample Considerations\n\nThe Vietnamese stock market has a relatively short history compared to the U.S. market studied in @jegadeesh1993returns. Our sample spans approximately two decades, compared to the nearly three decades in the original study. This shorter sample period implies wider confidence intervals and greater sensitivity to specific episodes (such as the 2007–2009 financial crisis, which had a severe impact on Vietnamese equities). Results should be interpreted with this caveat in mind.\n\n## Key Takeaways\n\nThis chapter has provided an implementation and analysis of momentum strategies in the Vietnamese equity market, following the methodology of @jegadeesh1993returns. The main findings and methodological contributions are:\n\n1.  **Methodology**: We implemented the full @jegadeesh1993returns overlapping portfolio methodology, including the two-stage averaging procedure (within-cohort, then across-cohort) that handles the $K$ active portfolios in each month.\n\n2.  **Baseline results**: The $J=6$, $K=6$ strategy provides a natural benchmark. The spread between winner and loser portfolios reveals whether cross-sectional momentum exists in Vietnamese equities.\n\n3.  **Robustness across horizons**: By computing the full $J \\times K$ grid with $J, K \\in \\{3, 6, 9, 12\\}$, we assessed whether the momentum premium is robust to the choice of formation and holding periods, following the approach in @jegadeesh1993returns Table 1.\n\n4.  **Risk adjustment**: CAPM and Fama-French three-factor alphas measure whether the momentum premium is explained by standard risk factors, building on the analysis in @fama1996multifactor who show that their three-factor model fails to explain momentum.\n\n5.  **Market state dependence**: Following @cooper2004market, we examined whether momentum profits vary with market conditions, which is particularly relevant in emerging markets with pronounced boom-bust cycles.\n\n6.  **Value weighting**: The comparison of equally weighted and value-weighted strategies addresses practical implementability and isolates the role of firm size in driving momentum profits.\n\n7.  **Daily analysis**: By tracking momentum portfolios at the daily frequency, we computed precise risk metrics including realized volatility, maximum drawdown, VaR, and CVaR, providing a complete risk profile of the strategy.\n\n8.  **Emerging market context**: Throughout the analysis, we have highlighted features specific to the Vietnamese market—trading band limits, foreign ownership restrictions, shorter sample history, and higher transaction costs—that affect the interpretation and practical viability of momentum strategies.\n\n```{=html}\n<!-- ## Exercises\n\n1.  **Skip-month momentum**: Modify the implementation to skip one month between the formation and holding periods (i.e., form portfolios based on months $t-J-1$ through $t-2$ rather than $t-J$ through $t-1$). Does this improve momentum profits by avoiding short-term reversal? Compare with the results in @jegadeesh1993returns.\n\n2.  **Quintile portfolios**: Repeat the analysis using quintile (5-group) portfolios instead of deciles. How do the results change? In the Vietnamese market with fewer stocks, quintiles may produce more stable portfolios.\n\n3.  **Exchange-specific momentum**: Separately analyze momentum on HOSE and HNX. Do the two exchanges exhibit different momentum patterns, potentially due to differences in liquidity, firm size, and investor composition?\n\n4.  **Industry momentum**: Following @moskowitz1999industries, decompose stock-level momentum into an industry component and a stock-specific component. Assign each stock the equally weighted return of its industry group as the industry momentum signal. Is momentum in Vietnam primarily driven by industry rotation or stock selection?\n\n5.  **Momentum and volume**: @lee2000price document an interaction between momentum and trading volume. Construct double-sorted portfolios based on past returns and past trading volume. Do high-volume winners outperform low-volume winners?\n\n6.  **Seasonal patterns**: Examine whether momentum profits exhibit seasonal patterns. In the U.S., @jegadeesh1993returns document that January returns of momentum portfolios are particularly unusual. Does a similar pattern exist in the Vietnamese market, potentially around the Lunar New Year (Tết)?\n\n7.  **Carhart four-factor model**: Using the WML factor saved to the database in this chapter, estimate the @carhart1997persistence four-factor model for the momentum portfolios. This adds the momentum factor to the Fama-French three-factor model: $r_{i,t} - r_{f,t} = \\alpha_i + \\beta_{1,i} \\text{MKT}_t + \\beta_{2,i} \\text{SMB}_t + \\beta_{3,i} \\text{HML}_t + \\beta_{4,i} \\text{WML}_t + \\epsilon_{i,t}$. -->\n```\n\n",
    "supporting": [
      "13_momemtum_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}