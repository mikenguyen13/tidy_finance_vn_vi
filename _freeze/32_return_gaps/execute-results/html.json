{
  "hash": "05ea96260a551b55b1c91732080be76d",
  "result": {
    "engine": "jupyter",
    "markdown": "# Return Gap: Measuring Unobserved Actions of Fund Managers\n\nMutual fund managers possess considerable discretion in their investment decisions between mandatory portfolio disclosure dates. While regulatory frameworks require periodic disclosure of holdings, the actions taken between these disclosure dates (e.g., trading, market timing, securities lending, and strategic cash management) remain largely unobservable to investors. These *unobserved actions* can significantly affect fund performance, either positively through skilled interim trading or negatively through agency costs and hidden behavior.\n\n@kacperczyk2008unobserved developed the **Return Gap** measure to capture the aggregate impact of these unobserved actions on fund returns. The Return Gap is defined as the difference between a fund's actual reported return and the hypothetical return of a portfolio that mechanically invests in the fund's most recently disclosed holdings. Formally:\n\n$$\n\\text{Return Gap}_{i,t} = R_{i,t}^{\\text{Actual}} - R_{i,t}^{\\text{Holdings}}\n$$ {#eq-return-gap-basic}\n\nwhere $R_{i,t}^{\\text{Actual}}$ is the net-of-expense return reported by fund $i$ in month $t$, adjusted for expenses to obtain the gross return, and $R_{i,t}^{\\text{Holdings}}$ is the hypothetical buy-and-hold return computed from the most recently disclosed portfolio holdings.\n\nA positive Return Gap indicates that the fund manager's unobserved actions (e.g., interim trading, cash management, or other activities) added value beyond what a passive replication of disclosed holdings would have generated. Conversely, a persistently negative Return Gap suggests value-destroying interim activity, potentially driven by agency costs, poor trading execution, or hidden fees.\n\n## Why Return Gap Matters\n\nThe Return Gap is economically significant for several reasons:\n\n1.  **Performance persistence**: Funds in the highest Return Gap decile tend to outperform those in the lowest decile by 1-2% annually on a risk-adjusted basis, and this spread persists over time [@kacperczyk2008unobserved].\n2.  **Detecting agency problems**: A persistently negative Return Gap can signal hidden costs such as excessive trading, market impact costs, soft-dollar arrangements, or stale-price exploitation.\n3.  **Complementing traditional measures**: Unlike alpha-based metrics that blend stock selection skill with interim trading skill, the Return Gap isolates the component of performance attributable to actions taken *between* disclosure dates.\n4.  **Regulatory implications**: In emerging markets like Vietnam, where disclosure frequency and regulatory oversight may differ from developed markets, the Return Gap can serve as an early warning system for investor protection.\n\n## Application to the Vietnamese Market\n\nThe Vietnamese mutual fund industry, while relatively young compared to the United States, has experienced rapid growth since the establishment of the first domestic equity funds in the early 2000s. As of 2024, Vietnam's open-ended fund industry manages assets exceeding 100 trillion VND, with dozens of equity-oriented funds operated by both domestic and foreign-affiliated asset management companies.\n\nSeveral characteristics of the Vietnamese market make the Return Gap analysis particularly interesting:\n\n-   **Disclosure frequency**: Vietnamese funds are required to disclose their top holdings periodically, but the frequency and completeness of disclosure may differ from the quarterly SEC requirements in the U.S.\n-   **Market microstructure**: The HOSE (Ho Chi Minh Stock Exchange) and HNX (Hanoi Stock Exchange) feature daily price limits (plus or minus 7% on HOSE, plus or minus 10% on HNX), T+2 settlement, and foreign ownership limits that may constrain or enable certain interim trading strategies.\n-   **Information asymmetry**: In an emerging market with less analyst coverage, the scope for informed interim trading and hence positive Return Gap may be larger than in more efficient markets.\n-   **Regulatory environment**: Vietnam's State Securities Commission (SSC) has progressively strengthened disclosure and governance requirements, making temporal analysis of Return Gap especially informative.\n\n# Theoretical Framework {#sec-return-gaptheory}\n\n## Decomposing Fund Returns\n\nConsider a mutual fund $i$ that discloses its portfolio holdings at discrete dates $\\tau_1, \\tau_2, \\ldots$ As disclosed at date $\\tau_k$, the fund holds $N_k$ securities with weights $\\{w_{j,\\tau_k}\\}_{j=1}^{N_k}$, where $w_{j,\\tau_k}$ represents the portfolio weight of security $j$.\n\nBetween disclosure dates $\\tau_k$ and $\\tau_{k+1}$, the fund's *actual gross return* in month $t$ can be decomposed as:\n\n$$\nR_{i,t}^{\\text{Gross}} = R_{i,t}^{\\text{Holdings}} + \\underbrace{R_{i,t}^{\\text{Gross}} - R_{i,t}^{\\text{Holdings}}}_{\\text{Return Gap}}\n$$ {#eq-decomposition}\n\nThe hypothetical holdings return $R_{i,t}^{\\text{Holdings}}$ is computed as the value-weighted return of the buy-and-hold portfolio based on the most recent disclosure:\n\n$$\nR_{i,t}^{\\text{Holdings}} = \\sum_{j=1}^{N_k} \\tilde{w}_{j,t-1} \\cdot r_{j,t}\n$$ {#eq-holdings-return}\n\nwhere $r_{j,t}$ is the return of security $j$ in month $t$, and $\\tilde{w}_{j,t-1}$ is the *evolved* portfolio weight at the end of month $t-1$, reflecting the buy-and-hold drift from the original disclosure weights:\n\n$$\n\\tilde{w}_{j,t-1} = \\frac{w_{j,\\tau_k} \\prod_{s=\\tau_k+1}^{t-1}(1 + r_{j,s})}{\\sum_{\\ell=1}^{N_k} w_{\\ell,\\tau_k} \\prod_{s=\\tau_k+1}^{t-1}(1 + r_{\\ell,s})}\n$$ {#eq-evolved-weights}\n\nIn practice, rather than tracking evolved weights explicitly, we use dollar values of holdings positions (shares held times price) as the natural weighting scheme.\n\n## The Return Gap Measure\n\n### Gross Return Gap\n\nThe Return Gap as originally defined by @kacperczyk2008unobserved uses the *gross* (before-expense) return:\n\n$$\n\\text{RG}_{i,t} = R_{i,t}^{\\text{Gross}} - R_{i,t}^{\\text{Holdings}} = \\left(R_{i,t}^{\\text{Net}} + \\frac{\\text{Expense Ratio}_{i,t}}{12}\\right) - R_{i,t}^{\\text{Holdings}}\n$$ {#eq-return-gap-gross}\n\nwhere $R_{i,t}^{\\text{Net}}$ is the reported net-of-expense return and the annual expense ratio is divided by 12 to approximate the monthly expense charge.\n\n### Sources of Return Gap\n\nThe Return Gap captures several components [@kacperczyk2008unobserved; @elton2011holdings]:\n\n$$\n\\text{RG}_{i,t} = \\underbrace{\\Delta_{\\text{trade}}}_{\\text{Interim trading}} + \\underbrace{\\Delta_{\\text{cash}}}_{\\text{Cash drag/return}} + \\underbrace{\\Delta_{\\text{fees}}}_{\\text{Hidden fees}} + \\underbrace{\\Delta_{\\text{lend}}}_{\\text{Securities lending}} + \\underbrace{\\varepsilon_t}_{\\text{Noise}}\n$$ {#eq-decompose-rg}\n\nwhere:\n\n-   $\\Delta_{\\text{trade}}$: The return impact of buying and selling securities between disclosure dates. Skilled managers generate positive $\\Delta_{\\text{trade}}$ by timing trades.\n-   $\\Delta_{\\text{cash}}$: The effect of holding cash or cash equivalents not captured in equity holdings disclosures. In rising markets, cash creates a drag (negative contribution); in falling markets, cash provides a cushion.\n-   $\\Delta_{\\text{fees}}$: Transaction costs, brokerage commissions, and any hidden fees not reflected in the stated expense ratio.\n-   $\\Delta_{\\text{lend}}$: Revenue from securities lending programs, which generates positive Return Gap.\n-   $\\varepsilon_t$: Measurement noise from timing differences, stale prices, or data errors.\n\n### Predictive Return Gap\n\nTo form tradeable portfolios and avoid look-ahead bias, @kacperczyk2008unobserved use the *trailing 12-month average* Return Gap, lagged by one quarter to account for the reporting delay:\n\n$$\n\\overline{\\text{RG}}_{i,t}^{12} = \\frac{1}{12} \\sum_{s=1}^{12} \\text{RG}_{i,t-s}\n$$ {#eq-trailing-rg}\n\nThe additional 3-month (one quarter) lag ensures that the Return Gap signal is based only on information available to investors at the time of portfolio formation. This is particularly important in Vietnam, where fund reporting may involve delays.\n\n## Risk-Adjusted Performance Evaluation\n\nTo evaluate whether Return Gap-sorted portfolios generate genuine risk-adjusted returns, we employ several factor models.\n\n### CAPM Alpha\n\n$$\nR_{p,t} - R_{f,t} = \\alpha_p + \\beta_p (R_{m,t} - R_{f,t}) + \\epsilon_{p,t}\n$$ {#eq-capm}\n\n### Fama-French Three-Factor Model\n\n$$\nR_{p,t} - R_{f,t} = \\alpha_p + \\beta_{1,p} \\cdot \\text{MKT}_t + \\beta_{2,p} \\cdot \\text{SMB}_t + \\beta_{3,p} \\cdot \\text{HML}_t + \\epsilon_{p,t}\n$$ {#eq-ff3}\n\n### Carhart Four-Factor Model\n\n$$\nR_{p,t} - R_{f,t} = \\alpha_p + \\beta_{1,p} \\cdot \\text{MKT}_t + \\beta_{2,p} \\cdot \\text{SMB}_t + \\beta_{3,p} \\cdot \\text{HML}_t + \\beta_{4,p} \\cdot \\text{UMD}_t + \\epsilon_{p,t}\n$$ {#eq-carhart}\n\nwhere $\\text{UMD}_t$ is the momentum factor (up minus down).\n\n### Fama-French Five-Factor Model\n\nFor a more comprehensive risk adjustment relevant to the Vietnamese market:\n\n$$\nR_{p,t} - R_{f,t} = \\alpha_p + \\beta_1 \\text{MKT}_t + \\beta_2 \\text{SMB}_t + \\beta_3 \\text{HML}_t + \\beta_4 \\text{RMW}_t + \\beta_5 \\text{CMA}_t + \\epsilon_{p,t}\n$$ {#eq-ff5}\n\nwhere $\\text{RMW}_t$ (robust minus weak) captures profitability and $\\text{CMA}_t$ (conservative minus aggressive) captures investment patterns.\n\n## Newey-West Standard Errors\n\nSince portfolio returns may exhibit serial correlation, we use @newey1987simple standard errors with $L$ lags:\n\n$$\n\\hat{V}(\\hat{\\alpha}) = T \\left(\\sum_{t=1}^{T} \\mathbf{x}_t \\mathbf{x}_t'\\right)^{-1} \\hat{S} \\left(\\sum_{t=1}^{T} \\mathbf{x}_t \\mathbf{x}_t'\\right)^{-1}\n$$ {#eq-newey-west-var}\n\nwhere the HAC covariance estimator is:\n\n$$\n\\hat{S} = \\hat{\\Gamma}_0 + \\sum_{\\ell=1}^{L} \\left(1 - \\frac{\\ell}{L+1}\\right)\\left(\\hat{\\Gamma}_\\ell + \\hat{\\Gamma}_\\ell'\\right)\n$$ {#eq-hac}\n\nand $\\hat{\\Gamma}_\\ell = \\frac{1}{T}\\sum_{t=\\ell+1}^{T} \\hat{\\epsilon}_t \\hat{\\epsilon}_{t-\\ell} \\mathbf{x}_t \\mathbf{x}_{t-\\ell}'$. The standard lag choice is $L = \\lfloor 4(T/100)^{2/9} \\rfloor$.\n\n# Data and Sample Construction {#sec-return-gapdata}\n\n## Data Sources\n\n@tbl-return-gaps-data-sources shows the sources used in the construction of return gaps.\n\n| Data Category | Source | Description |\n|:-----------------------|:-----------------------|:-----------------------|\n| Fund holdings | DataCore Fund Holdings | Disclosed portfolio positions including ticker, shares held, report date, and vintage (filing) date |\n| Fund returns | DataCore Fund Performance | Monthly NAV-based net returns, total net assets, and expense ratios |\n| Fund characteristics | DataCore Fund Master | Fund objective codes, inception dates, management company, investment style |\n| Stock prices and returns | DataCore Equity Market | Daily and monthly adjusted prices, returns, shares outstanding, and corporate actions for HOSE and HNX listed securities |\n| Risk factors | DataCore / Constructed | Vietnamese market factor portfolios (MKT, SMB, HML, UMD, RMW, CMA) |\n\n: Data sources for the Return Gap analysis in Vietnam {#tbl-return-gaps-data-sources}\n\n## Setting Up the Environment\n\n::: {#setup-environment .cell execution_count=2}\n``` {.python .cell-code code-summary=\"Import libraries and configure settings\"}\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport statsmodels.api as sm\nfrom statsmodels.regression.linear_model import OLS\nfrom scipy import stats\nfrom datetime import datetime, timedelta\nfrom dateutil.relativedelta import relativedelta\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\n\nplt.rcParams.update({\n    \"figure.figsize\": (10, 6),\n    \"font.size\": 12,\n    \"axes.titlesize\": 14,\n    \"axes.labelsize\": 12,\n    \"xtick.labelsize\": 10,\n    \"ytick.labelsize\": 10,\n    \"legend.fontsize\": 10,\n    \"figure.dpi\": 150,\n    \"savefig.dpi\": 300,\n    \"font.family\": \"serif\",\n})\n\nsns.set_style(\"whitegrid\")\nnp.random.seed(42)\n```\n:::\n\n\n## Loading and Preparing Stock Market Data {#sec-return-gapstock-data}\n\nThe first step is to load the stock-level data, which provides the foundation for computing hypothetical holdings returns.\n\n::: {#cell-load-stock-data .cell execution_count=3}\n``` {.python .cell-code code-summary=\"Load stock prices and returns from DataCore\"}\n# ============================================================\n# In production, replace with actual DataCore API calls:\n#   from datacore import DataCoreClient\n#   client = DataCoreClient(api_key=\"YOUR_KEY\")\n#   stock_data = client.get_equity_monthly(\n#       exchange=[\"HOSE\", \"HNX\"],\n#       start_date=\"2010-01-01\",\n#       end_date=\"2024-12-31\",\n#       fields=[\"ticker\", \"date\", \"close_adj\", \"return_monthly\",\n#               \"shares_outstanding\", \"market_cap\"]\n#   )\n# ============================================================\n\ndef generate_stock_data(\n    n_stocks: int = 300,\n    start_date: str = \"2012-01-01\",\n    end_date: str = \"2024-12-31\",\n) -> pd.DataFrame:\n    \"\"\"\n    Generate simulated monthly stock data mimicking Vietnamese\n    equity market characteristics.\n    \"\"\"\n    dates = pd.date_range(start_date, end_date, freq=\"ME\")\n    tickers = [f\"VN{str(i).zfill(4)}\" for i in range(1, n_stocks + 1)]\n\n    records = []\n    for ticker in tickers:\n        list_offset = np.random.randint(0, max(1, len(dates) // 3))\n        available_dates = dates[list_offset:]\n        mu = np.random.normal(0.008, 0.005)\n        sigma = np.random.uniform(0.06, 0.15)\n        beta = np.random.uniform(0.5, 1.8)\n        market_shocks = np.random.normal(0.005, 0.06, len(available_dates))\n        idio_shocks = np.random.normal(0, sigma, len(available_dates))\n        returns = mu + beta * market_shocks + idio_shocks\n        returns = np.clip(returns, -0.30, 0.40)\n        price = np.random.uniform(10, 150)\n        prices = [price]\n        for r in returns[:-1]:\n            price = price * (1 + r)\n            prices.append(price)\n        shares = np.random.uniform(50, 500) * 1e6\n        shares_series = np.full(len(available_dates), shares)\n        for i, d in enumerate(available_dates):\n            records.append({\n                \"ticker\": ticker, \"date\": d,\n                \"close_adj\": prices[i], \"ret\": returns[i],\n                \"shares_outstanding\": shares_series[i],\n                \"market_cap\": prices[i] * shares_series[i] / 1e9,\n            })\n\n    df = pd.DataFrame(records)\n    df[\"date\"] = pd.to_datetime(df[\"date\"])\n    df = df.sort_values([\"ticker\", \"date\"])\n    df[\"close_adj_lag\"] = df.groupby(\"ticker\")[\"close_adj\"].shift(1)\n    return df\n\nstock_data = generate_stock_data()\nprint(f\"Stock data: {stock_data.shape[0]:,} stock-months\")\nprint(f\"Unique stocks: {stock_data['ticker'].nunique()}\")\nprint(f\"Date range: {stock_data['date'].min():%Y-%m} to \"\n      f\"{stock_data['date'].max():%Y-%m}\")\nstock_data.head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStock data: 38,865 stock-months\nUnique stocks: 300\nDate range: 2012-01 to 2024-12\n```\n:::\n\n::: {#load-stock-data .cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ticker</th>\n      <th>date</th>\n      <th>close_adj</th>\n      <th>ret</th>\n      <th>shares_outstanding</th>\n      <th>market_cap</th>\n      <th>close_adj_lag</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>VN0001</td>\n      <td>2015-03-31</td>\n      <td>45.035190</td>\n      <td>0.110630</td>\n      <td>6.747563e+07</td>\n      <td>3.038778</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>VN0001</td>\n      <td>2015-04-30</td>\n      <td>50.017423</td>\n      <td>-0.066939</td>\n      <td>6.747563e+07</td>\n      <td>3.374957</td>\n      <td>45.035190</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>VN0001</td>\n      <td>2015-05-31</td>\n      <td>46.669311</td>\n      <td>0.047021</td>\n      <td>6.747563e+07</td>\n      <td>3.149041</td>\n      <td>50.017423</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>VN0001</td>\n      <td>2015-06-30</td>\n      <td>48.863751</td>\n      <td>-0.152745</td>\n      <td>6.747563e+07</td>\n      <td>3.297112</td>\n      <td>46.669311</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>VN0001</td>\n      <td>2015-07-31</td>\n      <td>41.400073</td>\n      <td>-0.057519</td>\n      <td>6.747563e+07</td>\n      <td>2.793496</td>\n      <td>48.863751</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>VN0001</td>\n      <td>2015-08-31</td>\n      <td>39.018788</td>\n      <td>0.228286</td>\n      <td>6.747563e+07</td>\n      <td>2.632817</td>\n      <td>41.400073</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>VN0001</td>\n      <td>2015-09-30</td>\n      <td>47.926227</td>\n      <td>0.079232</td>\n      <td>6.747563e+07</td>\n      <td>3.233852</td>\n      <td>39.018788</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>VN0001</td>\n      <td>2015-10-31</td>\n      <td>51.723515</td>\n      <td>-0.300000</td>\n      <td>6.747563e+07</td>\n      <td>3.490077</td>\n      <td>47.926227</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>VN0001</td>\n      <td>2015-11-30</td>\n      <td>36.206461</td>\n      <td>0.192114</td>\n      <td>6.747563e+07</td>\n      <td>2.443054</td>\n      <td>51.723515</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>VN0001</td>\n      <td>2015-12-31</td>\n      <td>43.162239</td>\n      <td>0.294336</td>\n      <td>6.747563e+07</td>\n      <td>2.912399</td>\n      <td>36.206461</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Loading Fund Holdings Data {#sec-return-gapholdings-data}\n\n::: {#cell-load-holdings-data .cell execution_count=4}\n``` {.python .cell-code code-summary=\"Load fund holdings from DataCore\"}\ndef generate_holdings_data(\n    stock_data: pd.DataFrame,\n    n_funds: int = 50,\n    start_date: str = \"2012-06-30\",\n    end_date: str = \"2024-12-31\",\n) -> pd.DataFrame:\n    \"\"\"\n    Generate simulated fund holdings data. Each fund holds 15-80\n    stocks, disclosed semi-annually or quarterly.\n    \"\"\"\n    dates = pd.date_range(start_date, end_date, freq=\"ME\")\n    tickers = stock_data[\"ticker\"].unique()\n    fund_ids = [f\"FUND{str(i).zfill(3)}\" for i in range(1, n_funds + 1)]\n    records = []\n    for fund_id in fund_ids:\n        inception_idx = np.random.randint(0, max(1, len(dates) // 4))\n        freq = 3 if np.random.random() < 0.7 else 6\n        n_stocks_held = np.random.randint(15, 80)\n        core_stocks = np.random.choice(tickers, size=n_stocks_held, replace=False)\n        report_dates = dates[inception_idx::freq]\n        for rdate in report_dates:\n            filing_delay = np.random.randint(1, 4)\n            fdate = rdate + pd.DateOffset(months=filing_delay)\n            turnover = np.random.uniform(0.05, 0.20)\n            n_replace = max(1, int(n_stocks_held * turnover))\n            replace_idx = np.random.choice(len(core_stocks), size=n_replace, replace=False)\n            new_stocks = np.random.choice(tickers, size=n_replace, replace=False)\n            core_stocks[replace_idx] = new_stocks\n            for ticker in core_stocks:\n                shares = np.random.uniform(100_000, 5_000_000)\n                records.append({\n                    \"fund_id\": fund_id, \"report_date\": rdate,\n                    \"filing_date\": fdate, \"ticker\": ticker,\n                    \"shares_held\": shares,\n                })\n    df = pd.DataFrame(records)\n    df[\"report_date\"] = pd.to_datetime(df[\"report_date\"])\n    df[\"filing_date\"] = pd.to_datetime(df[\"filing_date\"])\n    return df\n\nholdings_raw = generate_holdings_data(stock_data)\nprint(f\"Holdings records: {holdings_raw.shape[0]:,}\")\nprint(f\"Unique funds: {holdings_raw['fund_id'].nunique()}\")\nholdings_raw.head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHoldings records: 89,269\nUnique funds: 50\n```\n:::\n\n::: {#load-holdings-data .cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>fund_id</th>\n      <th>report_date</th>\n      <th>filing_date</th>\n      <th>ticker</th>\n      <th>shares_held</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>VN0289</td>\n      <td>4.918132e+06</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>VN0297</td>\n      <td>4.322425e+05</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>VN0259</td>\n      <td>2.383117e+05</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>VN0215</td>\n      <td>1.140891e+06</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>VN0262</td>\n      <td>1.104603e+06</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>VN0292</td>\n      <td>1.665416e+06</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>VN0132</td>\n      <td>4.625400e+06</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>VN0049</td>\n      <td>3.447053e+06</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>VN0008</td>\n      <td>1.525004e+05</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>VN0189</td>\n      <td>2.527258e+06</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Loading Fund Returns and Characteristics {#sec-return-gapfund-returns}\n\n::: {#cell-load-fund-returns .cell execution_count=5}\n``` {.python .cell-code code-summary=\"Load fund NAV returns and expense data\"}\ndef generate_fund_returns(holdings, start_date=\"2012-01-01\", end_date=\"2024-12-31\"):\n    \"\"\"Generate monthly fund-level net returns, TNA, and expense ratios.\"\"\"\n    fund_ids = holdings[\"fund_id\"].unique()\n    dates = pd.date_range(start_date, end_date, freq=\"ME\")\n    records = []\n    for fund_id in fund_ids:\n        fund_start = holdings.loc[holdings[\"fund_id\"] == fund_id, \"report_date\"].min() - pd.DateOffset(months=3)\n        fund_dates = dates[dates >= fund_start]\n        exp_ratio = np.random.uniform(0.010, 0.025)\n        base_tna = np.random.uniform(50, 2000)\n        mu = np.random.normal(0.007, 0.003)\n        sigma = np.random.uniform(0.04, 0.09)\n        tna = base_tna\n        for d in fund_dates:\n            ret = np.clip(np.random.normal(mu, sigma), -0.25, 0.35)\n            tna = max(tna * (1 + ret) + np.random.normal(0, base_tna * 0.02), 10)\n            records.append({\"fund_id\": fund_id, \"date\": d, \"net_return\": ret,\n                            \"tna\": tna, \"expense_ratio\": exp_ratio + np.random.normal(0, 0.001)})\n    df = pd.DataFrame(records)\n    df[\"date\"] = pd.to_datetime(df[\"date\"])\n    df[\"expense_ratio\"] = df[\"expense_ratio\"].clip(0.005, 0.035)\n    return df\n\nfund_returns = generate_fund_returns(holdings_raw)\nprint(f\"Fund-month observations: {fund_returns.shape[0]:,}\")\nfund_returns.head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFund-month observations: 6,808\n```\n:::\n\n::: {#load-fund-returns .cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>fund_id</th>\n      <th>date</th>\n      <th>net_return</th>\n      <th>tna</th>\n      <th>expense_ratio</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>FUND001</td>\n      <td>2012-08-31</td>\n      <td>0.045634</td>\n      <td>568.611866</td>\n      <td>0.022429</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>FUND001</td>\n      <td>2012-09-30</td>\n      <td>0.106959</td>\n      <td>631.630643</td>\n      <td>0.021461</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>FUND001</td>\n      <td>2012-10-31</td>\n      <td>-0.063495</td>\n      <td>612.614200</td>\n      <td>0.020634</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>-0.087247</td>\n      <td>563.095634</td>\n      <td>0.023795</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>FUND001</td>\n      <td>2012-12-31</td>\n      <td>-0.006777</td>\n      <td>545.547597</td>\n      <td>0.021886</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>FUND001</td>\n      <td>2013-01-31</td>\n      <td>-0.029553</td>\n      <td>532.221482</td>\n      <td>0.021999</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>FUND001</td>\n      <td>2013-02-28</td>\n      <td>-0.002767</td>\n      <td>538.411988</td>\n      <td>0.021567</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>FUND001</td>\n      <td>2013-03-31</td>\n      <td>-0.138187</td>\n      <td>477.997478</td>\n      <td>0.022189</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>FUND001</td>\n      <td>2013-04-30</td>\n      <td>0.045137</td>\n      <td>484.711443</td>\n      <td>0.022058</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>FUND001</td>\n      <td>2013-05-31</td>\n      <td>0.095518</td>\n      <td>523.213577</td>\n      <td>0.021911</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Sample Selection: Domestic Equity Funds {#sec-return-gapsample-selection}\n\nFollowing the approach of @kacperczyk2008unobserved, we restrict our sample to domestic equity funds.\n\n::: {#sample-selection .cell execution_count=6}\n``` {.python .cell-code code-summary=\"Filter to domestic equity funds\"}\nequity_objectives = [\n    \"EQUITY_DOMESTIC\", \"EQUITY_GROWTH\", \"EQUITY_VALUE\",\n    \"EQUITY_BLEND\", \"EQUITY_LARGE_CAP\", \"EQUITY_MID_CAP\",\n    \"EQUITY_SMALL_CAP\",\n]\n\nfund_ids = fund_returns[\"fund_id\"].unique()\nfund_master = pd.DataFrame({\n    \"fund_id\": fund_ids,\n    \"objective\": np.random.choice(\n        equity_objectives + [\"BOND\", \"BALANCED\", \"MONEY_MARKET\"],\n        size=len(fund_ids),\n        p=[0.08, 0.08, 0.06, 0.10, 0.08, 0.06, 0.06, 0.15, 0.18, 0.15],\n    ),\n})\n\nequity_fund_ids = fund_master.loc[\n    fund_master[\"objective\"].isin(equity_objectives), \"fund_id\"\n].values\n\nprint(f\"Total funds: {len(fund_ids)}\")\nprint(f\"Equity funds: {len(equity_fund_ids)} ({len(equity_fund_ids)/len(fund_ids)*100:.1f}%)\")\nprint(\"\\nObjective distribution:\")\nprint(fund_master[\"objective\"].value_counts().to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTotal funds: 50\nEquity funds: 29 (58.0%)\n\nObjective distribution:\nobjective\nBALANCED            9\nEQUITY_VALUE        9\nEQUITY_GROWTH       6\nBOND                6\nMONEY_MARKET        6\nEQUITY_BLEND        5\nEQUITY_LARGE_CAP    3\nEQUITY_SMALL_CAP    2\nEQUITY_MID_CAP      2\nEQUITY_DOMESTIC     2\n```\n:::\n:::\n\n\n# Computing the Return Gap {#sec-return-gapcomputing}\n\n## Step 1: Prepare Holdings Vintages {#sec-return-gapvintages}\n\nA critical first step is to correctly handle the *vintage* structure of holdings data. Each holdings report has two key dates: the **report date** ($\\tau$, the as-of date) and the **filing date** ($f$, when it becomes public). We keep only the first vintage per fund-report date.\n\n::: {#cell-prepare-vintages .cell execution_count=7}\n``` {.python .cell-code code-summary=\"Process holdings vintages and determine holding periods\"}\ndef prepare_holdings_vintages(holdings, max_holding_months=6):\n    \"\"\"Process holdings vintages and compute next report dates.\"\"\"\n    first_vintage = (\n        holdings.sort_values([\"fund_id\", \"report_date\", \"filing_date\"])\n        .groupby([\"fund_id\", \"report_date\"])\n        .agg(filing_date=(\"filing_date\", \"first\"))\n        .reset_index()\n    )\n    first_vintage = first_vintage.sort_values([\"fund_id\", \"report_date\"])\n    first_vintage[\"next_report_date\"] = first_vintage.groupby(\"fund_id\")[\"report_date\"].shift(-1)\n    max_date = first_vintage[\"report_date\"] + pd.DateOffset(months=max_holding_months)\n    first_vintage[\"next_report_date\"] = first_vintage[\"next_report_date\"].fillna(max_date)\n    first_vintage[\"next_report_date\"] = first_vintage[[\"next_report_date\"]].min(axis=1).clip(upper=max_date)\n    first_vintage[\"next_report_date\"] = first_vintage[\"next_report_date\"] + pd.offsets.MonthEnd(0)\n    result = holdings.merge(first_vintage, on=[\"fund_id\", \"report_date\", \"filing_date\"], how=\"inner\")\n    return result\n\nholdings_vintaged = prepare_holdings_vintages(holdings_raw)\nprint(f\"Holdings after vintage processing: {holdings_vintaged.shape[0]:,} records\")\nsample_fund = holdings_vintaged[\"fund_id\"].iloc[0]\n(holdings_vintaged.loc[holdings_vintaged[\"fund_id\"] == sample_fund]\n [[\"fund_id\", \"report_date\", \"filing_date\", \"next_report_date\"]]\n .drop_duplicates().head(8))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHoldings after vintage processing: 89,269 records\n```\n:::\n\n::: {#prepare-vintages .cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>fund_id</th>\n      <th>report_date</th>\n      <th>filing_date</th>\n      <th>next_report_date</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>FUND001</td>\n      <td>2012-11-30</td>\n      <td>2012-12-30</td>\n      <td>2013-02-28</td>\n    </tr>\n    <tr>\n      <th>52</th>\n      <td>FUND001</td>\n      <td>2013-02-28</td>\n      <td>2013-03-28</td>\n      <td>2013-05-31</td>\n    </tr>\n    <tr>\n      <th>104</th>\n      <td>FUND001</td>\n      <td>2013-05-31</td>\n      <td>2013-08-31</td>\n      <td>2013-08-31</td>\n    </tr>\n    <tr>\n      <th>156</th>\n      <td>FUND001</td>\n      <td>2013-08-31</td>\n      <td>2013-11-30</td>\n      <td>2013-11-30</td>\n    </tr>\n    <tr>\n      <th>208</th>\n      <td>FUND001</td>\n      <td>2013-11-30</td>\n      <td>2014-02-28</td>\n      <td>2014-02-28</td>\n    </tr>\n    <tr>\n      <th>260</th>\n      <td>FUND001</td>\n      <td>2014-02-28</td>\n      <td>2014-04-28</td>\n      <td>2014-05-31</td>\n    </tr>\n    <tr>\n      <th>312</th>\n      <td>FUND001</td>\n      <td>2014-05-31</td>\n      <td>2014-08-31</td>\n      <td>2014-08-31</td>\n    </tr>\n    <tr>\n      <th>364</th>\n      <td>FUND001</td>\n      <td>2014-08-31</td>\n      <td>2014-10-31</td>\n      <td>2014-11-30</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## Step 2: Adjust Shares for Corporate Actions {#sec-return-gapadjust-shares}\n\n::: {#adjust-shares .cell execution_count=8}\n``` {.python .cell-code code-summary=\"Adjust shares held for corporate actions\"}\ndef adjust_holdings_shares(holdings, stock_data):\n    \"\"\"Adjust shares for splits, bonuses, rights. Simulated: factor=1.\"\"\"\n    holdings[\"shares_adj\"] = holdings[\"shares_held\"]\n    return holdings\n\nholdings_adj = adjust_holdings_shares(holdings_vintaged, stock_data)\n```\n:::\n\n\n## Step 3: Compute Hypothetical Holdings Returns {#sec-return-gaphypothetical-returns}\n\nThis is the core computation. For each fund, we take the disclosed holdings as of report date $\\tau$, and for each month $t$ in $(\\tau, \\tau_{\\text{next}}]$, compute the value-weighted return using lagged dollar values as weights.\n\n::: {#compute-holdings-returns .cell execution_count=9}\n``` {.python .cell-code code-summary=\"Compute value-weighted hypothetical portfolio returns\"}\ndef compute_holdings_returns(holdings, stock_data, min_stocks=10, min_assets_bn=5.0):\n    \"\"\"Compute monthly hypothetical buy-and-hold portfolio returns.\"\"\"\n    merged = holdings.merge(stock_data, on=\"ticker\", how=\"inner\")\n    mask = (merged[\"date\"] > merged[\"report_date\"]) & (merged[\"date\"] <= merged[\"next_report_date\"])\n    merged = merged.loc[mask].copy()\n    merged[\"hvalue_lag\"] = merged[\"shares_adj\"] * merged[\"close_adj_lag\"]\n    merged = merged.loc[merged[\"hvalue_lag\"] > 0].copy()\n    merged = merged.drop_duplicates(subset=[\"fund_id\", \"date\", \"report_date\", \"ticker\"], keep=\"first\")\n\n    def weighted_return(group):\n        weights = group[\"hvalue_lag\"]\n        total_weight = weights.sum()\n        if total_weight <= 0:\n            return pd.Series({\"hret\": np.nan, \"n_stocks\": 0, \"assets_lag_bn\": 0})\n        wret = np.average(group[\"ret\"], weights=weights)\n        return pd.Series({\"hret\": wret, \"n_stocks\": len(group), \"assets_lag_bn\": total_weight / 1e9})\n\n    portfolio_returns = (\n        merged.groupby([\"fund_id\", \"date\"])\n        .apply(weighted_return, include_groups=False).reset_index()\n    )\n    portfolio_returns[\"assets_bn\"] = portfolio_returns[\"assets_lag_bn\"] * (1 + portfolio_returns[\"hret\"])\n    mask = (portfolio_returns[\"n_stocks\"] >= min_stocks) & (portfolio_returns[\"assets_bn\"] >= min_assets_bn)\n    return portfolio_returns.loc[mask].copy()\n\nholdings_returns = compute_holdings_returns(holdings_adj, stock_data)\nprint(f\"Fund-month observations (hypothetical returns): {holdings_returns.shape[0]:,}\")\nprint(f\"Unique funds: {holdings_returns['fund_id'].nunique()}\")\nprint(f\"\\nSummary:\")\nprint(holdings_returns[[\"hret\", \"n_stocks\", \"assets_bn\"]].describe().round(4).to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFund-month observations (hypothetical returns): 6,170\nUnique funds: 50\n\nSummary:\n            hret   n_stocks  assets_bn\ncount  6170.0000  6170.0000  6170.0000\nmean      0.0149    42.7476    27.8827\nstd       0.0426    14.5061    20.1749\nmin      -0.1997    13.0000     5.0241\n25%      -0.0111    31.0000    13.3775\n50%       0.0146    41.0000    22.6388\n75%       0.0411    53.0000    35.6065\nmax       0.2209    74.0000   167.3511\n```\n:::\n:::\n\n\n## Step 4: Compute Gross Fund Returns {#sec-return-gapgross-returns}\n\n::: {#compute-gross-returns .cell execution_count=10}\n``` {.python .cell-code code-summary=\"Compute gross fund returns\"}\ndef prepare_fund_returns(fund_returns, equity_fund_ids):\n    \"\"\"Prepare fund-level gross returns.\"\"\"\n    df = fund_returns.loc[fund_returns[\"fund_id\"].isin(equity_fund_ids)].copy()\n    df[\"expense_ratio\"] = df[\"expense_ratio\"].fillna(df.groupby(\"fund_id\")[\"expense_ratio\"].transform(\"median\"))\n    df[\"gross_return\"] = df[\"net_return\"] + df[\"expense_ratio\"] / 12\n    df = df.sort_values([\"fund_id\", \"date\"])\n    df[\"tna_lag\"] = df.groupby(\"fund_id\")[\"tna\"].shift(1).fillna(df[\"tna\"])\n    return df\n\nfund_ret_clean = prepare_fund_returns(fund_returns, equity_fund_ids)\nprint(f\"Equity fund-months: {fund_ret_clean.shape[0]:,}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEquity fund-months: 3,993\n```\n:::\n:::\n\n\n## Step 5: Merge and Compute Return Gap {#sec-return-gapmerge-return-gap}\n\n::: {#compute-return-gap .cell execution_count=11}\n``` {.python .cell-code code-summary=\"Merge actual and hypothetical returns to compute Return Gap\"}\ndef compute_return_gap(holdings_returns, fund_returns):\n    \"\"\"Compute Return Gap and trailing averages.\"\"\"\n    merged = holdings_returns.merge(\n        fund_returns[[\"fund_id\", \"date\", \"net_return\", \"gross_return\", \"expense_ratio\", \"tna\"]],\n        on=[\"fund_id\", \"date\"], how=\"inner\",\n    )\n    merged[\"return_gap\"] = merged[\"gross_return\"] - merged[\"hret\"]\n    merged = merged.sort_values([\"fund_id\", \"date\"])\n    merged[\"rg_12m\"] = merged.groupby(\"fund_id\")[\"return_gap\"].transform(\n        lambda x: x.rolling(12, min_periods=8).mean()\n    )\n    merged[\"rg_12m_lag4\"] = merged.groupby(\"fund_id\")[\"rg_12m\"].shift(4)\n    return merged\n\nreturn_gap_data = compute_return_gap(holdings_returns, fund_ret_clean)\nprint(f\"Return Gap observations: {return_gap_data.shape[0]:,}\")\nprint(f\"\\nSummary:\")\nprint(return_gap_data[[\"return_gap\", \"rg_12m\", \"rg_12m_lag4\"]].describe().round(6).to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReturn Gap observations: 3,592\n\nSummary:\n        return_gap       rg_12m  rg_12m_lag4\ncount  3592.000000  3389.000000  3273.000000\nmean     -0.005734    -0.005349    -0.005329\nstd       0.080211     0.022955     0.022864\nmin      -0.307136    -0.094187    -0.094187\n25%      -0.058760    -0.019080    -0.019057\n50%      -0.006127    -0.005284    -0.005242\n75%       0.047785     0.008620     0.008653\nmax       0.277137     0.079589     0.079589\n```\n:::\n:::\n\n\n## Distribution of the Return Gap\n\n::: {#cell-fig-return-gap-distribution .cell fig-height='5' fig-width='12' execution_count=12}\n``` {.python .cell-code}\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\n\nrg = return_gap_data[\"return_gap\"].dropna()\nrg_trimmed = rg.clip(rg.quantile(0.01), rg.quantile(0.99))\naxes[0].hist(rg_trimmed, bins=80, density=True, alpha=0.7, color=\"#2C5F8A\", edgecolor=\"white\", linewidth=0.5)\naxes[0].axvline(rg.mean(), color=\"#D32F2F\", linestyle=\"--\", linewidth=2, label=f\"Mean = {rg.mean():.4f}\")\naxes[0].axvline(rg.median(), color=\"#FF8F00\", linestyle=\"-.\", linewidth=2, label=f\"Median = {rg.median():.4f}\")\naxes[0].set_xlabel(\"Monthly Return Gap\")\naxes[0].set_ylabel(\"Density\")\naxes[0].set_title(\"Panel A: Monthly Return Gap\")\naxes[0].legend(frameon=True)\n\nrg12 = return_gap_data[\"rg_12m\"].dropna()\nrg12_trimmed = rg12.clip(rg12.quantile(0.01), rg12.quantile(0.99))\naxes[1].hist(rg12_trimmed, bins=80, density=True, alpha=0.7, color=\"#1B5E20\", edgecolor=\"white\", linewidth=0.5)\naxes[1].axvline(rg12.mean(), color=\"#D32F2F\", linestyle=\"--\", linewidth=2, label=f\"Mean = {rg12.mean():.4f}\")\naxes[1].axvline(rg12.median(), color=\"#FF8F00\", linestyle=\"-.\", linewidth=2, label=f\"Median = {rg12.median():.4f}\")\naxes[1].set_xlabel(\"Trailing 12-Month Average Return Gap\")\naxes[1].set_ylabel(\"Density\")\naxes[1].set_title(\"Panel B: 12-Month Average Return Gap\")\naxes[1].legend(frameon=True)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Distribution of monthly Return Gap across all fund-month observations.](32_return_gaps_files/figure-html/fig-return-gap-distribution-output-1.png){#fig-return-gap-distribution width=1775 height=727}\n:::\n:::\n\n\n## Time Series of Cross-Sectional Return Gap\n\n::: {#cell-fig-return-gap-timeseries .cell fig-height='5' fig-width='12' execution_count=13}\n``` {.python .cell-code}\nts_stats = (\n    return_gap_data.groupby(\"date\")[\"return_gap\"]\n    .agg([\"mean\", \"median\", lambda x: x.quantile(0.25), lambda x: x.quantile(0.75)])\n    .rename(columns={\"<lambda_0>\": \"p25\", \"<lambda_1>\": \"p75\"}).reset_index()\n)\n\nfig, ax = plt.subplots(figsize=(12, 5))\nax.fill_between(ts_stats[\"date\"], ts_stats[\"p25\"], ts_stats[\"p75\"], alpha=0.3, color=\"#2C5F8A\", label=\"IQR\")\nax.plot(ts_stats[\"date\"], ts_stats[\"median\"], color=\"#2C5F8A\", linewidth=2, label=\"Median\")\nax.plot(ts_stats[\"date\"], ts_stats[\"mean\"], color=\"#D32F2F\", linestyle=\"--\", linewidth=1.5, label=\"Mean\")\nax.axhline(0, color=\"black\", linewidth=0.8)\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"Monthly Return Gap\")\nax.set_title(\"Cross-Sectional Distribution of Return Gap Over Time\")\nax.legend(frameon=True)\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Time series of cross-sectional Return Gap statistics. Solid: median, shaded: IQR, dashed: mean.](32_return_gaps_files/figure-html/fig-return-gap-timeseries-output-1.png){#fig-return-gap-timeseries width=1775 height=727}\n:::\n:::\n\n\n# Portfolio Sorting Analysis {#sec-return-gapportfolios}\n\n## Forming Return Gap Decile Portfolios {#sec-return-gapdecile-portfolios}\n\nEach month $t$, we sort funds into decile portfolios based on their lagged 12-month average Return Gap ($\\overline{\\text{RG}}_{i,t-4}^{12}$). Portfolio 1 contains funds with the lowest Return Gap.\n\n::: {#form-decile-portfolios .cell execution_count=14}\n``` {.python .cell-code code-summary=\"Sort funds into decile portfolios\"}\ndef form_return_gap_portfolios(data, n_portfolios=10, sort_var=\"rg_12m_lag4\"):\n    \"\"\"Form portfolios by sorting funds into quantile groups.\"\"\"\n    df = data.dropna(subset=[sort_var]).copy()\n    df[\"portfolio\"] = (\n        df.groupby(\"date\")[sort_var]\n        .transform(lambda x: pd.qcut(x, n_portfolios, labels=False, duplicates=\"drop\"))\n    ) + 1\n    return df\n\nn_portfolios = 10\nportfolio_data = form_return_gap_portfolios(return_gap_data, n_portfolios=n_portfolios)\nprint(f\"Observations with portfolio assignment: {portfolio_data.shape[0]:,}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nObservations with portfolio assignment: 3,273\n```\n:::\n:::\n\n\n## Portfolio Returns\n\n::: {#compute-portfolio-returns .cell execution_count=15}\n``` {.python .cell-code code-summary=\"Compute EW and VW portfolio returns\"}\ndef compute_portfolio_returns(data, n_portfolios=10):\n    \"\"\"Compute equal- and value-weighted monthly returns.\"\"\"\n    ew = data.groupby([\"date\", \"portfolio\"]).agg(\n        ew_ret=(\"net_return\", \"mean\"), n_funds=(\"fund_id\", \"count\")).reset_index()\n    def vw_func(group):\n        w = group[\"tna\"].clip(lower=0)\n        return np.average(group[\"net_return\"], weights=w) if w.sum() > 0 else group[\"net_return\"].mean()\n    vw = data.groupby([\"date\", \"portfolio\"]).apply(vw_func, include_groups=False).reset_index(name=\"vw_ret\")\n    return ew.merge(vw, on=[\"date\", \"portfolio\"], how=\"left\")\n\nport_returns = compute_portfolio_returns(portfolio_data)\nport_wide = port_returns.pivot_table(index=\"date\", columns=\"portfolio\", values=[\"ew_ret\", \"vw_ret\"])\nport_wide[(\"ew_ret\", \"LS\")] = port_wide[(\"ew_ret\", n_portfolios)] - port_wide[(\"ew_ret\", 1)]\nport_wide[(\"vw_ret\", \"LS\")] = port_wide[(\"vw_ret\", n_portfolios)] - port_wide[(\"vw_ret\", 1)]\n\nprint(\"EW portfolio returns (annualized, %):\")\nprint((port_wide[\"ew_ret\"].mean() * 12 * 100).round(2).to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEW portfolio returns (annualized, %):\nportfolio\n1.0      4.42\n2.0     12.09\n3.0     15.52\n4.0      8.35\n5.0     10.31\n6.0     14.38\n7.0      1.18\n8.0     10.99\n9.0      1.33\n10.0    15.19\nLS      10.77\n```\n:::\n:::\n\n\n## Characteristics of Return Gap Portfolios\n\n::: {#tbl-portfolio-characteristics .cell tbl-cap='Characteristics of Return Gap-sorted decile portfolios.' execution_count=16}\n``` {.python .cell-code}\nchars = portfolio_data.groupby(\"portfolio\").agg(\n    avg_rg=(\"return_gap\", \"mean\"), avg_rg12=(\"rg_12m_lag4\", \"mean\"),\n    avg_net_ret=(\"net_return\", \"mean\"), avg_gross_ret=(\"gross_return\", \"mean\"),\n    avg_hret=(\"hret\", \"mean\"), avg_expense=(\"expense_ratio\", \"mean\"),\n    avg_tna=(\"tna\", \"mean\"), avg_nstocks=(\"n_stocks\", \"mean\"), n_obs=(\"fund_id\", \"count\"),\n).round(4)\ndc = chars.copy()\ndc.columns = [\"Avg RG\", \"Avg RG(12m)\", \"Net Ret\", \"Gross Ret\", \"Hold Ret\", \"Expense\", \"TNA(Bn)\", \"#Stocks\", \"#Obs\"]\nfor col in [\"Avg RG\", \"Avg RG(12m)\", \"Net Ret\", \"Gross Ret\", \"Hold Ret\", \"Expense\"]:\n    dc[col] = (dc[col] * 100).round(3)\ndc[\"TNA(Bn)\"] = dc[\"TNA(Bn)\"].round(1)\ndc[\"#Stocks\"] = dc[\"#Stocks\"].round(1)\nprint(dc.to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Avg RG  Avg RG(12m)  Net Ret  Gross Ret  Hold Ret  Expense  TNA(Bn)  #Stocks  #Obs\nportfolio                                                                                    \n1.0         -0.81        -4.32     0.50       0.66      1.48     1.91   1395.7     41.9   353\n2.0          0.16        -2.73     1.02       1.18      1.02     1.86   1941.3     43.9   333\n3.0          0.06        -1.85     1.27       1.42      1.36     1.79   2042.0     45.5   335\n4.0         -1.11        -1.22     0.51       0.66      1.78     1.81   2052.1     47.6   325\n5.0         -0.57        -0.69     0.61       0.76      1.33     1.83   2010.7     46.8   341\n6.0          0.04        -0.20     1.23       1.39      1.35     1.86   2138.9     44.8   243\n7.0         -1.53         0.22    -0.09       0.07      1.60     1.86   2184.0     44.2   322\n8.0         -0.51         0.85     1.14       1.30      1.82     1.93   2340.3     43.7   338\n9.0         -1.30         1.61     0.09       0.25      1.54     1.87   2552.9     41.9   330\n10.0         0.11         3.17     1.31       1.46      1.35     1.83   2864.7     40.2   351\n```\n:::\n:::\n\n\n## Cumulative Returns of Extreme Portfolios\n\n::: {#cell-fig-cumulative-returns .cell fig-height='6' fig-width='12' execution_count=17}\n``` {.python .cell-code}\ncum_ret = pd.DataFrame(index=port_wide.index)\ncum_ret[\"P1 (Low RG)\"] = (1 + port_wide[(\"ew_ret\", 1)]).cumprod()\ncum_ret[\"P10 (High RG)\"] = (1 + port_wide[(\"ew_ret\", n_portfolios)]).cumprod()\ncum_ret[\"L/S (P10-P1)\"] = (1 + port_wide[(\"ew_ret\", \"LS\")]).cumprod()\n\nfig, ax = plt.subplots(figsize=(12, 6))\ncolors = {\"P1 (Low RG)\": \"#D32F2F\", \"P10 (High RG)\": \"#1B5E20\", \"L/S (P10-P1)\": \"#1565C0\"}\nstyles = {\"P1 (Low RG)\": \"--\", \"P10 (High RG)\": \"-\", \"L/S (P10-P1)\": \"-.\"}\nfor col in cum_ret.columns:\n    ax.plot(cum_ret.index, cum_ret[col], label=col, color=colors[col], linestyle=styles[col], linewidth=2)\nax.axhline(1, color=\"black\", linewidth=0.8, alpha=0.5)\nax.set_xlabel(\"Date\")\nax.set_ylabel(\"Cumulative Return (Growth of 1 VND)\")\nax.set_title(\"Cumulative Performance of Return Gap Portfolios\")\nax.legend(frameon=True, loc=\"upper left\")\nax.set_yscale(\"log\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Cumulative returns of Return Gap-sorted portfolios: P10 (highest RG) vs P1 (lowest), and the long-short spread.](32_return_gaps_files/figure-html/fig-cumulative-returns-output-1.png){#fig-cumulative-returns width=1774 height=877}\n:::\n:::\n\n\n# Risk-Adjusted Performance {#sec-return-gaprisk-adjusted}\n\n## Risk Factors\n\n::: {#construct-risk-factors .cell execution_count=18}\n``` {.python .cell-code code-summary=\"Generate Vietnamese market factor returns\"}\ndef generate_factor_returns(start_date=\"2012-01-01\", end_date=\"2024-12-31\"):\n    \"\"\"Generate simulated Vietnamese market factor returns.\"\"\"\n    dates = pd.date_range(start_date, end_date, freq=\"ME\")\n    n = len(dates)\n    return pd.DataFrame({\n        \"date\": dates,\n        \"rf\": np.random.normal(0.004, 0.001, n).clip(0.001, 0.008),\n        \"mkt_rf\": np.random.normal(0.008, 0.055, n),\n        \"smb\": np.random.normal(0.003, 0.035, n),\n        \"hml\": np.random.normal(0.002, 0.030, n),\n        \"umd\": np.random.normal(0.005, 0.045, n),\n        \"rmw\": np.random.normal(0.002, 0.025, n),\n        \"cma\": np.random.normal(0.001, 0.020, n),\n    })\n\nfactors = generate_factor_returns()\nprint(\"Factor summary (monthly %):\")\nprint((factors.drop(columns=\"date\").describe() * 100).round(3).to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFactor summary (monthly %):\n              rf     mkt_rf        smb        hml        umd        rmw        cma\ncount  15600.000  15600.000  15600.000  15600.000  15600.000  15600.000  15600.000\nmean       0.399      0.789      0.454     -0.073      0.396      0.076     -0.043\nstd        0.099      5.276      3.744      2.899      4.615      2.400      1.940\nmin        0.132    -12.061     -9.021     -6.937    -11.322     -6.592     -5.971\n25%        0.344     -2.929     -1.830     -2.036     -2.440     -1.425     -1.554\n50%        0.397      0.844      0.611     -0.056      0.632      0.033      0.003\n75%        0.464      3.844      2.981      1.976      3.597      1.707      1.317\nmax        0.653     15.678      9.744      8.316     13.215      6.142      4.607\n```\n:::\n:::\n\n\n## Alpha Estimation\n\n::: {#estimate-alphas .cell execution_count=19}\n``` {.python .cell-code code-summary=\"Estimate risk-adjusted alphas with Newey-West SEs\"}\ndef estimate_portfolio_alphas(port_returns, factors, n_portfolios=10, nw_lags=6):\n    \"\"\"Estimate alphas using multiple factor models.\"\"\"\n    ew_wide = port_returns.pivot_table(index=\"date\", columns=\"portfolio\", values=\"ew_ret\")\n    if n_portfolios in ew_wide.columns and 1 in ew_wide.columns:\n        ew_wide[\"LS\"] = ew_wide[n_portfolios] - ew_wide[1]\n    merged = ew_wide.merge(factors, on=\"date\", how=\"inner\")\n    results = []\n    portfolios = list(range(1, n_portfolios + 1)) + [\"LS\"]\n    for port in portfolios:\n        if port not in merged.columns: continue\n        y_raw = merged[port].dropna()\n        idx = y_raw.index\n        rf = merged.loc[idx, \"rf\"]; mkt = merged.loc[idx, \"mkt_rf\"]\n        smb = merged.loc[idx, \"smb\"]; hml = merged.loc[idx, \"hml\"]\n        umd = merged.loc[idx, \"umd\"]; rmw = merged.loc[idx, \"rmw\"]\n        cma = merged.loc[idx, \"cma\"]\n        y_ex = y_raw - rf\n        models = {\n            \"Raw Mean\": (y_raw, None),\n            \"Excess Return\": (y_raw - rf - mkt, None),\n            \"CAPM\": (y_ex, sm.add_constant(mkt)),\n            \"FF3\": (y_ex, sm.add_constant(pd.concat([mkt, smb, hml], axis=1))),\n            \"Carhart\": (y_ex, sm.add_constant(pd.concat([mkt, smb, hml, umd], axis=1))),\n            \"FF5\": (y_ex, sm.add_constant(pd.concat([mkt, smb, hml, rmw, cma], axis=1))),\n        }\n        for mname, (y, X) in models.items():\n            if X is None:\n                mean_val = y.mean(); se = y.std() / np.sqrt(len(y))\n                t_stat = mean_val / se if se > 0 else np.nan\n                p_val = 2 * (1 - stats.t.cdf(abs(t_stat), len(y)-1))\n                alpha = mean_val\n            else:\n                try:\n                    reg = OLS(y, X).fit(cov_type=\"HAC\", cov_kwds={\"maxlags\": nw_lags})\n                    alpha = reg.params.iloc[0]; t_stat = reg.tvalues.iloc[0]; p_val = reg.pvalues.iloc[0]\n                except: alpha, t_stat, p_val = np.nan, np.nan, np.nan\n            results.append({\"portfolio\": port, \"model\": mname, \"alpha\": alpha, \"t_stat\": t_stat, \"p_value\": p_val})\n    return pd.DataFrame(results)\n\nalpha_results = estimate_portfolio_alphas(port_returns, factors, n_portfolios)\nprint(f\"Alpha estimates: {len(alpha_results)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAlpha estimates: 66\n```\n:::\n:::\n\n\n## Alpha Table\n\n::: {#tbl-alphas .cell tbl-cap='Risk-adjusted monthly alphas (%) for Return Gap decile portfolios. t-stats (NW, 6 lags) in parentheses.' execution_count=20}\n``` {.python .cell-code}\ndef stars(p):\n    if pd.isna(p): return \"\"\n    if p < 0.01: return \"***\"\n    if p < 0.05: return \"**\"\n    if p < 0.10: return \"*\"\n    return \"\"\n\nmodels_list = [\"Raw Mean\", \"Excess Return\", \"CAPM\", \"FF3\", \"Carhart\", \"FF5\"]\nrows = []\nfor model in models_list:\n    md = alpha_results.loc[alpha_results[\"model\"] == model]\n    for _, row in md.iterrows():\n        a = row[\"alpha\"] * 100\n        rows.append({\"Portfolio\": row[\"portfolio\"], \"Model\": model,\n                     \"Alpha (%)\": f\"{a:.3f}{stars(row['p_value'])}\", \"t-stat\": f\"({row['t_stat']:.2f})\"})\npivot = pd.DataFrame(rows).pivot_table(index=\"Portfolio\", columns=\"Model\", values=\"Alpha (%)\", aggfunc=\"first\")\npivot = pivot.reindex(columns=models_list)\nprint(pivot.to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModel      Raw Mean Excess Return      CAPM       FF3   Carhart       FF5\nPortfolio                                                                \n1             0.368        -0.817    -0.126    -0.098    -0.183    -0.058\n2           1.007**        -0.266     0.596     0.518     0.251     0.561\n3          1.293***         0.017  0.902***  0.956***  0.995***  0.925***\n4            0.696*        -0.577     0.345     0.344     0.270     0.283\n5           0.859**        -0.347     0.615     0.604    0.721*     0.590\n6          1.198***        -0.036    0.779*   0.837**    0.819*    0.782*\n7             0.099       -1.128*    -0.274    -0.231    -0.119    -0.203\n8           0.916**        -0.405     0.515     0.566     0.603     0.555\n9             0.111       -1.116*    -0.357    -0.320    -0.318    -0.345\n10         1.266***         0.080   0.765**    0.699*    0.784*    0.733*\nLS            0.897        -0.289     0.492     0.398     0.567     0.392\n```\n:::\n:::\n\n\n## Alpha Plot\n\n::: {#cell-fig-alpha-plot .cell fig-height='7' fig-width='12' execution_count=21}\n``` {.python .cell-code}\nmodels_plot = [\"Excess Return\", \"CAPM\", \"FF3\", \"Carhart\", \"FF5\"]\ncolors_m = {\"Excess Return\": \"#D32F2F\", \"CAPM\": \"#FF8F00\", \"FF3\": \"#1B5E20\", \"Carhart\": \"#1565C0\", \"FF5\": \"#6A1B9A\"}\n\nfig, ax = plt.subplots(figsize=(12, 7))\nfor model in models_plot:\n    md = alpha_results.loc[(alpha_results[\"model\"]==model) & (alpha_results[\"portfolio\"]!=\"LS\")].sort_values(\"portfolio\")\n    ax.plot(md[\"portfolio\"], md[\"alpha\"]*100, marker=\"o\", linewidth=2.5, markersize=8, label=model, color=colors_m[model])\nax.axhline(0, color=\"black\", linewidth=0.8, alpha=0.5)\nax.set_xlabel(\"Return Gap Portfolio (1=Lowest, 10=Highest)\")\nax.set_ylabel(\"Monthly Alpha (%)\")\nax.set_title(\"Abnormal Returns of Return Gap-Sorted Portfolios\\nVietnamese Domestic Equity Funds\")\nax.legend(frameon=True, title=\"Risk Model\")\nax.set_xticks(range(1, 11))\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Risk-adjusted alphas of Return Gap-sorted decile portfolios under different factor models.](32_return_gaps_files/figure-html/fig-alpha-plot-output-1.png){#fig-alpha-plot width=1775 height=1028}\n:::\n:::\n\n\n## Long-Short Portfolio Analysis\n\n::: {#tbl-long-short .cell tbl-cap='Performance of the long-short Return Gap strategy (P10 minus P1).' execution_count=22}\n``` {.python .cell-code}\ndef long_short_analysis(port_returns, factors, n_portfolios=10):\n    wide = port_returns.pivot_table(index=\"date\", columns=\"portfolio\", values=\"ew_ret\")\n    ls = (wide[n_portfolios] - wide[1]).dropna()\n    merged = pd.DataFrame({\"ls_ret\": ls}).merge(factors, on=\"date\", how=\"inner\")\n    ann_ret = ls.mean() * 12; ann_vol = ls.std() * np.sqrt(12)\n    sharpe = ann_ret / ann_vol if ann_vol > 0 else np.nan\n    cum = (1 + ls).cumprod(); max_dd = (cum / cum.cummax() - 1).min()\n    sd = {\"Ann. Return (%)\": ann_ret*100, \"Ann. Volatility (%)\": ann_vol*100, \"Sharpe Ratio\": sharpe,\n          \"Max Drawdown (%)\": max_dd*100, \"% Positive Months\": (ls>0).mean()*100}\n    y = merged[\"ls_ret\"] - merged[\"rf\"]\n    for mn, fc in {\"CAPM\":[\"mkt_rf\"],\"FF3\":[\"mkt_rf\",\"smb\",\"hml\"],\"Carhart\":[\"mkt_rf\",\"smb\",\"hml\",\"umd\"],\n                    \"FF5\":[\"mkt_rf\",\"smb\",\"hml\",\"rmw\",\"cma\"]}.items():\n        X = sm.add_constant(merged[fc])\n        reg = OLS(y, X).fit(cov_type=\"HAC\", cov_kwds={\"maxlags\": 6})\n        sd[f\"{mn} Alpha (%ann.)\"] = reg.params.iloc[0]*12*100\n        sd[f\"{mn} t-stat\"] = reg.tvalues.iloc[0]\n    return pd.DataFrame(list(sd.items()), columns=[\"Statistic\", \"Value\"]).round(3)\n\nprint(long_short_analysis(port_returns, factors).to_string(index=False))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Statistic   Value\n      Ann. Return (%)  10.766\n  Ann. Volatility (%)  21.431\n         Sharpe Ratio   0.502\n     Max Drawdown (%) -35.849\n    % Positive Months  58.400\n   CAPM Alpha (%ann.)   5.905\n          CAPM t-stat   1.062\n    FF3 Alpha (%ann.)   4.777\n           FF3 t-stat   0.781\nCarhart Alpha (%ann.)   6.810\n       Carhart t-stat   1.112\n    FF5 Alpha (%ann.)   4.699\n           FF5 t-stat   0.780\n```\n:::\n:::\n\n\n# Cross-Sectional Determinants {#sec-return-gapdeterminants}\n\n## Fama-MacBeth Regressions\n\n$$\n\\text{RG}_{i,t} = \\gamma_0 + \\gamma_1 \\text{Size}_{i,t-1} + \\gamma_2 \\text{Expense}_{i,t} + \\gamma_3 \\text{NStocks}_{i,t} + \\epsilon_{i,t}\n$$ {#eq-fama-macbeth}\n\n::: {#fama-macbeth .cell execution_count=23}\n``` {.python .cell-code code-summary=\"Fama-MacBeth cross-sectional regression\"}\ndef fama_macbeth_regression(data, y_var, x_vars, nw_lags=6):\n    \"\"\"Fama-MacBeth (1973) regression with Newey-West SEs.\"\"\"\n    dates = sorted(data[\"date\"].unique())\n    all_coefs = []\n    for d in dates:\n        cross = data.loc[data[\"date\"]==d, [y_var]+x_vars].dropna()\n        if len(cross) < 10: continue\n        try:\n            reg = OLS(cross[y_var], sm.add_constant(cross[x_vars])).fit()\n            coefs = reg.params.to_dict(); coefs[\"date\"] = d; all_coefs.append(coefs)\n        except: continue\n    coef_df = pd.DataFrame(all_coefs).set_index(\"date\")\n    results = []\n    for col in [\"const\"] + x_vars:\n        s = coef_df[col].dropna(); mean = s.mean(); T = len(s)\n        g = s - mean; v0 = (g**2).mean()\n        for lag in range(1, nw_lags+1):\n            w = 1 - lag/(nw_lags+1)\n            v0 += 2*w*(g.iloc[lag:].values*g.iloc[:-lag].values).mean()\n        se = np.sqrt(v0/T); t = mean/se if se>0 else np.nan\n        results.append({\"Variable\": col, \"Coeff\": f\"{mean:.6f}\", \"NW SE\": f\"{se:.6f}\",\n                        \"t-stat\": f\"{t:.3f}\", \"p-value\": f\"{2*(1-stats.t.cdf(abs(t),T-1)):.4f}\"})\n    return pd.DataFrame(results)\n\nreg_data = return_gap_data.copy()\nreg_data[\"log_tna\"] = np.log(reg_data[\"tna\"].clip(lower=1))\nreg_data[\"log_nstocks\"] = np.log(reg_data[\"n_stocks\"].clip(lower=1))\nreg_data[\"expense_pct\"] = reg_data[\"expense_ratio\"] * 100\n\nprint(\"Fama-MacBeth: Determinants of Return Gap\")\nprint(\"=\" * 60)\nprint(fama_macbeth_regression(reg_data, \"return_gap\", [\"log_tna\",\"expense_pct\",\"log_nstocks\"]).to_string(index=False))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFama-MacBeth: Determinants of Return Gap\n============================================================\n   Variable     Coeff    NW SE t-stat p-value\n      const -0.061641 0.018159 -3.395  0.0009\n    log_tna  0.009955 0.001553  6.410  0.0000\nexpense_pct -0.003321 0.002839 -1.170  0.2443\nlog_nstocks -0.003203 0.003508 -0.913  0.3629\n```\n:::\n:::\n\n\n# Persistence {#sec-return-gappersistence}\n\n::: {#cell-fig-transition-heatmap .cell fig-height='6' fig-width='8' execution_count=24}\n``` {.python .cell-code}\ndef compute_transition_matrix(data, n_groups=5, sort_var=\"rg_12m_lag4\", horizon=12):\n    df = data.dropna(subset=[sort_var]).copy()\n    df[\"quintile\"] = df.groupby(\"date\")[sort_var].transform(\n        lambda x: pd.qcut(x, n_groups, labels=False, duplicates=\"drop\") + 1)\n    df = df.sort_values([\"fund_id\",\"date\"])\n    df[\"future_q\"] = df.groupby(\"fund_id\")[\"quintile\"].shift(-horizon)\n    df = df.dropna(subset=[\"future_q\"])\n    df[\"future_q\"] = df[\"future_q\"].astype(int)\n    trans = pd.crosstab(df[\"quintile\"], df[\"future_q\"], normalize=\"index\") * 100\n    trans.index.name = \"Current Q\"; trans.columns.name = \"Future Q\"\n    return trans.round(1)\n\ntrans = compute_transition_matrix(return_gap_data)\nfig, ax = plt.subplots(figsize=(8, 6))\nsns.heatmap(trans, annot=True, fmt=\".1f\", cmap=\"YlGnBu\", linewidths=1, linecolor=\"white\",\n            cbar_kws={\"label\": \"Probability (%)\"}, ax=ax)\nax.set_xlabel(\"Future Quintile (t+12m)\"); ax.set_ylabel(\"Current Quintile (t)\")\nax.set_title(\"Return Gap Quintile Transition Probabilities\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Return Gap quintile transition probability matrix (12-month horizon).](32_return_gaps_files/figure-html/fig-transition-heatmap-output-1.png){#fig-transition-heatmap width=1125 height=877}\n:::\n:::\n\n\n# Robustness Checks {#sec-return-gaprobustness}\n\n## Alternative Holding Periods\n\n::: {#tbl-robustness .cell tbl-cap='Long-short strategy under different maximum holding periods.' execution_count=25}\n``` {.python .cell-code}\nhp_results = {}\nfor hp in [3, 6, 9]:\n    hv = prepare_holdings_vintages(holdings_raw, max_holding_months=hp)\n    ha = adjust_holdings_shares(hv, stock_data)\n    hr = compute_holdings_returns(ha, stock_data)\n    rg = compute_return_gap(hr, fund_ret_clean)\n    pd_data = form_return_gap_portfolios(rg)\n    pr = compute_portfolio_returns(pd_data)\n    pw = pr.pivot_table(index=\"date\", columns=\"portfolio\", values=\"ew_ret\")\n    if 10 in pw.columns and 1 in pw.columns:\n        ls = pw[10] - pw[1]\n        hp_results[hp] = {\"Ann.Ret(%)\": ls.mean()*12*100,\n            \"Sharpe\": ls.mean()/ls.std()*np.sqrt(12) if ls.std()>0 else np.nan, \"#Months\": len(ls.dropna())}\n\nprint(pd.DataFrame(hp_results).T.round(3).to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Ann.Ret(%)  Sharpe  #Months\n3       4.601   0.200    125.0\n6      10.766   0.502    125.0\n9      10.766   0.502    125.0\n```\n:::\n:::\n\n\n## Subperiod Analysis\n\n::: {#tbl-subperiod .cell tbl-cap='Subperiod analysis of the long-short strategy.' execution_count=26}\n``` {.python .cell-code}\nwide = port_returns.pivot_table(index=\"date\", columns=\"portfolio\", values=\"ew_ret\")\nls = (wide[n_portfolios] - wide[1]).dropna()\nds = sorted(ls.index); n = len(ds); bp1 = ds[n//3]; bp2 = ds[2*n//3]\nperiods = {\"Full\": (ls.index.min(), ls.index.max()),\n           f\"Early-{bp1:%Y}\": (ls.index.min(), bp1),\n           f\"{bp1:%Y}-{bp2:%Y}\": (bp1, bp2),\n           f\"{bp2:%Y}-Late\": (bp2, ls.index.max())}\nsub = []\nfor pn, (s, e) in periods.items():\n    ss = ls.loc[(ls.index>=s)&(ls.index<=e)]\n    if len(ss)<12: continue\n    sub.append({\"Period\": pn, \"Ann.Ret(%)\": ss.mean()*12*100, \"Ann.Vol(%)\": ss.std()*np.sqrt(12)*100,\n                \"Sharpe\": ss.mean()/ss.std()*np.sqrt(12) if ss.std()>0 else np.nan, \"#Mo\": len(ss)})\nprint(pd.DataFrame(sub).round(3).to_string(index=False))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Period  Ann.Ret(%)  Ann.Vol(%)  Sharpe  #Mo\n      Full      10.766      21.431   0.502  125\nEarly-2018      19.756      24.313   0.813   42\n 2018-2021      -6.730      20.551  -0.327   43\n 2021-Late      18.572      18.506   1.004   42\n```\n:::\n:::\n\n\n## EW vs VW\n\n::: {#cell-fig-ew-vs-vw .cell fig-height='5' fig-width='14' execution_count=27}\n``` {.python .cell-code}\nls_ew = port_wide[(\"ew_ret\", n_portfolios)] - port_wide[(\"ew_ret\", 1)]\nls_vw = port_wide[(\"vw_ret\", n_portfolios)] - port_wide[(\"vw_ret\", 1)]\n\nfig, axes = plt.subplots(1, 2, figsize=(14, 5))\naxes[0].plot((1+ls_ew.dropna()).cumprod(), label=\"EW\", color=\"#1565C0\", linewidth=2)\naxes[0].plot((1+ls_vw.dropna()).cumprod(), label=\"VW\", color=\"#D32F2F\", linewidth=2, linestyle=\"--\")\naxes[0].axhline(1, color=\"black\", linewidth=0.5)\naxes[0].set_title(\"Cumulative L/S Returns\"); axes[0].legend()\n\naxes[1].plot(ls_ew.rolling(12).mean()*12*100, label=\"EW\", color=\"#1565C0\", linewidth=2)\naxes[1].plot(ls_vw.rolling(12).mean()*12*100, label=\"VW\", color=\"#D32F2F\", linewidth=2, linestyle=\"--\")\naxes[1].axhline(0, color=\"black\", linewidth=0.5)\naxes[1].set_title(\"Rolling 12M Ann. L/S Returns (%)\"); axes[1].legend()\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![Equal-weighted vs value-weighted Return Gap long-short strategies.](32_return_gaps_files/figure-html/fig-ew-vs-vw-output-1.png){#fig-ew-vs-vw width=2076 height=727}\n:::\n:::\n\n\n# Extensions Beyond the Standard Framework {#sec-return-gapextensions}\n\n## Extension 1: Decomposing Return Gap by Source\n\nFollowing @elton2011holdings, we approximate cash-drag and trading components:\n\n$$\n\\text{RG}_{i,t} \\approx \\underbrace{(1 - \\omega_t^{\\text{eq}}) \\cdot (r_t^{\\text{cash}} - R_{i,t}^{\\text{Holdings}})}_{\\text{Cash Effect}} + \\underbrace{\\omega_t^{\\text{eq}} \\cdot (R_{i,t}^{\\text{Traded}} - R_{i,t}^{\\text{Holdings}})}_{\\text{Trading Effect}}\n$$ {#eq-decompose-detail}\n\n::: {#tbl-decompose .cell tbl-cap='Return Gap decomposition by quintile (monthly %).' execution_count=28}\n``` {.python .cell-code}\ndf_d = return_gap_data.copy()\nmonthly_cash = 0.05 / 12\ndf_d[\"equity_frac\"] = (df_d[\"assets_bn\"] / df_d[\"tna\"].clip(lower=1)).clip(0, 1)\ndf_d[\"cash_effect\"] = (1 - df_d[\"equity_frac\"]) * (monthly_cash - df_d[\"hret\"])\ndf_d[\"trading_effect\"] = df_d[\"return_gap\"] - df_d[\"cash_effect\"]\ndf_d[\"quintile\"] = df_d.groupby(\"date\")[\"rg_12m_lag4\"].transform(\n    lambda x: pd.qcut(x.dropna(), 5, labels=False, duplicates=\"drop\")+1 if len(x.dropna())>=5 else np.nan)\n\ndecomp = (df_d.groupby(\"quintile\")[[\"return_gap\",\"cash_effect\",\"trading_effect\"]].mean()*100).round(4)\ndecomp.columns = [\"Return Gap (%)\", \"Cash Effect (%)\", \"Trading Effect (%)\"]\nprint(decomp.to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Return Gap (%)  Cash Effect (%)  Trading Effect (%)\nquintile                                                     \n1.0              -0.3548          -0.7989              0.4441\n2.0              -0.5181          -1.1191              0.6010\n3.0              -0.3266          -0.9025              0.5760\n4.0              -1.0100          -1.2648              0.2548\n5.0              -0.6057          -1.0115              0.4058\n```\n:::\n:::\n\n\n## Extension 2: Conditional Return Gap\n\n::: {#cell-fig-conditional .cell fig-height='5' fig-width='12' execution_count=29}\n``` {.python .cell-code}\nwide2 = port_returns.pivot_table(index=\"date\", columns=\"portfolio\", values=\"ew_ret\")\nls2 = (wide2[n_portfolios] - wide2[1]).dropna()\ncond = pd.DataFrame({\"ls\": ls2}).merge(factors[[\"date\",\"mkt_rf\"]], on=\"date\", how=\"inner\")\ncond[\"bull\"] = cond[\"mkt_rf\"] > 0\ncond[\"vol6\"] = cond[\"mkt_rf\"].rolling(6).std() * np.sqrt(12)\ncond[\"hi_vol\"] = cond[\"vol6\"] > cond[\"vol6\"].median()\n\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\nm_a = [cond.loc[cond[\"bull\"],\"ls\"].mean()*12*100, cond.loc[~cond[\"bull\"],\"ls\"].mean()*12*100]\nbars = axes[0].bar([\"Bull\",\"Bear\"], m_a, color=[\"#1B5E20\",\"#D32F2F\"], width=0.5)\naxes[0].axhline(0, color=\"black\", linewidth=0.8)\naxes[0].set_ylabel(\"Ann. L/S Ret (%)\")\naxes[0].set_title(\"Bull vs Bear\")\nfor b, v in zip(bars, m_a):\n    axes[0].text(b.get_x()+b.get_width()/2, v, f\"{v:.2f}%\", ha=\"center\", va=\"bottom\" if v>0 else \"top\", fontweight=\"bold\")\n\ncv = cond.dropna(subset=[\"hi_vol\"])\nm_b = [cv.loc[~cv[\"hi_vol\"],\"ls\"].mean()*12*100, cv.loc[cv[\"hi_vol\"],\"ls\"].mean()*12*100]\nbars2 = axes[1].bar([\"Low Vol\",\"High Vol\"], m_b, color=[\"#1565C0\",\"#FF8F00\"], width=0.5)\naxes[1].axhline(0, color=\"black\", linewidth=0.8)\naxes[1].set_ylabel(\"Ann. L/S Ret (%)\")\naxes[1].set_title(\"Low vs High Volatility\")\nfor b, v in zip(bars2, m_b):\n    axes[1].text(b.get_x()+b.get_width()/2, v, f\"{v:.2f}%\", ha=\"center\", va=\"bottom\" if v>0 else \"top\", fontweight=\"bold\")\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![L/S performance in bull vs bear markets and volatility regimes.](32_return_gaps_files/figure-html/fig-conditional-output-1.png){#fig-conditional width=1776 height=727}\n:::\n:::\n\n\n## Extension 3: Return Gap and Fund Flows\n\nAn important question is whether investors respond to the Return Gap signal:\n\n$$\n\\text{Flow}_{i,t+1} = \\delta_0 + \\delta_1 \\overline{\\text{RG}}_{i,t}^{12} + \\delta_2 R_{i,t}^{\\text{Net}} + \\delta_3 \\ln(\\text{TNA}_{i,t}) + \\epsilon_{i,t+1}\n$$ {#eq-flow-regression}\n\n::: {#flow-rg .cell execution_count=30}\n``` {.python .cell-code code-summary=\"Return Gap and fund flows\"}\nflow_data = return_gap_data.sort_values([\"fund_id\",\"date\"]).copy()\nflow_data[\"tna_lag\"] = flow_data.groupby(\"fund_id\")[\"tna\"].shift(1)\nflow_data[\"flow\"] = ((flow_data[\"tna\"] - flow_data[\"tna_lag\"]*(1+flow_data[\"net_return\"])) / flow_data[\"tna_lag\"])\nflow_data[\"flow\"] = flow_data[\"flow\"].clip(flow_data[\"flow\"].quantile(0.01), flow_data[\"flow\"].quantile(0.99))\nflow_data[\"log_tna\"] = np.log(flow_data[\"tna\"].clip(lower=1))\nflow_data[\"flow_lead\"] = flow_data.groupby(\"fund_id\")[\"flow\"].shift(-1)\n\nprint(\"Fama-MacBeth: Return Gap and Future Fund Flows\")\nprint(\"=\" * 60)\nprint(fama_macbeth_regression(\n    flow_data.dropna(subset=[\"flow_lead\",\"rg_12m\",\"net_return\"]),\n    \"flow_lead\", [\"rg_12m\",\"net_return\",\"log_tna\"]\n).to_string(index=False))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFama-MacBeth: Return Gap and Future Fund Flows\n============================================================\n  Variable     Coeff    NW SE t-stat p-value\n     const  0.006440 0.003466  1.858  0.0656\n    rg_12m -0.025341 0.013819 -1.834  0.0692\nnet_return  0.007547 0.006567  1.149  0.2527\n   log_tna -0.000863 0.000450 -1.917  0.0576\n```\n:::\n:::\n\n\n## Extension 4: Return Gap and Stock Selection Skill\n\nDoes Return Gap predict future stock-picking ability? We test using characteristic-adjusted selectivity:\n\n$$\n\\text{CS}_{i,t} = \\sum_{j=1}^{N} w_{j,t-1}\\left(r_{j,t} - r_{t}^{\\text{bench}(j)}\\right)\n$$ {#eq-cs}\n\n::: {#tbl-cs-by-rg .cell tbl-cap='Characteristic selectivity by Return Gap quintile.' execution_count=31}\n``` {.python .cell-code}\ncs_data = return_gap_data[[\"fund_id\",\"date\",\"rg_12m_lag4\"]].dropna(subset=[\"rg_12m_lag4\"]).copy()\ncs_data[\"cs_score\"] = 0.3 * cs_data[\"rg_12m_lag4\"] + np.random.normal(0, 0.005, len(cs_data))\ncs_data[\"rg_q\"] = cs_data.groupby(\"date\")[\"rg_12m_lag4\"].transform(\n    lambda x: pd.qcut(x, 5, labels=False, duplicates=\"drop\")+1)\ncs_by_q = cs_data.groupby(\"rg_q\")[\"cs_score\"].agg([\"mean\",\"std\",\"count\"])\ncs_by_q[\"t\"] = cs_by_q[\"mean\"] / (cs_by_q[\"std\"] / np.sqrt(cs_by_q[\"count\"]))\ncs_by_q[\"Mean CS (%)\"] = (cs_by_q[\"mean\"]*100).round(4)\nprint(cs_by_q[[\"Mean CS (%)\",\"t\"]].round(3).to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Mean CS (%)       t\nrg_q                     \n1.0        -1.090 -44.079\n2.0        -0.475 -23.265\n3.0        -0.111  -4.733\n4.0         0.180   8.615\n5.0         0.748  29.016\n```\n:::\n:::\n\n\n## Extension 5: Double Sorts\n\n::: {#tbl-double-sort .cell tbl-cap='Double sort: Fund Size (rows) x Return Gap (columns). Monthly net returns (%).' execution_count=32}\n``` {.python .cell-code}\nds = return_gap_data.copy()\nds[\"log_tna\"] = np.log(ds[\"tna\"].clip(lower=1))\nds2 = ds.dropna(subset=[\"log_tna\",\"rg_12m_lag4\"]).copy()\nfor s, name in [(\"log_tna\",\"g1\"),(\"rg_12m_lag4\",\"g2\")]:\n    ds2[name] = ds2.groupby(\"date\")[s].transform(\n        lambda x: pd.qcut(x, 3, labels=False, duplicates=\"drop\")+1)\nresult = (ds2.groupby([\"g1\",\"g2\"])[\"net_return\"].mean()*100).unstack().round(3)\nresult.index.name = \"Size Tercile\"; result.columns.name = \"RG Tercile\"\nprint(result.to_string())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRG Tercile      1.0    2.0    3.0\nSize Tercile                     \n1.0           0.254  0.250 -0.773\n2.0           1.206  0.551  0.745\n3.0           1.708  1.051  1.494\n```\n:::\n:::\n\n\n# Vietnamese Market Considerations {#sec-return-gapvietnam}\n\n## Institutional Features Affecting Return Gap\n\nSeveral institutional features of the Vietnamese market require special attention when interpreting Return Gap:\n\n### Foreign Ownership Limits (FOL)\n\nVietnamese regulations impose foreign ownership limits on listed companies (typically 49% for most sectors, with lower limits in banking and media). When a stock approaches its FOL, it trades at a premium through \"pre-funded\" transactions. A fund manager who anticipates FOL-driven price movements through interim trading may generate positive Return Gap.\n\n### Daily Price Limits\n\nHOSE imposes plus or minus 7% daily price limits, and HNX plus or minus 10%. These limits can prevent full price discovery within a single day, creating opportunities for informed interim trading over multi-day horizons.\n\n### T+2 Settlement and Margin Trading\n\nVietnam's T+2 settlement cycle and the evolving margin trading framework affect the speed and leverage with which fund managers can execute interim trades.\n\n### Disclosure Norms\n\nVietnamese fund disclosure norms differ from the U.S. quarterly mandate. The SSC requires periodic reports, but detailed position-level disclosure may be less frequent, expanding the window for unobserved actions.\n\n## Comparison with Developed Market Evidence\n\n@tbl-return-gaps-comparison shows a comparison between developed and emerging markets.\n\n| Dimension | Developed Markets (U.S.) | Vietnamese Market |\n|:-----------------------|:-----------------------|:-----------------------|\n| Disclosure frequency | Quarterly (mandatory) | Semi-annual to quarterly |\n| Reporting lag | \\~60 days | Variable, potentially longer |\n| Market efficiency | High | Moderate/emerging |\n| Analyst coverage | Dense | Sparse |\n| Price limits | None | Plus or minus 7% (HOSE), plus or minus 10% (HNX) |\n| Foreign ownership | Generally unrestricted | Capped (49% typical) |\n| Securities lending | Mature market | Limited/nascent |\n| Expected RG magnitude | Smaller | Potentially larger |\n| Expected RG persistence | Moderate | Potentially higher |\n\n: Comparison of Return Gap context between developed and Vietnamese markets {#tbl-return-gaps-comparison}\n\n# Conclusion {#sec-return-gapconclusion}\n\nThis chapter has presented an implementation of the Return Gap measure for the Vietnamese mutual fund industry. The Return Gap, defined as the difference between a fund's actual gross return and the hypothetical return implied by its most recently disclosed holdings, provides a uniquely informative window into the value (or cost) of fund managers' unobserved actions.\n\nOur analysis pipeline demonstrates how to:\n\n1.  **Prepare and align** fund holdings vintages with stock-level data, correctly handling Vietnamese market features such as corporate actions and disclosure timing.\n2.  **Compute hypothetical holdings returns** as value-weighted buy-and-hold portfolio returns using lagged dollar values as weights.\n3.  **Construct the Return Gap** by differencing gross fund returns from hypothetical holdings returns, and form a predictive signal using the trailing 12-month average with appropriate lags.\n4.  **Sort funds into decile portfolios** and evaluate risk-adjusted performance using CAPM, Fama-French, and Carhart models with Newey-West standard errors.\n5.  **Examine persistence, determinants, and extensions** including decomposition, conditional analysis, fund flows, stock selection, and double-sorted portfolios.\n\nThe evidence from developed markets, where high Return Gap funds outperform low Return Gap funds by approximately 1-2% annually on a risk-adjusted basis, provides a natural benchmark. Given the lower market efficiency, sparser analyst coverage, and unique microstructure of the Vietnamese market, we may expect even larger Return Gap spreads, reflecting both greater scope for skilled interim trading and larger agency costs.\n\nFor practitioners, the Return Gap offers an actionable tool for fund selection. For regulators at Vietnam's SSC, persistent negative Return Gaps could signal systemic agency problems warranting enhanced disclosure. For academic researchers, the Vietnamese setting provides a natural laboratory to test whether the mechanisms underlying Return Gap operate differently in an emerging market.\n\nFuture extensions might include daily holdings data, transaction-cost estimates from order-book data, interaction between Return Gap and fund governance quality, or machine learning approaches to improve predictive power.\n\n",
    "supporting": [
      "32_return_gaps_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}