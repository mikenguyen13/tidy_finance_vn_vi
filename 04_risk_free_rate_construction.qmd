# Xây dựng lãi suất phi rủi ro tại Việt Nam

::: callout-note
Trong chương này, chúng ta sẽ giải quyết một vấn đề đơn giản nhưng quan trọng: làm thế nào để xây dựng chuỗi lãi suất phi rủi ro cho nghiên cứu tài chính thực nghiệm tại Việt Nam. Chúng ta sẽ đánh giá các chỉ số thay thế hiện có, chẳng hạn như lợi suất trái phiếu chính phủ, lãi suất liên ngân hàng qua đêm và lãi suất chính sách của Ngân hàng Nhà nước Việt Nam (SBV), phát triển các quy trình nội suy và điều chỉnh tần số, và định lượng độ nhạy của các kết quả định giá tài sản chính đối với việc lựa chọn chỉ số thay thế lãi suất phi rủi ro.
:::

Lãi suất phi rủi ro là con số quan trọng nhất trong lĩnh vực tài chính. Nó là cơ sở cho lợi nhuận vượt trội, lãi suất chiết khấu, phí bảo hiểm nhân tố, chi phí vốn chủ sở hữu, đánh giá hiệu suất và định giá phái sinh. Mặc dù đóng vai trò nền tảng như vậy, lãi suất phi rủi ro thường được coi là một con số cố định: một con số được lấy từ cơ sở dữ liệu và đưa vào các công thức mà không cần suy nghĩ thêm. Tại các thị trường phát triển với thị trường chứng khoán chính phủ sâu rộng và thanh khoản cao, cách tiếp cận hời hợt này thường không gây hại. Nhưng ở Việt Nam thì không phải vậy.

Thị trường trái phiếu của Việt Nam khá mỏng, phân mảnh và đặc trưng bởi việc phát hành trái phiếu chính phủ ngắn hạn không đều đặn. Không có một lãi suất phi rủi ro duy nhất, được chấp nhận rộng rãi, tương tự như lãi suất tín phiếu kho bạc kỳ hạn 1 tháng – vốn là nền tảng cho hầu hết các nghiên cứu định giá tài sản tại các thị trường phát triển. Thay vào đó, các nhà nghiên cứu phải lựa chọn giữa các chỉ số thay thế không hoàn hảo, mỗi chỉ số đều có những ưu điểm và hạn chế riêng. Sự lựa chọn này không hề đơn giản: các chỉ số thay thế khác nhau có thể tạo ra lợi nhuận vượt trội, phí bảo hiểm nhân tố và ước tính định giá khác nhau đáng kể.

Chương này trình bày một phương pháp tiếp cận có hệ thống để xây dựng lãi suất phi rủi ro. Chúng ta bắt đầu với các yêu cầu lý thuyết đối với một tài sản phi rủi ro, sau đó đánh giá các chỉ số thay thế hiện có của Việt Nam so với các yêu cầu này. Chúng ta xây dựng chuỗi lãi suất phi rủi ro hàng tháng theo các thông số kỹ thuật khác nhau, trình bày các kỹ thuật điều chỉnh tần số và nội suy, và tiến hành phân tích độ nhạy để định lượng ảnh hưởng của việc lựa chọn chỉ số thay thế đến các kết quả tiếp theo.

## Vai trò của lãi suất phi rủi ro trong tài chính

### Lợi nhuận vượt mức

Việc sử dụng cơ bản nhất của tỷ lệ không rủi ro là tính toán lợi nhuận vượt mức. Lợi nhuận vượt quá trên tài sản $i$ trong kỳ $t$ là:

$$
r_{i,t}^{e} = r_{i,t} - r_{f,t}
$$ {#eq-excess-return}

trong đó $r_{i,t}$ là lợi nhuận thô và $r_{f,t}$ là tỷ lệ không rủi ro trong cùng một khoảng thời gian, bằng cùng một loại tiền tệ và theo cùng một quy ước lãi kép. Lợi nhuận vượt mức cô lập khoản bồi thường cho rủi ro gánh chịu, loại bỏ lợi nhuận có thể kiếm được mà không phải chịu rủi ro.

Việc đo sai $r{f,t}$ trực tiếp làm ô nhiễm mọi quan sát lợi nhuận dư thừa và mở rộng ra, mọi số lượng bắt nguồn từ lợi nhuận vượt mức. Nếu $r_{f,t}$ bị thiên vị đi lên một cách có hệ thống, lợi nhuận vượt quá bị đánh giá thấp một cách có hệ thống, phí bảo hiểm nhân tố bị nén và chi phí vốn chủ sở hữu bị phóng đại.

### Phí bảo hiểm yếu tố

Trong mô hình ba yếu tố @Fama1993, phí bảo hiểm rủi ro thị trường là:

$$
\text{MKTRF}_t = r_{m,t} - r_{f,t}
$$ {#eq-mktrf}

trong đó $r_{m,t}$ là lợi suất thị trường được tính theo giá trị. Phần bù rủi ro theo quy mô (SMB) và giá trị (HML) được định nghĩa là lợi suất của các danh mục đầu tư mua-bán và không phụ thuộc trực tiếp vào $r_{f,t}$. Tuy nhiên, hệ số chặn (alpha) từ hồi quy chuỗi thời gian của lợi suất vượt trội của bất kỳ danh mục đầu tư nào dựa trên các yếu tố lại phụ thuộc vào $r_{f,t}$ thông qua biến phụ thuộc. Lãi suất phi rủi ro bị sai lệch sẽ làm dịch chuyển tất cả các alpha một cách đồng đều.

### Tỷ lệ chiết khấu và định giá

Mô hình dòng tiền chiết khấu định giá một công ty như sau:

$$
V_0 = \sum_{t=1}^{\infty} \frac{E[CF_t]}{(1 + r_{WACC})^t}
$$ {#eq-dcf}

trong đó chi phí vốn bình quân gia quyền (WACC) phụ thuộc vào chi phí vốn chủ sở hữu, do đó phụ thuộc vào tỷ lệ phi rủi ro thông qua Mô hình định giá tài sản vốn:

$$
r_{e} = r_f + \beta_i (\bar{r}_m - r_f)
$$ {#eq-capm-cost}

Sai số 100 điểm cơ bản trong $r_f$ sẽ ảnh hưởng đến chi phí vốn chủ sở hữu và có thể làm thay đổi giá trị hiện tại của dòng tiền dài hạn từ 10-20%, tùy thuộc vào đặc điểm thời gian đáo hạn.

### Đánh giá hiệu suất

Các thước đo hiệu suất được điều chỉnh theo rủi ro, chẳng hạn như hệ số Sharpe:

$$
\text{SR} = \frac{\bar{r}_p - \bar{r}_f}{\sigma(r_p - r_f)}
$$ {#eq-sharpe}

và alpha của Jensen:

$$
\alpha = \bar{r}_p - r_f - \hat{\beta}_p (\bar{r}_m - r_f)
$$ {#eq-jensen}

Cả hai đều phụ thuộc trực tiếp vào $r_f$. Tỷ lệ Sharpe đặc biệt nhạy cảm vì mẫu số (biến động lợi nhuận vượt mức) cũng bị ảnh hưởng bởi mức độ và sự thay đổi của $r_f$.

## "Không rủi ro" có nghĩa là gì trong thực tế?

Một tài sản thực sự không có rủi ro phải đáp ứng đồng thời bốn điều kiện (@tbl-rf-requirements).

| Điều kiện | Định nghĩa | Thử thách thực tế |
|--------------------|--------------------|--------------------------------|
| Không có rủi ro vỡ nợ | Tổ chức phát hành không thể không thanh toán | Chỉ nợ có chủ quyền bằng đồng tiền của chính mình mới đủ điều kiện |
| Dòng tiền đã biết | Khoản thanh toán là chắc chắn trước | Loại trừ các công cụ lãi suất thả nổi |
| Không có rủi ro tái đầu tư | Thời gian đáo hạn phù hợp với thời gian đầu tư | Yêu cầu chứng khoán không có phiếu giảm giá có kỳ hạn chính xác |
| Tính thanh khoản cao | Có thể giao dịch với chi phí thấp | Thị trường trái phiếu chính phủ mỏng thất bại trong bài kiểm tra này |

: Yêu cầu đối với tài sản không rủi ro {#tbl-rf-requirements}

Không có tài sản nào trong thế giới thực đáp ứng hoàn hảo cả bốn điều kiện. Ngay cả trong thị trường trái phiếu chính phủ sâu nhất, vẫn có một khoản phí thanh khoản cao hơn đối với chứng khoán ngoài hoạt động và lợi suất thuận tiện trong các đợt phát hành đang hoạt động [@krishnamurthy2012aggregate]. Câu hỏi thực tế là: công cụ hiện có nào gần nhất?

### Proxy lý tưởng

Proxy tỷ lệ không rủi ro lý tưởng cho nghiên cứu định giá tài sản thực nghiệm có các thuộc tính sau:

1. **Kỳ hạn ngắn**: Giảm thiểu rủi ro tái đầu tư và ô nhiễm phí bảo hiểm có kỳ hạn. Lựa chọn thông thường là đáo hạn 1 tháng.
2. **Được chính phủ hậu thuẫn**: Loại bỏ rủi ro tín dụng (bằng nội tệ).
3. **Giao dịch tích cực**: Đảm bảo rằng lợi nhuận quan sát được phản ánh các điều kiện thị trường hiện tại.
4. **Phát hành thường xuyên**: Cung cấp một chuỗi thời gian liên tục mà không có khoảng trống.
5. **Phương pháp nhất quán**: Tính toán năng suất rõ ràng và có thể so sánh theo thời gian.

## Proxy có sẵn tại Việt Nam

Cơ sở hạ tầng tài chính của Việt Nam cung cấp một số công cụ ứng cử viên, không có công cụ nào đáp ứng hoàn toàn tất cả các tiêu chí. Chúng tôi lần lượt đánh giá từng công cụ.

### Lợi suất trái phiếu chính phủ

Chính phủ Việt Nam phát hành trái phiếu trong một loạt các kỳ hạn thông qua Kho bạc Nhà nước và Thị trường Trái phiếu Việt Nam (VBM). Các đặc điểm chính (tbl-govt-bond-characteristics)

| Feature | Description |
|---|---|
| Issuer | State Treasury of Vietnam |
| Primary market | Auction through HNX |
| Available maturities | 1, 2, 3, 5, 7, 10, 15, 20, 30 years |
| Shortest benchmark | 1-year (sometimes shorter tenors via T-bills) |
| Coupon structure | Fixed, semi-annual |
| Issuance frequency | Regular weekly/bi-weekly auctions |
| Secondary market liquidity | Concentrated in 3-5 year segment; short end is thin |
| Data availability | Available through DataCore.vn |

: Vietnamese Government Bond Characteristics {#tbl-govt-bond-characteristics}

```{python}
#| label: tbl-govt-bond-characteristics
#| include: false
#| tbl-cap: "Vietnamese Government Bond Characteristics"
import pandas as pd

bond_chars = pd.DataFrame({
    "Feature": [
        "Issuer",
        "Primary market",
        "Available maturities",
        "Shortest benchmark",
        "Coupon structure",
        "Issuance frequency",
        "Secondary market liquidity",
        "Data availability"
    ],
    "Description": [
        "State Treasury of Vietnam",
        "Auction through HNX",
        "1, 2, 3, 5, 7, 10, 15, 20, 30 years",
        "1-year (sometimes shorter tenors via T-bills)",
        "Fixed, semi-annual",
        "Regular weekly/bi-weekly auctions",
        "Concentrated in 3-5 year segment; short end is thin",
        "Available through DataCore.vn"
    ]
})

bond_chars.style.hide(axis="index")
```

Hạn chế chính của lợi suất trái phiếu chính phủ khi được sử dụng như một thước đo lãi suất phi rủi ro là sự khan hiếm các chứng khoán có kỳ hạn ngắn. Trái phiếu kỳ hạn một năm là chuẩn mực được phát hành thường xuyên ngắn nhất, và lợi suất của chúng bao gồm một khoản phí kỳ hạn mà không có trong lãi suất phi rủi ro thực sự. Tín phiếu kho bạc (kỳ hạn < 1 năm) được phát hành không thường xuyên và với số lượng nhỏ, khiến chúng không phù hợp để sử dụng như một chuỗi liên tục.

### Lãi suất qua đêm liên ngân hàng

Thị trường liên ngân hàng Việt Nam thiết lập lãi suất cho vay qua đêm giữa các ngân hàng thương mại. Lãi suất qua đêm được Ngân hàng Nhà nước Việt Nam (SBV) công bố.

**Ưu điểm**: Thời hạn rất ngắn (qua đêm), tần suất cao (hàng ngày), phản ánh chi phí vay thực tế trong hệ thống tài chính.

**Hạn chế**: Phản ánh rủi ro tín dụng của ngành ngân hàng (rủi ro vỡ nợ liên ngân hàng, mặc dù nhỏ), có thể biến động mạnh trong thời kỳ khủng hoảng thanh khoản và không tương ứng với một công cụ tài chính không lãi suất có thể giao dịch được.

### Lãi suất chính sách của Ngân hàng Nhà nước (SBV)

Ngân hàng Nhà nước Việt Nam quy định một số tỷ giá hối đoái do chính phủ quản lý (@tbl-sbv-rates).

| Tỷ lệ | Vai trò | Tần suất thay đổi |
|------------------|------------------|------------------------------------|
| Lãi suất tái cấp vốn | Lãi suất cho vay của Ngân hàng Nhà nước Việt Nam (SBV) đối với các ngân hàng | Không thường xuyên (các cuộc họp chính sách) |
| Tỷ lệ chiết khấu | Tỷ lệ chiết khấu lại cho các loại giấy tờ đủ điều kiện | Không thường xuyên |
| Lãi suất cho vay qua đêm | Mức trần cho vay liên ngân hàng qua đêm | Không thường xuyên |
| Mức trần lãi suất tiền gửi | Lãi suất tối đa mà ngân hàng có thể trả cho tiền gửi | Không thường xuyên |

Lãi suất chính sách của Ngân hàng Nhà nước (SBV) {#tbl-sbv-rates}

**Ưu điểm**: Ổn định (ít thay đổi), phản ánh lập trường chính sách tiền tệ, có sẵn trong toàn bộ giai đoạn nghiên cứu.

**Hạn chế**: Không phải là lợi nhuận được giao dịch (tức là không nhà đầu tư nào thực sự có thể kiếm được lãi suất theo chính sách). Đại diện cho mục tiêu quản lý, không phải giá cân bằng thị trường. Phản ứng với các điều kiện kinh tế vĩ mô với độ trễ.

### Lãi suất tiền gửi tiết kiệm

Các ngân hàng thương mại cung cấp tiền gửi có kỳ hạn với lãi suất chịu sự giám sát của Ngân hàng Nhà nước Việt Nam (SBV). Lãi suất tiền gửi ngắn hạn (1 tháng hoặc 3 tháng) đôi khi được sử dụng như một thước đo không chính thức cho lãi suất không rủi ro trong thực tiễn.

**Ưu điểm**: Mang lại lợi nhuận đầu tư cho các nhà đầu tư nhỏ, dễ dàng tiếp cận.

**Hạn chế**: Phụ thuộc vào rủi ro tín dụng của ngân hàng, có thể khác nhau giữa các ngân hàng, mức trần tạo ra một mức giá có thể không phản ánh tỷ lệ cân bằng thực tế, không được tiêu chuẩn hóa cho mục đích nghiên cứu.

### So sánh tóm tắt

```{python}
#| label: tbl-proxy-comparison
#| include: false
#| tbl-cap: "Comparison of Risk-Free Rate Proxies for Vietnam"
comparison = pd.DataFrame({
    "Proxy": [
        "1-Year Government Bond",
        "Treasury Bills (< 1Y)",
        "Interbank Overnight Rate",
        "SBV Refinancing Rate",
        "1-Month Bank Deposit Rate"
    ],
    "Default Risk": [
        "Minimal (sovereign)",
        "Minimal (sovereign)",
        "Low (interbank)",
        "None (administered)",
        "Low-moderate (bank)"
    ],
    "Maturity Match": [
        "Poor (1Y vs 1M)",
        "Good (when available)",
        "Very short (overnight)",
        "N/A (not traded)",
        "Good (1M)"
    ],
    "Continuity": [
        "Good",
        "Poor (irregular issuance)",
        "Excellent",
        "Excellent",
        "Good"
    ],
    "Liquidity": [
        "Moderate",
        "Low",
        "High (interbank)",
        "N/A",
        "N/A"
    ],
    "Recommended Use": [
        "Annual/quarterly analysis",
        "When available, preferred",
        "Daily/monthly analysis",
        "Long-run comparisons only",
        "Practitioner DCF"
    ]
})

comparison.style.hide(axis="index")
```

## Constructing the Risk-Free Rate Series

We now construct alternative monthly risk-free rate series and examine their properties.

### Loading and Cleaning Rate Data

```{python}
#| label: load-rf-data
#| eval: false
import pandas as pd
import numpy as np

# Assume rf_data contains: date, rate_type, rate_annual (annualized, in %)
rf_raw = pd.read_parquet("data/risk_free_rates.parquet")

# Preview available rate types
print("Available rate types:")
print(rf_raw["rate_type"].value_counts())
```

```{python}
#| label: fig-rf-raw-series
#| eval: false
#| fig-cap: "Raw Risk-Free Rate Proxies (Annualized, %)"
import matplotlib.pyplot as plt

fig, ax = plt.subplots(figsize=(8, 4.5))

colors = {
    "govt_bond_1y": "#2C73D2",
    "interbank_overnight": "#FF6B6B",
    "sbv_refinancing": "#5DCEAF",
    "tbill_3m": "#FFB347",
    "deposit_1m": "#B19CD9"
}

for rate_type, color in colors.items():
    subset = rf_raw[rf_raw["rate_type"] == rate_type].sort_values("date")
    if len(subset) > 0:
        ax.plot(
            subset["date"], subset["rate_annual"],
            label=rate_type.replace("_", " ").title(),
            color=color, linewidth=1.2, alpha=0.85
        )

ax.set_ylabel("Annualized Rate (%)")
ax.set_xlabel("")
ax.legend(frameon=False, fontsize=9, loc="upper right")
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.tight_layout()
plt.show()
```

### Frequency Alignment

Asset pricing tests require monthly risk-free rates. Raw data may arrive at daily, weekly, or irregular frequencies. We use the following conversion logic:

**Daily to monthly**: Take the average of daily rates within each month, then convert from annualized to monthly.

**Irregular to monthly**: For series with gaps (e.g., treasury bills), forward-fill the most recent observation, then average within each month.

**Annualized to monthly**: Under simple compounding, $r_f^{monthly} = r_f^{annual} / 12$. Under continuous compounding, $r_f^{monthly} = r_f^{annual} / 12$ (since continuous rates are additive). We use simple compounding for consistency with the convention that stock returns are computed as arithmetic returns.

```{python}
#| label: construct-monthly-rf
#| eval: false
# Construct monthly risk-free rates from each proxy

def construct_monthly_rf(rf_raw, rate_type, method="mean"):
    """
    Convert raw rate data to monthly frequency.

    Parameters
    ----------
    rf_raw : pd.DataFrame
        Raw rate data with columns: date, rate_type, rate_annual
    rate_type : str
        Which rate proxy to use
    method : str
        Aggregation method: 'mean', 'last', or 'first'

    Returns
    -------
    pd.DataFrame
        Monthly risk-free rate with columns: date, rf_monthly
    """
    subset = (
        rf_raw[rf_raw["rate_type"] == rate_type]
        .sort_values("date")
        .set_index("date")
    )

    # Forward-fill gaps (for irregular series)
    subset = subset.resample("D").ffill()

    # Aggregate to monthly
    if method == "mean":
        monthly = subset.resample("ME")["rate_annual"].mean()
    elif method == "last":
        monthly = subset.resample("ME")["rate_annual"].last()
    else:
        monthly = subset.resample("ME")["rate_annual"].first()

    monthly = monthly.reset_index()
    monthly.columns = ["date", "rf_annual"]

    # Convert annualized rate (%) to monthly decimal
    monthly["rf_monthly"] = monthly["rf_annual"] / 100 / 12

    return monthly[["date", "rf_monthly", "rf_annual"]]

# Construct series for each proxy
rf_proxies = {}
for proxy in ["govt_bond_1y", "interbank_overnight", "sbv_refinancing"]:
    rf_proxies[proxy] = construct_monthly_rf(rf_raw, proxy)
    rf_proxies[proxy]["proxy"] = proxy

rf_all = pd.concat(rf_proxies.values(), ignore_index=True)
```

### Handling Missing Data and Structural Breaks

Vietnamese rate data may contain gaps due to market closures, reporting changes, or the introduction of new instruments. We handle these systematically:

```{python}
#| label: check-missing
#| eval: false
# Check coverage for each proxy
coverage = (
    rf_all
    .groupby("proxy")
    .agg(
        start_date=("date", "min"),
        end_date=("date", "max"),
        n_months=("rf_monthly", "count"),
        n_missing=("rf_monthly", lambda x: x.isna().sum()),
        avg_rate_pct=("rf_annual", "mean")
    )
    .round(2)
)

print(coverage)
```

For periods where the primary proxy is unavailable, we construct a blended series using a priority hierarchy:

```{python}
#| label: construct-blended-rf
#| eval: false
def construct_blended_rf(rf_proxies, priority=None):
    """
    Construct a blended monthly risk-free rate using proxy priority.

    Priority order (default):
    1. Treasury bills (shortest maturity, sovereign)
    2. Interbank overnight (short maturity, high frequency)
    3. 1-year government bond (sovereign, regular)
    4. SBV refinancing rate (fallback)
    """
    if priority is None:
        priority = [
            "tbill_3m",
            "interbank_overnight",
            "govt_bond_1y",
            "sbv_refinancing"
        ]

    # Create full date range
    all_dates = pd.date_range(
        start=min(df["date"].min() for df in rf_proxies.values()),
        end=max(df["date"].max() for df in rf_proxies.values()),
        freq="ME"
    )

    blended = pd.DataFrame({"date": all_dates})
    blended["rf_monthly"] = np.nan
    blended["source"] = ""

    for proxy in priority:
        if proxy in rf_proxies:
            proxy_df = rf_proxies[proxy][["date", "rf_monthly"]].rename(
                columns={"rf_monthly": f"rf_{proxy}"}
            )
            blended = blended.merge(proxy_df, on="date", how="left")

            # Fill missing values from this proxy
            mask = blended["rf_monthly"].isna() & blended[f"rf_{proxy}"].notna()
            blended.loc[mask, "rf_monthly"] = blended.loc[mask, f"rf_{proxy}"]
            blended.loc[mask, "source"] = proxy

            blended = blended.drop(columns=[f"rf_{proxy}"])

    return blended

rf_blended = construct_blended_rf(rf_proxies)
```

```{python}
#| label: tbl-blended-source
#| eval: false
#| tbl-cap: "Data Source Composition of Blended Risk-Free Rate Series"

source_comp = (
    rf_blended
    .groupby("source")
    .agg(
        n_months=("date", "count"),
        pct=("date", lambda x: len(x) / len(rf_blended) * 100)
    )
    .round(1)
    .sort_values("n_months", ascending=False)
)

source_comp
```

### Properties of the Constructed Series

```{python}
#| label: tbl-rf-summary-stats
#| eval: false
#| tbl-cap: "Summary Statistics of Monthly Risk-Free Rate Proxies"

rf_wide = rf_all.pivot_table(
    index="date", columns="proxy", values="rf_monthly"
)

summary = rf_wide.describe(percentiles=[0.10, 0.25, 0.50, 0.75, 0.90]).T
summary = summary[["mean", "std", "min", "10%", "50%", "90%", "max"]]
summary.columns = [
    "Mean", "Std", "Min", "P10", "Median", "P90", "Max"
]

# Convert to annualized percentage for interpretability
(summary * 12 * 100).round(2)
```

```{python}
#| label: fig-rf-monthly-comparison
#| eval: false
#| fig-cap: "Monthly Risk-Free Rate Across Proxies"

fig, axes = plt.subplots(2, 1, figsize=(8, 6), sharex=True)

# Level
for proxy, color in [
    ("govt_bond_1y", "#2C73D2"),
    ("interbank_overnight", "#FF6B6B"),
    ("sbv_refinancing", "#5DCEAF")
]:
    subset = rf_proxies[proxy].sort_values("date")
    axes[0].plot(
        subset["date"], subset["rf_monthly"] * 100,
        label=proxy.replace("_", " ").title(),
        color=color, linewidth=1
    )
axes[0].set_ylabel("Monthly Rate (%)")
axes[0].legend(frameon=False, fontsize=9)
axes[0].spines["top"].set_visible(False)
axes[0].spines["right"].set_visible(False)

# Pairwise spread: govt bond - interbank
merged = rf_proxies["govt_bond_1y"][["date", "rf_monthly"]].merge(
    rf_proxies["interbank_overnight"][["date", "rf_monthly"]],
    on="date", suffixes=("_bond", "_interbank")
)
merged["spread"] = (merged["rf_monthly_bond"] - merged["rf_monthly_interbank"]) * 100

axes[1].fill_between(
    merged["date"], merged["spread"], 0,
    where=merged["spread"] > 0, alpha=0.4, color="#2C73D2", label="Bond > Interbank"
)
axes[1].fill_between(
    merged["date"], merged["spread"], 0,
    where=merged["spread"] <= 0, alpha=0.4, color="#FF6B6B", label="Bond < Interbank"
)
axes[1].axhline(0, color="black", linewidth=0.5)
axes[1].set_ylabel("Spread (% monthly)")
axes[1].set_xlabel("")
axes[1].legend(frameon=False, fontsize=9)
axes[1].spines["top"].set_visible(False)
axes[1].spines["right"].set_visible(False)

plt.tight_layout()
plt.show()
```

The spread between proxies is informative. A consistently positive spread (bond yield \> interbank rate) reflects the term premium embedded in the 1-year bond. Periods where the interbank rate spikes above the bond yield typically correspond to liquidity crunches in the banking system.

### Correlation Across Proxies

```{python}
#| label: tbl-rf-correlation
#| eval: false
#| tbl-cap: "Pairwise Correlation of Monthly Risk-Free Rate Proxies"

rf_corr = rf_wide.corr().round(3)
rf_corr.index = [x.replace("_", " ").title() for x in rf_corr.index]
rf_corr.columns = [x.replace("_", " ").title() for x in rf_corr.columns]
rf_corr
```

High correlation (\> 0.8) between proxies suggests that the level and direction of interest rate movements are captured similarly by all proxies. Low correlation would indicate that the choice of proxy introduces substantial idiosyncratic variation into excess returns.

## Excess Return Construction

With the risk-free rate series in hand, we now construct excess returns for individual stocks and for the market portfolio.

### Matching Conventions

Excess return construction requires strict consistency across three dimensions (@tbl-rf-consistency).

| Dimension | Requirement | Common Error |
|----------------------|------------------------|--------------------------|
| Currency | Same currency for $r_i$ and $r_f$ | Using USD rate for VND-denominated returns |
| Frequency | Same holding period | Using annualized $r_f$ with monthly $r_i$ |
| Compounding | Same convention | Mixing log and arithmetic returns |

: Consistency Requirements for Excess Returns {#tbl-rf-consistency}

```{python}
#| label: construct-excess-returns
#| eval: false
# Load monthly stock returns
stock_returns = pd.read_parquet("data/monthly_returns.parquet")
# Assume columns: symbol, date (month-end), ret

# Merge with risk-free rate
# Use the blended series as the baseline
rf_for_merge = rf_blended[["date", "rf_monthly"]].rename(
    columns={"rf_monthly": "rf"}
)

stock_returns = stock_returns.merge(rf_for_merge, on="date", how="left")

# Compute excess returns
stock_returns["ret_excess"] = stock_returns["ret"] - stock_returns["rf"]
```

### Market Excess Return

```{python}
#| label: compute-mktrf
#| eval: false
# Value-weighted market return
market_monthly = (
    stock_returns
    .groupby("date")
    .apply(
        lambda g: np.average(
            g["ret"].dropna(),
            weights=g["mktcap"].loc[g["ret"].dropna().index]
        ) if g["ret"].dropna().shape[0] > 0 else np.nan,
        include_groups=False
    )
    .reset_index(name="rm")
)

market_monthly = market_monthly.merge(rf_for_merge, on="date", how="left")
market_monthly["mktrf"] = market_monthly["rm"] - market_monthly["rf"]
```

```{python}
#| label: fig-mktrf-timeseries
#| fig-cap: "Monthly Market Excess Return (MKTRF)"
#| eval: false

fig, ax = plt.subplots(figsize=(8, 3.5))

ax.bar(
    market_monthly["date"], market_monthly["mktrf"] * 100,
    color=np.where(market_monthly["mktrf"] >= 0, "#2C73D2", "#FF6B6B"),
    width=25, alpha=0.8
)
ax.axhline(0, color="black", linewidth=0.5)
ax.set_ylabel("Market Excess Return (%)")
ax.set_xlabel("")
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.tight_layout()
plt.show()
```

## Sensitivity Analysis: How Much Does the Proxy Choice Matter?

This is the central empirical question of the chapter. If different risk-free proxies produce essentially the same downstream results, the choice is inconsequential. If they produce different results, researchers must justify their choice and report robustness.

### Effect on the Equity Premium

```{python}
#| label: tbl-equity-premium-sensitivity
#| eval: false
#| tbl-cap: "Annualized Equity Premium Under Alternative Risk-Free Proxies"

results = []
for proxy_name, proxy_df in rf_proxies.items():
    rf_merge = proxy_df[["date", "rf_monthly"]].rename(
        columns={"rf_monthly": "rf_proxy"}
    )
    merged = market_monthly[["date", "rm"]].merge(rf_merge, on="date", how="inner")
    merged["mktrf_proxy"] = merged["rm"] - merged["rf_proxy"]

    n_months = merged["mktrf_proxy"].count()
    mean_monthly = merged["mktrf_proxy"].mean()
    std_monthly = merged["mktrf_proxy"].std()
    sharpe = mean_monthly / std_monthly if std_monthly > 0 else np.nan
    t_stat = mean_monthly / (std_monthly / np.sqrt(n_months))

    results.append({
        "Proxy": proxy_name.replace("_", " ").title(),
        "N Months": n_months,
        "Mean (% ann.)": round(mean_monthly * 12 * 100, 2),
        "Std (% ann.)": round(std_monthly * np.sqrt(12) * 100, 2),
        "Sharpe (ann.)": round(sharpe * np.sqrt(12), 3),
        "t-stat": round(t_stat, 2)
    })

pd.DataFrame(results).style.hide(axis="index")
```

### Effect on Factor Premiums

```{python}
#| label: tbl-factor-premium-sensitivity
#| eval: false
#| tbl-cap: "Factor Premium Sensitivity to Risk-Free Proxy (Annualized %)"

# Load or construct factor returns
# Assume factors_monthly has: date, smb, hml (these are long-short, rf-independent)
# Only MKTRF changes with the proxy

factors_monthly = pd.read_parquet("data/factors_monthly.parquet")

for proxy_name, proxy_df in rf_proxies.items():
    rf_merge = proxy_df[["date", "rf_monthly"]].rename(
        columns={"rf_monthly": "rf_proxy"}
    )
    factors_merged = factors_monthly.merge(rf_merge, on="date", how="inner")
    factors_merged = factors_merged.merge(
        market_monthly[["date", "rm"]], on="date", how="inner"
    )
    factors_merged[f"mktrf_{proxy_name}"] = (
        factors_merged["rm"] - factors_merged["rf_proxy"]
    )

    mean_mktrf = factors_merged[f"mktrf_{proxy_name}"].mean() * 12 * 100
    mean_smb = factors_merged["smb"].mean() * 12 * 100
    mean_hml = factors_merged["hml"].mean() * 12 * 100

    print(
        f"{proxy_name:>25s}: MKTRF = {mean_mktrf:6.2f}%, "
        f"SMB = {mean_smb:6.2f}%, HML = {mean_hml:6.2f}%"
    )
```

Note that SMB and HML are constructed as long-short portfolio returns and should be identical regardless of the risk-free proxy. Only MKTRF differs. However, if the researcher uses the risk-free rate to compute individual stock excess returns before sorting into factor portfolios, small differences in sorting may arise.

### Effect on Alpha Estimates

The choice of risk-free proxy affects alpha estimates for any portfolio evaluated against a factor model. We illustrate this by estimating the alpha of a momentum portfolio under each proxy.

```{python}
#| label: tbl-alpha-sensitivity
#| eval: false
#| tbl-cap: "Momentum Portfolio Alpha Sensitivity to Risk-Free Proxy"
import statsmodels.api as sm

# Assume momentum_ret contains: date, mom_ret (raw return of WML portfolio)
momentum_ret = pd.read_parquet("data/momentum_returns.parquet")

alpha_results = []
for proxy_name, proxy_df in rf_proxies.items():
    rf_merge = proxy_df[["date", "rf_monthly"]].rename(
        columns={"rf_monthly": "rf_proxy"}
    )

    merged = (
        momentum_ret
        .merge(rf_merge, on="date", how="inner")
        .merge(market_monthly[["date", "rm"]], on="date", how="inner")
        .merge(factors_monthly[["date", "smb", "hml"]], on="date", how="inner")
    )

    merged["mom_excess"] = merged["mom_ret"] - merged["rf_proxy"]
    merged["mktrf"] = merged["rm"] - merged["rf_proxy"]

    X = sm.add_constant(merged[["mktrf", "smb", "hml"]])
    y = merged["mom_excess"]
    model = sm.OLS(y, X).fit(cov_type="HAC", cov_kwds={"maxlags": 6})

    alpha_results.append({
        "Proxy": proxy_name.replace("_", " ").title(),
        "Alpha (% monthly)": round(model.params["const"] * 100, 3),
        "t-stat": round(model.tvalues["const"], 2),
        "R²": round(model.rsquared, 3)
    })

pd.DataFrame(alpha_results).style.hide(axis="index")
```

### Effect on Valuation

To illustrate the valuation impact, consider a simple DCF exercise where the cost of equity is estimated via the CAPM.

```{python}
#| label: tbl-valuation-sensitivity
#| eval: false
#| tbl-cap: "Cost of Equity and Terminal Value Sensitivity to Risk-Free Proxy"

# Example: firm with beta = 1.0, expected CF = 1 billion VND, growth = 3%
beta_example = 1.0
cf = 1e9  # VND
growth = 0.03

valuation_results = []
for proxy_name, proxy_df in rf_proxies.items():
    rf_ann = proxy_df["rf_annual"].dropna().iloc[-12:].mean() / 100  # Latest year avg

    rf_merge = proxy_df[["date", "rf_monthly"]].rename(
        columns={"rf_monthly": "rf_proxy"}
    )
    mkt_merged = market_monthly[["date", "rm"]].merge(
        rf_merge, on="date", how="inner"
    )
    mkt_merged["mktrf"] = mkt_merged["rm"] - mkt_merged["rf_proxy"]
    erp = mkt_merged["mktrf"].mean() * 12  # Annualized equity premium

    cost_equity = rf_ann + beta_example * erp
    terminal_value = cf / (cost_equity - growth) if cost_equity > growth else np.nan

    valuation_results.append({
        "Proxy": proxy_name.replace("_", " ").title(),
        "Rf (% ann.)": round(rf_ann * 100, 2),
        "ERP (% ann.)": round(erp * 100, 2),
        "Cost of Equity (%)": round(cost_equity * 100, 2),
        "Terminal Value (B VND)": round(terminal_value / 1e9, 1) if terminal_value else "N/A"
    })

pd.DataFrame(valuation_results).style.hide(axis="index")
```

::: callout-important
## Key Finding

Even modest differences in the risk-free rate (50-150 basis points across proxies) can produce terminal value differences of 10-30%. Researchers and practitioners must document their risk-free rate choice explicitly and report sensitivity to alternatives.
:::

## Term Structure Considerations

When longer-horizon discount rates are needed (e.g., for multi-year DCF or cost of capital estimation), the risk-free rate should be maturity-matched. This requires constructing a yield curve from available government bond data.

### Yield Curve Estimation

@gurkaynak2007us develop a parametric approach to yield curve estimation using the @nelson1987parsimonious and @svensson1994estimating models. The Nelson-Siegel model parameterizes the instantaneous forward rate as:

$$
f(\tau) = \beta_0 + \beta_1 \exp\left(-\frac{\tau}{\lambda}\right) + \beta_2 \frac{\tau}{\lambda} \exp\left(-\frac{\tau}{\lambda}\right)
$$ {#eq-nelson-siegel}

where $\tau$ is the maturity, $\beta_0$ is the long-run level, $\beta_1$ determines the slope, $\beta_2$ determines the curvature, and $\lambda$ controls the location of the hump.

The corresponding yield is:

$$
y(\tau) = \beta_0 + \beta_1 \frac{1 - \exp(-\tau/\lambda)}{\tau/\lambda} + \beta_2 \left[\frac{1 - \exp(-\tau/\lambda)}{\tau/\lambda} - \exp(-\tau/\lambda)\right]
$$ {#eq-ns-yield}

```{python}
#| label: nelson-siegel-estimation
#| eval: false
from scipy.optimize import minimize

def nelson_siegel_yield(tau, beta0, beta1, beta2, lam):
    """Nelson-Siegel yield curve model."""
    tau_lam = tau / lam
    factor1 = (1 - np.exp(-tau_lam)) / tau_lam
    factor2 = factor1 - np.exp(-tau_lam)
    return beta0 + beta1 * factor1 + beta2 * factor2

def fit_nelson_siegel(maturities, yields):
    """Fit Nelson-Siegel model to observed yields."""
    def objective(params):
        beta0, beta1, beta2, lam = params
        if lam <= 0:
            return 1e10
        fitted = nelson_siegel_yield(maturities, beta0, beta1, beta2, lam)
        return np.sum((yields - fitted) ** 2)

    result = minimize(
        objective,
        x0=[yields[-1], yields[0] - yields[-1], 0, 2.0],
        method="Nelder-Mead",
        options={"maxiter": 10000}
    )
    return result.x

# Example: fit to latest available government bond yields
# Assume govt_yields contains: date, maturity_years, yield_pct
govt_yields = pd.read_parquet("data/govt_bond_yields.parquet")

latest_date = govt_yields["date"].max()
latest_yields = govt_yields[govt_yields["date"] == latest_date].sort_values("maturity_years")

maturities = latest_yields["maturity_years"].values
yields = latest_yields["yield_pct"].values

params = fit_nelson_siegel(maturities, yields)
beta0, beta1, beta2, lam = params
```

```{python}
#| label: fig-yield-curve
#| eval: false
#| fig-cap: "Vietnamese Government Bond Yield Curve (Nelson-Siegel Fit)"

tau_fine = np.linspace(0.25, 30, 200)
fitted_yields = nelson_siegel_yield(tau_fine, *params)

fig, ax = plt.subplots(figsize=(7, 4))
ax.scatter(
    maturities, yields, color="#FF6B6B", s=60, zorder=5,
    label="Observed yields", edgecolors="white"
)
ax.plot(
    tau_fine, fitted_yields, color="#2C73D2", linewidth=2,
    label="Nelson-Siegel fit"
)
ax.set_xlabel("Maturity (Years)")
ax.set_ylabel("Yield (%)")
ax.legend(frameon=False)
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.tight_layout()
plt.show()

print(f"Nelson-Siegel parameters:")
print(f"  β₀ (level)     = {beta0:.4f}")
print(f"  β₁ (slope)     = {beta1:.4f}")
print(f"  β₂ (curvature) = {beta2:.4f}")
print(f"  λ (decay)      = {lam:.4f}")
```

::: callout-tip
The Nelson-Siegel yield curve allows extraction of a risk-free rate at any maturity. For monthly asset pricing, evaluate the curve at $\tau = 1/12$ (one month). For DCF valuation with a 10-year horizon, evaluate at $\tau = 10$. This maturity-matching approach is superior to using a single proxy for all purposes.
:::

### Extracting the Short-Rate from the Yield Curve

```{python}
#| label: extract-short-rate
#| eval: false
# Extract 1-month rate from Nelson-Siegel curve at each date
def extract_ns_short_rate(govt_yields, target_maturity=1/12):
    """
    For each date, fit Nelson-Siegel and extract the yield
    at the target maturity.
    """
    dates = govt_yields["date"].unique()
    short_rates = []

    for d in dates:
        obs = govt_yields[govt_yields["date"] == d].sort_values("maturity_years")
        if len(obs) < 3:  # Need at least 3 points to fit
            short_rates.append({"date": d, "rf_ns": np.nan})
            continue

        try:
            params = fit_nelson_siegel(
                obs["maturity_years"].values,
                obs["yield_pct"].values
            )
            rf_ns = nelson_siegel_yield(target_maturity, *params)
            short_rates.append({"date": d, "rf_ns": rf_ns})
        except Exception:
            short_rates.append({"date": d, "rf_ns": np.nan})

    return pd.DataFrame(short_rates)

ns_short_rates = extract_ns_short_rate(govt_yields)
```

## Real vs. Nominal Risk-Free Rates

For certain applications, particularly long-horizon valuation and real return analysis, the real (inflation-adjusted) risk-free rate is more appropriate than the nominal rate. The Fisher equation relates them:

$$
r_f^{real} \approx r_f^{nominal} - \pi^{e}
$$ {#eq-fisher}

where $\pi^e$ is expected inflation. In practice, we can use realized CPI inflation as a proxy for expected inflation (under the assumption of rational expectations, or as an ex-post adjustment).

```{python}
#| label: compute-real-rf
#| eval: false
# Load CPI data
# Assume cpi_data contains: date, cpi_index (or inflation_mom for month-over-month)
cpi_data = pd.read_parquet("data/cpi_monthly.parquet")
cpi_data = cpi_data.sort_values("date")
cpi_data["inflation_monthly"] = cpi_data["cpi_index"].pct_change()

rf_real = rf_blended[["date", "rf_monthly"]].merge(
    cpi_data[["date", "inflation_monthly"]], on="date", how="inner"
)
rf_real["rf_real"] = rf_real["rf_monthly"] - rf_real["inflation_monthly"]
```

```{python}
#| label: fig-real-vs-nominal
#| eval: false
#| fig-cap: "Nominal vs. Real Monthly Risk-Free Rate"

fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(
    rf_real["date"], rf_real["rf_monthly"] * 100,
    color="#2C73D2", label="Nominal", linewidth=1
)
ax.plot(
    rf_real["date"], rf_real["rf_real"] * 100,
    color="#FF6B6B", label="Real", linewidth=1
)
ax.axhline(0, color="black", linewidth=0.5, linestyle="--")
ax.set_ylabel("Monthly Rate (%)")
ax.set_xlabel("")
ax.legend(frameon=False)
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.tight_layout()
plt.show()
```

::: callout-note
In periods of high inflation, the real risk-free rate can be substantially negative. This has implications for real excess return computation and for interpreting the equity premium in real terms. A negative real risk-free rate implies that nominal government securities do not preserve purchasing power, which strengthens the case for equity investment from a real-return perspective.
:::

## International Comparison

It is instructive to compare Vietnam's risk-free rate environment with that of other emerging and developed markets to contextualize the magnitudes involved.

```{python}
#| label: tbl-international-comparison
#| include: false
#| tbl-cap: "Risk-Free Rate Proxies: International Comparison"

intl_comparison = pd.DataFrame({
    "Country": [
        "Vietnam",
        "Thailand",
        "Indonesia",
        "Philippines",
        "India",
        "South Korea",
        "Japan"
    ],
    "Typical Proxy": [
        "Interbank overnight / 1Y govt bond",
        "1-day bilateral repurchase rate",
        "Bank Indonesia 7-day reverse repo rate",
        "91-day T-bill",
        "91-day T-bill",
        "91-day CD rate",
        "Uncollateralized overnight call rate"
    ],
    "Short-Term Maturity Available": [
        "Limited (<1Y sparse)",
        "Yes (1-day repo)",
        "Yes (7-day, 1M)",
        "Yes (91-day T-bill)",
        "Yes (91-day T-bill)",
        "Yes (91-day CD)",
        "Yes (overnight)"
    ],
    "Typical Level (%, 2020-2024)": [
        "2.5-6.0",
        "0.5-2.5",
        "3.5-6.0",
        "1.5-6.0",
        "3.5-7.0",
        "1.0-3.5",
        "-0.1-0.1"
    ]
})

intl_comparison.style.hide(axis="index")
```

Vietnam's risk-free rate environment is characterized by relatively high nominal rates (reflecting inflation and growth dynamics), limited availability of very-short-maturity sovereign instruments, and greater reliance on interbank rates as the operational proxy. This is broadly similar to other ASEAN frontier markets but contrasts sharply with developed Asian markets, where deep government securities markets provide clean short-term benchmarks.

## Best Practices Checklist

Based on the analysis in this chapter, we summarize the recommended practices for risk-free rate construction in Vietnamese financial research:

```{python}
#| label: tbl-best-practices
#| include: false
#| tbl-cap: "Best Practices for Risk-Free Rate Construction"

practices = pd.DataFrame({
    "Practice": [
        "Use the shortest available maturity",
        "Match frequency to return data",
        "Use the same compounding convention",
        "Document the proxy and source explicitly",
        "Report sensitivity to alternative proxies",
        "Avoid forward-looking policy rates",
        "Handle gaps with documented interpolation",
        "Use Nelson-Siegel for maturity matching",
        "Consider real rates for long-horizon analysis",
        "Maintain a single consistent series per study"
    ],
    "Rationale": [
        "Minimizes term premium contamination",
        "Avoids compounding mismatches between rf and stock returns",
        "Arithmetic returns require arithmetic rf conversion",
        "Enables replication; different proxies give different results",
        "Demonstrates robustness of conclusions",
        "Policy rates are not investable returns",
        "Forward-fill, then average within month; document procedure",
        "Enables extraction of any-maturity rate from sparse data",
        "Nominal rates overstate real compensation in high-inflation periods",
        "Mixing proxies across periods introduces structural breaks"
    ]
})

practices.style.hide(axis="index")
```

## Saving the Risk-Free Rate for Downstream Use

The final step is to save the constructed risk-free rate series for use in subsequent chapters.

```{python}
#| label: save-rf-series
#| eval: false
# Save all variants for flexibility
rf_output = rf_blended[["date", "rf_monthly", "source"]].copy()
rf_output["rf_annual_pct"] = rf_output["rf_monthly"] * 12 * 100

# Also save individual proxies
for proxy_name, proxy_df in rf_proxies.items():
    col_name = f"rf_{proxy_name}"
    rf_output = rf_output.merge(
        proxy_df[["date", "rf_monthly"]].rename(
            columns={"rf_monthly": col_name}
        ),
        on="date",
        how="left"
    )

# Save to parquet for use in later chapters
rf_output.to_parquet("data/risk_free_rate.parquet", index=False)

print(f"Risk-free rate series saved: {len(rf_output)} months")
print(f"Date range: {rf_output['date'].min()} to {rf_output['date'].max()}")
print(f"\nColumns: {list(rf_output.columns)}")
```

::: callout-tip
By saving the risk-free rate as a separate, well-documented file, all downstream chapters can merge it consistently. This avoids the common pitfall of reconstructing the risk-free rate differently in different analyses within the same study.
:::

## Summary

This chapter has established that risk-free rate construction is a first-order modeling decision in Vietnamese financial research, not a technical afterthought. The key takeaways are:

1.  **No perfect proxy exists** in Vietnam. The interbank overnight rate, 1-year government bond yield, and SBV policy rate each have distinct strengths and limitations. A blended series using a documented priority hierarchy provides the most robust baseline.

2.  **The choice of proxy matters quantitatively**. Different proxies can shift the estimated equity premium by 50-200 basis points annually, alter portfolio alphas, and change DCF terminal values by 10-30%.

3.  **Frequency alignment and compounding conventions** must be handled with care. Converting annualized rates to monthly requires specifying the compounding convention. Gaps in the data require documented interpolation.

4.  **The Nelson-Siegel yield curve model** enables the extraction of any-maturity risk-free rate from sparse government bond data, which is particularly valuable for maturity-matched discount rate estimation.

5.  **Sensitivity analysis is mandatory**. Any study that reports results under a single risk-free proxy without reporting robustness to alternatives has an unquantified source of specification uncertainty.

<!-- ## Exercises

1.  **Proxy substitution test**: Re-estimate the Fama-French three-factor model for the Vietnamese market using each of the three risk-free proxies. Report the market premium, SMB, and HML under each specification. Are the cross-sectional patterns in factor loadings sensitive to the proxy choice?

2.  **Breakpoint analysis**: Identify structural breaks in the interbank overnight rate series using the @bai2003critical sequential break detection procedure. Do these breaks correspond to known monetary policy regime changes (e.g., SBV rate adjustments, regulatory changes)?

3.  **Inflation-adjusted equity premium**: Compute the real equity premium by subtracting realized CPI inflation from both the market return and the nominal risk-free rate. Compare the Sharpe ratio of the market portfolio in nominal vs. real terms.

4.  **Yield curve dynamics**: Estimate the Nelson-Siegel model at monthly frequency and track the time series of $\beta_0$ (level), $\beta_1$ (slope), and $\beta_2$ (curvature). Do these factors predict future stock market returns or macroeconomic variables, following @Ang2006 @ang2006does?

5.  **Currency-adjusted risk-free rate**: For foreign investors, the relevant risk-free rate includes currency hedging costs. Construct a USD-hedged risk-free rate using the VND/USD forward premium (covered interest parity) and compare it to the local-currency risk-free rate. How does this affect the equity premium from a foreign investor's perspective?

6.  **Deposit rate ceiling effects**: During periods when the SBV imposes binding deposit rate ceilings, the observed deposit rate may be below the market-clearing rate. Identify such periods and test whether the deposit-rate-based risk-free proxy produces systematically different excess returns compared to the interbank rate during ceiling-binding vs. non-binding periods. -->