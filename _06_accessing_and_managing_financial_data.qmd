---
title: Accessing and Managing VN Financial Data
format:
  html:
    toc: true
    number-sections: true
jupyter: python3
execute:
  echo: true
  warning: false
  message: false
---

This chapter provides a guide to organizing, accessing, and managing financial data specifically tailored for the Vietnamese market. While global financial databases such as CRSP and Compustat serve as standard resources for developed markets, emerging markets like Vietnam require a different approach due to unique data sources, market structures, and regulatory environments. Understanding these nuances is essential for conducting rigorous empirical research on Vietnamese equities, bonds, and macroeconomic indicators.

Vietnam's financial market has experienced remarkable growth since the establishment of the Ho Chi Minh City Stock Exchange (HOSE) in 2000 and the Hanoi Stock Exchange (HNX) in 2005. Today, the market comprises over 1,600 listed companies across three trading venues: HOSE for large-cap stocks, HNX for mid-cap stocks, and UPCoM (Unlisted Public Company Market) for smaller companies transitioning to formal listing. This diversity creates both opportunities and challenges for financial researchers seeking comprehensive coverage of the Vietnamese equity universe.

The Vietnamese market presents several distinctive characteristics that researchers must account for. Foreign ownership limits (typically 49% for most sectors, with exceptions for banking and certain strategic industries), trading band restrictions (e.g., currently $\pm$ 7% for HOSE and $\pm$ 10% for HNX), and the T+2 settlement cycle all influence market microstructure and return dynamics. Additionally, the market operates in Vietnamese Dong (VND), requiring careful attention to currency effects when comparing results with international studies.

We begin by loading the essential Python packages that facilitate data acquisition and management throughout this chapter.

```{python}
#| message: false
import pandas as pd
import numpy as np
import requests
from datetime import datetime, timedelta
import json
import sqlite3
```

We also define the date range for our data collection, which spans from the early days of the Vietnamese stock market to the present. This extended timeframe allows us to capture the market's evolution through various economic cycles, including the 2008 global financial crisis, the 2011-2012 domestic banking crisis, and the COVID-19 pandemic period.

```{python}
start_date = "2000-07-28"  # HOSE establishment date
end_date = "2024-12-31"
```

------------------------------------------------------------------------

## Overview of Vietnamese Financial Data Sources

Before diving into the technical implementation, it is valuable to understand the landscape of financial data providers serving the Vietnamese market. Unlike developed markets where a few dominant providers (Bloomberg, Refinitiv, FactSet) offer comprehensive coverage, Vietnamese financial data has historically been fragmented across multiple sources, each with distinct strengths and limitations.

The primary sources of Vietnamese financial data include official exchange feeds from HOSE and HNX, which provide real-time and historical trading data. The State Securities Commission of Vietnam (SSC) publishes regulatory filings, corporate announcements, and market statistics. Commercial data vendors such as FiinGroup, StoxPlus (now part of FiinGroup), and VNDirect offer curated datasets with varying levels of coverage and data quality. Additionally, the State Bank of Vietnam (SBV) and the General Statistics Office (GSO) provide macroeconomic indicators essential for asset pricing research.

For academic researchers, this fragmentation traditionally involved difficult trade-offs between cost, coverage, data quality, and ease of access. Commercial providers like FiinGroup offer clean, standardized data but require subscription fees that may be prohibitive for individual researchers and smaller institutions. Open-source alternatives provide free access but often require substantial data cleaning and validation efforts. Manually collecting data from government websites is time-consuming and prone to inconsistencies.

Fortunately, this landscape has improved significantly with the emergence of [**Datacore**](https://datacore.vn/) as a unified data platform for Vietnamese financial markets. In our experience working with Vietnamese financial data across multiple research projects, Datacore has proven to be the most practical solution for academic research. The platform consolidates data from multiple sources, including stock prices, corporate fundamentals, market indices, macroeconomic indicators, and alternative data, into a single, accessible interface with a well-documented API.

What distinguishes [Datacore](https://datacore.vn/) from traditional commercial providers like FiinGroup extends beyond mere data aggregation. While FiinGroup has long been the institutional incumbent, several factors make Datacore particularly attractive for rigorous empirical research:

1.  **API-First Architecture**: Datacore was built from the ground up for programmatic access, making it seamlessly integrable with Python, R, and other research workflows. FiinGroup's data access, by contrast, often requires manual downloads or cumbersome Excel-based interfaces that impede reproducibility.

2.  **Cost Efficiency**: Academic researchers frequently operate under budget constraints. Datacore offers competitive pricing structures that make comprehensive market coverage accessible without the substantial subscription fees associated with legacy providers.

3.  **Corporate Action Handling**: One persistent challenge with Vietnamese data is accurate adjustment for stock splits, bonus shares, and rights issues. Datacore implements transparent adjustment methodologies with clear documentation, whereas legacy providers often apply adjustments inconsistently or without adequate explanation.

4.  **Update Frequency**: Datacore maintains near real-time data updates with clear timestamps, enabling event study research and timely portfolio rebalancing. Traditional providers often suffer from publication lags that can compromise research requiring current data.

5.  **Coverage Breadth**: Beyond standard price and fundamental data, Datacore integrates alternative data, and macroeconomic indicators into a unified schema. This eliminates the need to merge datasets from multiple sources, which is a process that introduces potential errors and consumes valuable research time.

Throughout this chapter, we leverage Datacore as our primary data source. By centralizing our data acquisition through a single platform, we benefit from consistent data formats, reliable corporate action adjustments, and comprehensive market coverage spanning HOSE, HNX, and UPCoM. The code examples that follow demonstrate how straightforward Vietnamese financial research becomes when data access friction is minimized.

The following table summarizes the key data sources for Vietnamese financial research:

| Data Source | Coverage | Access Type | Key Strengths | Limitations |
|---------------|---------------|---------------|---------------|---------------|
| **Datacore** | Prices, fundamentals, indices, macro, derivatives | API | Unified platform, programmatic access, comprehensive coverage, transparent methodology | Newer platform |
| FiinGroup | Full market coverage | Commercial | Established reputation, institutional adoption | High cost, manual access, limited API |
| HOSE/HNX websites | Official exchange data | Free (manual) | Authoritative, real-time | No API, manual collection required |
| GSO (gso.gov.vn) | Macroeconomic indicators | Free (manual) | Official government statistics | Infrequent updates, no API |
| SBV (sbv.gov.vn) | Monetary policy, rates | Free (manual) | Central bank data | Manual download only |
| CafeF/VnExpress | News, announcements | Free | Market sentiment, events | Unstructured, requires NLP processing |

: Vietnamese Financial Data Sources {#tbl-data-sources}

------------------------------------------------------------------------

## Stock Market Data

The vnstock library has emerged as the most comprehensive open-source solution for accessing Vietnamese stock market data. Developed and maintained by the Vietnamese fintech community, vnstock provides programmatic access to stock prices, trading volumes, fundamental data, and corporate actions from multiple data sources including VCI (Viet Capital Securities), TCBS (Techcom Securities), and SSI (Saigon Securities Inc.).

The library supports both daily and intraday data frequencies, making it suitable for a wide range of research applications from long-horizon asset allocation studies to high-frequency market microstructure analysis. Importantly, vnstock handles the complexities of Vietnamese stock identifiers, which differ from international conventions and can change over time due to mergers, ticker changes, and exchange transfers.

We begin by initializing the vnstock client and retrieving the complete list of stocks traded on all three Vietnamese exchanges. This stock universe forms the foundation for subsequent data collection and serves as our master security file.

```{python}
#| eval: false
# Initialize vnstock with VCI as data source
stock = Vnstock().stock(symbol="VNM", source="VCI")

# Get complete stock listing across all exchanges
stock_listing = stock.listing.all_symbols()

# Filter to include only common stocks (exclude ETFs, bonds)
common_stocks = stock_listing.query(
    "type == 'STOCK' and exchange in ['HOSE', 'HNX', 'UPCOM']"
)

# Display summary statistics
print(f"Total stocks: {len(common_stocks)}")
print(f"HOSE: {len(common_stocks.query('exchange == \"HOSE\"'))}")
print(f"HNX: {len(common_stocks.query('exchange == \"HNX\"'))}")
print(f"UPCoM: {len(common_stocks.query('exchange == \"UPCOM\"'))}")
```

The resulting DataFrame contains essential security identifiers including the ticker symbol, company name in both Vietnamese and English, exchange listing, industry classification according to the Vietnam Standard Industrial Classification (VSIC), and various flags indicating special status such as foreign ownership restrictions or trading suspensions.

### Historical Price Data

With our stock universe defined, we can now retrieve historical price data for individual securities. The vnstock library returns OHLCV (Open, High, Low, Close, Volume) data along with adjusted prices that account for corporate actions such as stock splits, stock dividends, and rights issues. Proper adjustment for corporate actions is critical for computing accurate returns, particularly for long-horizon studies where cumulative effects can be substantial.

```{python}
#| eval: false
def get_stock_history(symbol, start_date, end_date):
    """
    Retrieve historical price data for a Vietnamese stock.
    
    Parameters
    ----------
    symbol : str
        Stock ticker symbol (e.g., 'VNM', 'VIC', 'FPT')
    start_date : str
        Start date in 'YYYY-MM-DD' format
    end_date : str
        End date in 'YYYY-MM-DD' format
    
    Returns
    -------
    pd.DataFrame
        DataFrame with date, OHLCV, and adjusted prices
    """
    stock = Vnstock().stock(symbol=symbol, source="VCI")
    
    df = stock.quote.history(
        start=start_date,
        end=end_date,
        interval="1D"
    )
    
    # Add symbol identifier
    df["symbol"] = symbol
    
    # Calculate daily returns
    df["return"] = df["close"].pct_change()
    
    return df
```

For comprehensive market analysis, we need to collect data for the entire stock universe. The following function iterates through all symbols while implementing robust error handling and rate limiting to respect the data provider's usage policies. We also include progress tracking given the potentially lengthy data collection process.

```{python}
#| eval: false
import time
from tqdm import tqdm

def collect_all_stock_data(symbols, start_date, end_date):
    """
    Collect historical data for multiple stocks with error handling.
    
    Parameters
    ----------
    symbols : list
        List of stock ticker symbols
    start_date : str
        Start date in 'YYYY-MM-DD' format
    end_date : str
        End date in 'YYYY-MM-DD' format
    
    Returns
    -------
    tuple
        (combined_df, failed_symbols) where combined_df is the 
        concatenated DataFrame and failed_symbols lists any errors
    """
    all_data = []
    failed_symbols = []
    
    for symbol in tqdm(symbols, desc="Collecting stock data"):
        try:
            df = get_stock_history(symbol, start_date, end_date)
            all_data.append(df)
            time.sleep(0.1)  # Rate limiting
        except Exception as e:
            failed_symbols.append((symbol, str(e)))
            continue
    
    # Combine all successful downloads
    if all_data:
        combined_df = pd.concat(all_data, ignore_index=True)
    else:
        combined_df = pd.DataFrame()
    
    print(f"Successfully collected: {len(all_data)} stocks")
    print(f"Failed: {len(failed_symbols)} stocks")
    
    return combined_df, failed_symbols
```

### Fundamental Data and Financial Statements

Beyond price data, fundamental analysis requires access to corporate financial statements including balance sheets, income statements, and cash flow statements. Vietnamese publicly listed companies are required to publish quarterly and annual financial reports according to Vietnamese Accounting Standards (VAS), which differ in certain respects from International Financial Reporting Standards (IFRS). Understanding these differences is important when comparing Vietnamese firms with international peers or applying models developed using US or European data.

Key differences between VAS and IFRS that affect financial analysis include:

1.  **Revenue recognition**: VAS allows more flexibility in timing of revenue recognition compared to IFRS 15
2.  **Financial instruments**: VAS has less comprehensive guidance on fair value measurement
3.  **Lease accounting**: VAS does not require operating lease capitalization as under IFRS 16
4.  **Goodwill**: VAS requires amortization while IFRS requires impairment testing only

The vnstock library provides access to fundamental data through the company module. We can retrieve financial statements, key ratios, and company profiles programmatically.

```{python}
#| eval: false
def get_financial_statements(symbol):
    """
    Retrieve financial statements for a Vietnamese company.
    
    Parameters
    ----------
    symbol : str
        Stock ticker symbol
    
    Returns
    -------
    dict
        Dictionary containing balance_sheet, income_statement, 
        and cash_flow DataFrames
    """
    company = Vnstock().stock(symbol=symbol, source="TCBS").company
    
    # Get balance sheet
    balance_sheet = company.balance_sheet(period="quarter", lang="en")
    
    # Get income statement
    income_stmt = company.income_statement(period="quarter", lang="en")
    
    # Get cash flow statement
    cash_flow = company.cash_flow(period="quarter", lang="en")
    
    return {
        "balance_sheet": balance_sheet,
        "income_statement": income_stmt,
        "cash_flow": cash_flow
    }


def get_financial_ratios(symbol):
    """
    Retrieve key financial ratios for a Vietnamese company.
    
    Parameters
    ----------
    symbol : str
        Stock ticker symbol
    
    Returns
    -------
    pd.DataFrame
        DataFrame containing financial ratios over time
    """
    company = Vnstock().stock(symbol=symbol, source="TCBS").company
    
    # Get financial ratios
    ratios = company.ratio(period="quarter", lang="en")
    
    return ratios
```

### Corporate Actions and Events

Accurate treatment of corporate actions is essential for computing correct returns and maintaining data integrity. Vietnamese companies frequently engage in corporate actions including cash dividends, stock dividends (bonus shares), rights issues, and stock splits. The vnstock library provides access to corporate action data, though researchers should validate this information against official exchange announcements.

```{python}
#| eval: false
def get_corporate_events(symbol):
    """
    Retrieve corporate events and actions for a Vietnamese company.
    
    Parameters
    ----------
    symbol : str
        Stock ticker symbol
    
    Returns
    -------
    pd.DataFrame
        DataFrame containing corporate events
    """
    company = Vnstock().stock(symbol=symbol, source="TCBS").company
    
    # Get dividend history
    dividends = company.dividends()
    
    # Get major events/news
    events = company.events()
    
    return {
        "dividends": dividends,
        "events": events
    }
```

## Market Indices and Benchmarks

Constructing appropriate benchmarks is fundamental to performance evaluation and factor model estimation. The Vietnamese market features several indices that serve different purposes in financial research.

| Index       | Exchange | Description             | Use Case               |
|-------------|----------|-------------------------|------------------------|
| VN-Index    | HOSE     | All HOSE-listed stocks  | Broad market benchmark |
| VN30-Index  | HOSE     | 30 largest, most liquid | Investable benchmark   |
| HNX-Index   | HNX      | All HNX-listed stocks   | Mid-cap benchmark      |
| HNX30-Index | HNX      | 30 largest HNX stocks   | HNX large-cap          |
| VNAllShare  | Combined | HOSE + HNX              | Total market           |
| VN100       | Combined | Top 100 stocks          | Large/mid-cap          |

: Vietnamese Market Indices {#tbl-indices}

The VN-Index, which tracks all stocks listed on HOSE, is the most widely followed benchmark and serves as the primary gauge of overall market performance. The HNX-Index covers stocks on the Hanoi exchange, while the VN30-Index tracks the thirty largest and most liquid stocks on HOSE.

For asset pricing research, the VN30-Index is particularly valuable as it represents the investable universe for institutional investors and serves as the underlying for Vietnam's most liquid derivatives contracts. The constituent stocks are reviewed semi-annually based on market capitalization, liquidity, and free-float requirements.

```{python}
#| eval: false
# Retrieve VN-Index historical data
index = Vnstock().stock(symbol="VNINDEX", source="VCI")

vn_index = index.quote.history(
    start=start_date,
    end=end_date,
    interval="1D"
)

# Calculate daily and monthly returns
vn_index["return_daily"] = vn_index["close"].pct_change()
vn_index["date"] = pd.to_datetime(vn_index["time"])
vn_index["year_month"] = vn_index["date"].dt.to_period("M")

# Monthly returns
vn_index_monthly = (
    vn_index
    .groupby("year_month")
    .agg(
        close_last=("close", "last"),
        volume_sum=("volume", "sum")
    )
    .reset_index()
)
vn_index_monthly["return_monthly"] = (
    vn_index_monthly["close_last"].pct_change()
)
```

### Index Constituent Data

For factor model construction and portfolio analysis, access to index constituent lists and their weights is essential. While official constituent data requires subscription to exchange data feeds, we can approximate index membership using market capitalization and liquidity filters.

```{python}
#| eval: false
def get_index_constituents(index_name="VN30"):
    """
    Retrieve current constituents of a Vietnamese index.
    
    Parameters
    ----------
    index_name : str
        Index identifier (e.g., 'VN30', 'HNX30')
    
    Returns
    -------
    pd.DataFrame
        DataFrame with constituent symbols and weights
    """
    # Get listing data
    stock = Vnstock().stock(symbol="VNM", source="VCI")
    listing = stock.listing.all_symbols()
    
    if index_name == "VN30":
        # Filter HOSE stocks and sort by market cap
        hose_stocks = listing.query("exchange == 'HOSE' and type == 'STOCK'")
        # Note: Actual VN30 uses more complex selection criteria
        # This is an approximation based on available data
        return hose_stocks.head(30)
    
    return listing
```

## Macroeconomic Data from Vietnamese Sources

Asset pricing models often incorporate macroeconomic variables as predictors of expected returns or as state variables in conditional models. For the Vietnamese market, relevant macroeconomic data comes primarily from two sources: the General Statistics Office (GSO) and the State Bank of Vietnam (SBV).

### Key Macroeconomic Indicators

The following macroeconomic variables are particularly relevant for Vietnamese financial research:

1.  **Consumer Price Index (CPI)**: Essential for computing real returns and inflation-adjusted valuations. Vietnam experienced periods of high inflation, particularly during 2008 and 2011 when annual CPI exceeded 20%.

2.  **Industrial Production Index (IPI)**: Proxy for economic activity and business cycle conditions.

3.  **Money Supply (M2)**: Indicator of monetary policy stance and liquidity conditions.

4.  **Credit Growth**: Bank lending growth, a key driver of economic activity in Vietnam's bank-dominated financial system.

5.  **USD/VND Exchange Rate**: Critical for international investors and companies with foreign currency exposure.

6.  **Foreign Direct Investment (FDI)**: Indicator of international capital flows and economic confidence.

7.  **Trade Balance**: Export and import dynamics affecting corporate earnings.

Unfortunately, unlike the US Federal Reserve's FRED database, Vietnamese macroeconomic data is not available through standardized APIs. Researchers must typically download data manually from GSO and SBV websites or use web scraping techniques.

```{python}
#| eval: false
# Structure for Vietnamese macroeconomic data
# Data must be downloaded manually from GSO (gso.gov.vn)

def create_macro_template():
    """
    Create template DataFrame for Vietnamese macroeconomic data.
    
    Returns
    -------
    pd.DataFrame
        Empty template with proper column structure
    """
    macro_vietnam = pd.DataFrame({
        "date": pd.date_range(start="2010-01-01", periods=180, freq="ME"),
        "cpi": None,              # Consumer Price Index (2020=100)
        "cpi_yoy": None,          # CPI year-over-year change (%)
        "ipi": None,              # Industrial Production Index
        "ipi_yoy": None,          # IPI year-over-year change (%)
        "m2": None,               # M2 money supply (trillion VND)
        "m2_growth": None,        # M2 growth rate (%)
        "credit_growth": None,    # Bank credit growth (%)
        "refinancing_rate": None, # SBV refinancing rate (%)
        "discount_rate": None,    # SBV discount rate (%)
        "usd_vnd": None,          # USD/VND exchange rate
        "fdi_registered": None,   # Registered FDI (million USD)
        "fdi_disbursed": None,    # Disbursed FDI (million USD)
        "exports": None,          # Exports (million USD)
        "imports": None,          # Imports (million USD)
        "trade_balance": None,    # Trade balance (million USD)
    })
    
    return macro_vietnam
```

### Downloading Macroeconomic Data

While automated API access is not available, we can structure the manual data collection process to ensure consistency and reproducibility. The following workflow describes the recommended approach:

```{python}
#| eval: false
def load_macro_data(filepath):
    """
    Load manually downloaded macroeconomic data from CSV.
    
    The CSV should contain columns matching the template structure.
    Data sources:
    - CPI, IPI: General Statistics Office (gso.gov.vn)
    - Monetary data: State Bank of Vietnam (sbv.gov.vn)
    - Trade data: General Department of Customs
    
    Parameters
    ----------
    filepath : str
        Path to CSV file with macroeconomic data
    
    Returns
    -------
    pd.DataFrame
        Cleaned macroeconomic data
    """
    macro = pd.read_csv(filepath, parse_dates=["date"])
    
    # Validate required columns
    required_cols = ["date", "cpi", "refinancing_rate", "usd_vnd"]
    missing = set(required_cols) - set(macro.columns)
    if missing:
        raise ValueError(f"Missing required columns: {missing}")
    
    # Sort by date
    macro = macro.sort_values("date").reset_index(drop=True)
    
    # Calculate derived variables if not present
    if "cpi_yoy" not in macro.columns:
        macro["cpi_yoy"] = macro["cpi"].pct_change(12) * 100
    
    return macro
```

### Risk-Free Rate Approximation

Determining an appropriate risk-free rate for Vietnam presents challenges not encountered in developed markets. Unlike the US Treasury market, Vietnam's government bond market is relatively illiquid with limited secondary trading. Several alternatives exist:

1.  **SBV Refinancing Rate**: The policy rate set by the State Bank of Vietnam. Not directly investable but reflects monetary policy stance.

2.  **Government Bond Yields**: One-year or longer-term government bond yields from auction results. More investable but less liquid than US Treasuries.

3.  **Interbank Rates**: Overnight or term interbank lending rates. Reflect short-term funding costs but include credit risk.

4.  **Adjusted US Rate**: US Treasury rate plus expected VND depreciation, following uncovered interest rate parity.

```{python}
#| eval: false
def calculate_risk_free_rate(macro_data, method="refinancing"):
    """
    Calculate risk-free rate proxy for Vietnamese market.
    
    Parameters
    ----------
    macro_data : pd.DataFrame
        DataFrame with macroeconomic data
    method : str
        Method for risk-free rate: 'refinancing', 'bond', or 'adjusted_us'
    
    Returns
    -------
    pd.DataFrame
        DataFrame with date and monthly risk-free rate
    """
    if method == "refinancing":
        # Use SBV refinancing rate, convert annual to monthly
        rf = macro_data[["date", "refinancing_rate"]].copy()
        rf["rf_monthly"] = rf["refinancing_rate"] / 12 / 100
        
    elif method == "adjusted_us":
        # US rate + expected VND depreciation
        # Requires additional data on US rates and exchange rate expectations
        pass
    
    return rf[["date", "rf_monthly"]]
```

## Constructing Vietnamese Fama-French Factors

The Fama-French factor models have become the standard framework for explaining cross-sectional variation in expected stock returns. While Ken French provides factor data for developed markets on his website, Vietnamese market factors must be constructed by researchers.

### Factor Construction Methodology

The construction process follows the original @Fama1993 methodology with adaptations for Vietnamese market structure:

1.  **Universe Definition**: Include all common stocks on HOSE and HNX with at least 12 months of return history and positive book equity.

2.  **Size Sort**: At the end of June each year, sort stocks by market capitalization. Stocks below the median are classified as Small (S), above as Big (B).

3.  **Value Sort**: Using book-to-market ratio from the prior fiscal year end (typically December for Vietnamese firms), sort into three groups based on the 30th and 70th percentiles: Growth (G), Neutral (N), and Value (V).

4.  **Portfolio Formation**: Create six portfolios from the intersection of size and value sorts: SG, SN, SV, BG, BN, BV.

5.  **Factor Calculation**:

    -   SMB = (SG + SN + SV)/3 - (BG + BN + BV)/3
    -   HML = (SV + BV)/2 - (SG + BG)/2

```{python}
#| eval: false
def assign_portfolios(stock_data, date):
    """
    Assign stocks to size and value portfolios at given date.
    
    Parameters
    ----------
    stock_data : pd.DataFrame
        DataFrame with symbol, mktcap, and book_to_market columns
    date : str
        Portfolio formation date (end of June)
    
    Returns
    -------
    pd.DataFrame
        DataFrame with portfolio assignments
    """
    # Filter to formation date
    data = stock_data.query(f"date == '{date}'").copy()
    
    # Require positive book equity
    data = data.query("book_to_market > 0")
    
    # Size breakpoint: median market cap
    size_median = data["mktcap"].median()
    
    # B/M breakpoints: 30th and 70th percentiles
    bm_30 = data["book_to_market"].quantile(0.30)
    bm_70 = data["book_to_market"].quantile(0.70)
    
    # Assign size group
    data["size_group"] = np.where(
        data["mktcap"] <= size_median, "S", "B"
    )
    
    # Assign value group
    data["bm_group"] = np.select(
        [
            data["book_to_market"] <= bm_30,
            data["book_to_market"] >= bm_70
        ],
        ["G", "V"],
        default="N"
    )
    
    # Combined portfolio
    data["portfolio"] = data["size_group"] + data["bm_group"]
    
    return data[["symbol", "size_group", "bm_group", "portfolio"]]


def calculate_ff_factors(returns_data, portfolios):
    """
    Calculate Fama-French SMB and HML factors.
    
    Parameters
    ----------
    returns_data : pd.DataFrame
        Monthly stock returns with symbol and date
    portfolios : pd.DataFrame
        Portfolio assignments from assign_portfolios()
    
    Returns
    -------
    pd.DataFrame
        Monthly factor returns (SMB, HML)
    """
    # Merge returns with portfolio assignments
    data = returns_data.merge(portfolios, on="symbol")
    
    # Calculate value-weighted portfolio returns
    port_returns = (
        data
        .groupby(["date", "portfolio"])
        .apply(
            lambda x: np.average(x["return"], weights=x["mktcap"])
        )
        .reset_index(name="port_return")
        .pivot(index="date", columns="portfolio", values="port_return")
    )
    
    # Calculate factors
    factors = pd.DataFrame(index=port_returns.index)
    
    # SMB: Small minus Big
    factors["SMB"] = (
        (port_returns["SG"] + port_returns["SN"] + port_returns["SV"]) / 3 -
        (port_returns["BG"] + port_returns["BN"] + port_returns["BV"]) / 3
    )
    
    # HML: High minus Low (Value minus Growth)
    factors["HML"] = (
        (port_returns["SV"] + port_returns["BV"]) / 2 -
        (port_returns["SG"] + port_returns["BG"]) / 2
    )
    
    return factors.reset_index()
```

### Extending to Five Factors

Following @Fama2015, we can extend the three-factor model to include profitability (RMW) and investment (CMA) factors. For Vietnamese firms, profitability is typically measured as operating profit divided by book equity, and investment as total asset growth.

```{python}
#| eval: false
def calculate_ff5_factors(returns_data, accounting_data, date):
    """
    Calculate Fama-French five factors for Vietnamese market.
    
    Parameters
    ----------
    returns_data : pd.DataFrame
        Monthly stock returns
    accounting_data : pd.DataFrame
        Fundamental data with profitability and investment measures
    date : str
        Portfolio formation date
    
    Returns
    -------
    pd.DataFrame
        Monthly factor returns (MKT, SMB, HML, RMW, CMA)
    """
    # Calculate profitability: Operating Profit / Book Equity
    accounting_data["op"] = (
        accounting_data["operating_profit"] / 
        accounting_data["book_equity"]
    )
    
    # Calculate investment: Asset Growth
    accounting_data["inv"] = accounting_data["total_assets"].pct_change()
    
    # Sort into profitability terciles
    op_30 = accounting_data["op"].quantile(0.30)
    op_70 = accounting_data["op"].quantile(0.70)
    
    accounting_data["op_group"] = np.select(
        [accounting_data["op"] <= op_30, accounting_data["op"] >= op_70],
        ["W", "R"],  # Weak, Robust
        default="N"
    )
    
    # Sort into investment terciles
    inv_30 = accounting_data["inv"].quantile(0.30)
    inv_70 = accounting_data["inv"].quantile(0.70)
    
    accounting_data["inv_group"] = np.select(
        [accounting_data["inv"] <= inv_30, accounting_data["inv"] >= inv_70],
        ["C", "A"],  # Conservative, Aggressive
        default="N"
    )
    
    # Factor calculations follow similar logic to SMB/HML
    # RMW = Robust - Weak profitability
    # CMA = Conservative - Aggressive investment
    
    return accounting_data
```

## Setting Up a Database for Vietnamese Financial Data

Managing financial data across multiple sources and formats requires a systematic approach to data storage. We recommend using SQLite as the primary database engine for several reasons: it requires no server setup, stores the entire database in a single portable file, supports standard SQL queries, and integrates seamlessly with Python through the built-in sqlite3 module.

### Database Schema Design

Our database schema is designed to support efficient queries for common research tasks while maintaining data integrity. We create separate tables for different data types with appropriate relationships.

```{python}
#| eval: false
import os
import sqlite3

# Create data directory if it doesn't exist
if not os.path.exists("data"):
    os.makedirs("data")

# Initialize SQLite database connection
tidy_finance_vietnam = sqlite3.connect(
    "data/tidy_finance_vietnam.sqlite"
)

# Create tables with explicit schema
cursor = tidy_finance_vietnam.cursor()

# Stock master table
cursor.execute("""
    CREATE TABLE IF NOT EXISTS stock_master (
        symbol TEXT PRIMARY KEY,
        company_name TEXT,
        company_name_en TEXT,
        exchange TEXT,
        industry TEXT,
        listing_date DATE,
        delisting_date DATE
    )
""")

# Daily price table
cursor.execute("""
    CREATE TABLE IF NOT EXISTS stock_prices_daily (
        symbol TEXT,
        date DATE,
        open REAL,
        high REAL,
        low REAL,
        close REAL,
        volume INTEGER,
        value REAL,
        adjusted_close REAL,
        PRIMARY KEY (symbol, date),
        FOREIGN KEY (symbol) REFERENCES stock_master(symbol)
    )
""")

# Fundamental data table
cursor.execute("""
    CREATE TABLE IF NOT EXISTS fundamentals_quarterly (
        symbol TEXT,
        fiscal_year INTEGER,
        fiscal_quarter INTEGER,
        total_assets REAL,
        total_liabilities REAL,
        book_equity REAL,
        revenue REAL,
        operating_profit REAL,
        net_income REAL,
        PRIMARY KEY (symbol, fiscal_year, fiscal_quarter),
        FOREIGN KEY (symbol) REFERENCES stock_master(symbol)
    )
""")

# Factor returns table
cursor.execute("""
    CREATE TABLE IF NOT EXISTS factors_monthly (
        date DATE PRIMARY KEY,
        mkt_rf REAL,
        smb REAL,
        hml REAL,
        rmw REAL,
        cma REAL,
        rf REAL
    )
""")

# Macroeconomic data table
cursor.execute("""
    CREATE TABLE IF NOT EXISTS macro_monthly (
        date DATE PRIMARY KEY,
        cpi REAL,
        cpi_yoy REAL,
        ipi REAL,
        m2_growth REAL,
        credit_growth REAL,
        refinancing_rate REAL,
        usd_vnd REAL
    )
""")

tidy_finance_vietnam.commit()
```

### Storing Data

With the database schema established, we can store our collected data using pandas' to_sql() method.

```{python}
#| eval: false
# Store stock listing data
common_stocks.to_sql(
    name="stock_master",
    con=tidy_finance_vietnam,
    if_exists="replace",
    index=False
)

# Store stock price data
stock_prices.to_sql(
    name="stock_prices_daily",
    con=tidy_finance_vietnam,
    if_exists="replace",
    index=False
)

# Store market indices
vn_index.to_sql(
    name="market_indices",
    con=tidy_finance_vietnam,
    if_exists="replace",
    index=False
)

# Store factor returns
factors_vietnam.to_sql(
    name="factors_monthly",
    con=tidy_finance_vietnam,
    if_exists="replace",
    index=False
)
```

## Querying and Updating the Database

Once data is stored in the database, retrieval is straightforward using SQL queries. The pandas read_sql_query() function executes a SQL statement and returns the results as a DataFrame.

```{python}
#| eval: false
# Query stock prices for specific symbols and date range
query = """
SELECT date, symbol, close, volume
FROM stock_prices_daily
WHERE symbol IN ('VNM', 'VIC', 'FPT', 'VHM', 'VCB')
  AND date >= '2020-01-01'
ORDER BY symbol, date
"""

selected_stocks = pd.read_sql_query(
    sql=query,
    con=tidy_finance_vietnam,
    parse_dates=["date"]
)

# Query factor data merged with market returns
query_factors = """
SELECT f.date, f.mkt_rf, f.smb, f.hml, f.rf,
       m.cpi_yoy, m.credit_growth
FROM factors_monthly f
LEFT JOIN macro_monthly m ON f.date = m.date
WHERE f.date >= '2015-01-01'
ORDER BY f.date
"""

factor_data = pd.read_sql_query(
    sql=query_factors,
    con=tidy_finance_vietnam,
    parse_dates=["date"]
)
```

### Incremental Updates

For ongoing research, we need to update the database with new data as it becomes available. The following workflow handles incremental updates efficiently.

```{python}
#| eval: false
def update_stock_prices(symbols, tidy_finance_vietnam):
    """
    Update stock prices with latest available data.
    
    Parameters
    ----------
    symbols : list
        List of stock symbols to update
    tidy_finance_vietnam : sqlite3.Connection
        Database connection
    """
    for symbol in symbols:
        # Get last date in database
        query = f"""
        SELECT MAX(date) as last_date 
        FROM stock_prices_daily 
        WHERE symbol = '{symbol}'
        """
        result = pd.read_sql_query(query, tidy_finance_vietnam)
        last_date = result["last_date"].iloc[0]
        
        if last_date is None:
            start = "2000-01-01"
        else:
            start = (pd.to_datetime(last_date) + 
                    timedelta(days=1)).strftime("%Y-%m-%d")
        
        end = datetime.today().strftime("%Y-%m-%d")
        
        # Fetch new data
        try:
            new_data = get_stock_history(symbol, start, end)
            if len(new_data) > 0:
                new_data.to_sql(
                    name="stock_prices_daily",
                    con=tidy_finance_vietnam,
                    if_exists="append",
                    index=False
                )
                print(f"Updated {symbol}: {len(new_data)} new records")
        except Exception as e:
            print(f"Error updating {symbol}: {e}")
```

### Database Maintenance

Regular database maintenance ensures optimal performance and data integrity.

```{python}
#| eval: false
# Optimize database
tidy_finance_vietnam.execute("VACUUM")

# Check database integrity
integrity_check = pd.read_sql_query(
    "PRAGMA integrity_check",
    tidy_finance_vietnam
)
print(f"Integrity check: {integrity_check.iloc[0, 0]}")

# Get database statistics
table_stats = pd.read_sql_query("""
    SELECT name, 
           (SELECT COUNT(*) FROM stock_prices_daily) as price_rows,
           (SELECT COUNT(*) FROM stock_master) as stock_count,
           (SELECT COUNT(*) FROM factors_monthly) as factor_months
    FROM sqlite_master
    WHERE type='table' AND name='stock_master'
""", tidy_finance_vietnam)

print(table_stats)

# Close connection when done
tidy_finance_vietnam.close()
```

## Alternative Data Sources for Vietnamese Markets

Beyond traditional price and fundamental data, researchers increasingly incorporate alternative data sources to gain unique insights into market dynamics.

### Foreign Investor Flow Data

Foreign investor flow data is particularly valuable given the significant role of foreign capital in Vietnamese equity markets. The State Securities Commission publishes daily foreign ownership statistics by security.

```{python}
#| eval: false
def get_foreign_trading(symbol, start_date, end_date):
    """
    Retrieve foreign investor trading data for a stock.
    
    Parameters
    ----------
    symbol : str
        Stock ticker symbol
    start_date : str
        Start date
    end_date : str
        End date
    
    Returns
    -------
    pd.DataFrame
        Foreign buy/sell volumes and net flow
    """
    stock = Vnstock().stock(symbol=symbol, source="VCI")
    
    # Get trading data including foreign flows
    data = stock.quote.history(
        start=start_date,
        end=end_date,
        interval="1D"
    )
    
    # Calculate net foreign flow
    if "foreign_buy_volume" in data.columns:
        data["foreign_net"] = (
            data["foreign_buy_volume"] - data["foreign_sell_volume"]
        )
    
    return data
```

### News and Sentiment Data

Media sentiment from Vietnamese financial news sources offers another research avenue. Major outlets such as CafeF, VnExpress Finance, and Vietstock publish real-time news that can be analyzed for market sentiment.

```{python}
#| eval: false
def get_company_news(symbol, limit=50):
    """
    Retrieve recent news for a Vietnamese company.
    
    Parameters
    ----------
    symbol : str
        Stock ticker symbol
    limit : int
        Maximum number of news items
    
    Returns
    -------
    pd.DataFrame
        News headlines and metadata
    """
    company = Vnstock().stock(symbol=symbol, source="TCBS").company
    
    # Get news/events
    news = company.news(limit=limit)
    
    return news
```

## Data Quality and Validation

Ensuring data quality is paramount for rigorous empirical research. Vietnamese financial data, like data from other emerging markets, may contain errors, missing values, and inconsistencies that can bias research results.

### Common Data Quality Issues

1.  **Missing observations**: Trading halts, system errors, or data gaps
2.  **Extreme values**: Potential errors vs. genuine market events
3.  **Corporate action adjustments**: Inconsistencies across data sources
4.  **Stale data**: Delayed fundamental data updates
5.  **Survivorship bias**: Missing delisted companies

```{python}
#| eval: false
def validate_price_data(df):
    """
    Validate price data for common issues.
    
    Parameters
    ----------
    df : pd.DataFrame
        Price data with date, symbol, close, and return columns
    
    Returns
    -------
    dict
        Dictionary of validation results and issues found
    """
    issues = {
        "missing_values": {},
        "extreme_returns": [],
        "duplicates": 0,
        "negative_prices": 0,
        "zero_volume_days": 0
    }
    
    # Check for missing values
    missing_count = df.isnull().sum()
    issues["missing_values"] = missing_count[missing_count > 0].to_dict()
    
    # Check for extreme returns (beyond daily limits)
    # HOSE limit: ±7%, HNX limit: ±10%
    if "return" in df.columns:
        extreme = df[
            (df["return"].abs() > 0.15) &  # Allow some buffer
            (df["return"].notna())
        ]
        if len(extreme) > 0:
            issues["extreme_returns"] = extreme[
                ["date", "symbol", "return"]
            ].to_dict("records")
    
    # Check for duplicate entries
    duplicates = df.duplicated(subset=["date", "symbol"])
    issues["duplicates"] = duplicates.sum()
    
    # Check for negative prices
    if "close" in df.columns:
        issues["negative_prices"] = (df["close"] < 0).sum()
    
    # Check for zero volume days (potential data issues)
    if "volume" in df.columns:
        issues["zero_volume_days"] = (df["volume"] == 0).sum()
    
    return issues


def clean_price_data(df, issues):
    """
    Clean price data based on validation results.
    
    Parameters
    ----------
    df : pd.DataFrame
        Raw price data
    issues : dict
        Validation results from validate_price_data()
    
    Returns
    -------
    pd.DataFrame
        Cleaned price data
    """
    cleaned = df.copy()
    
    # Remove duplicates
    cleaned = cleaned.drop_duplicates(subset=["date", "symbol"])
    
    # Handle extreme returns
    # Option 1: Winsorize at daily limits
    if "return" in cleaned.columns:
        cleaned["return"] = cleaned["return"].clip(lower=-0.10, upper=0.10)
    
    # Forward fill missing prices (with caution)
    # Only for short gaps, flag longer gaps
    
    return cleaned
```

### Cross-Validation with Multiple Sources

When possible, cross-validate data across multiple sources to identify discrepancies.

```{python}
#| eval: false
def cross_validate_prices(symbol, date, sources=["VCI", "TCBS"]):
    """
    Compare price data across multiple sources.
    
    Parameters
    ----------
    symbol : str
        Stock ticker symbol
    date : str
        Date to validate
    sources : list
        Data sources to compare
    
    Returns
    -------
    pd.DataFrame
        Comparison of prices across sources
    """
    results = []
    
    for source in sources:
        try:
            stock = Vnstock().stock(symbol=symbol, source=source)
            data = stock.quote.history(start=date, end=date, interval="1D")
            if len(data) > 0:
                results.append({
                    "source": source,
                    "close": data["close"].iloc[0],
                    "volume": data["volume"].iloc[0]
                })
        except Exception as e:
            results.append({
                "source": source,
                "close": None,
                "volume": None,
                "error": str(e)
            })
    
    comparison = pd.DataFrame(results)
    
    # Check for discrepancies
    if comparison["close"].nunique() > 1:
        print(f"Warning: Price discrepancy for {symbol} on {date}")
    
    return comparison
```

## Practical Workflow Example

To illustrate the complete data workflow, here is an end-to-end example that collects, validates, stores, and retrieves Vietnamese financial data.

```{python}
#| eval: false
# Complete workflow example

# Step 1: Initialize database
import os
import sqlite3

if not os.path.exists("data"):
    os.makedirs("data")

conn = sqlite3.connect("data/tidy_finance_vietnam.sqlite")

# Step 2: Collect stock universe
stock = Vnstock().stock(symbol="VNM", source="VCI")
universe = stock.listing.all_symbols()
hose_stocks = universe.query("exchange == 'HOSE' and type == 'STOCK'")

# Step 3: Collect price data for sample
sample_symbols = ["VNM", "VIC", "VHM", "FPT", "VCB", 
                  "HPG", "MWG", "TCB", "VPB", "MSN"]

price_data, failed = collect_all_stock_data(
    symbols=sample_symbols,
    start_date="2020-01-01",
    end_date="2024-12-31"
)

# Step 4: Validate data
validation_results = validate_price_data(price_data)
print("Validation Results:")
for key, value in validation_results.items():
    print(f"  {key}: {value}")

# Step 5: Clean and store
cleaned_prices = clean_price_data(price_data, validation_results)

cleaned_prices.to_sql(
    name="stock_prices_daily",
    con=conn,
    if_exists="replace",
    index=False
)

# Step 6: Retrieve and analyze
query = """
SELECT symbol, 
       MIN(date) as first_date,
       MAX(date) as last_date,
       COUNT(*) as observations,
       AVG(return) * 252 as annualized_return,
       AVG(volume) as avg_volume
FROM stock_prices_daily
GROUP BY symbol
ORDER BY annualized_return DESC
"""

summary = pd.read_sql_query(query, conn)
print("\nStock Summary:")
print(summary)

# Step 7: Close connection
conn.close()
```

## Key Takeaways

1.  **Market Structure Understanding**: The Vietnamese financial market operates across three exchanges (HOSE, HNX, UPCoM) with distinct characteristics including foreign ownership limits, trading band restrictions, and a T+2 settlement cycle. Researchers must account for these institutional features in empirical analysis.

2.  **vnstock as Primary Data Source**: The vnstock library provides the most comprehensive open-source access to Vietnamese stock data, including historical prices, fundamental data, and corporate actions from multiple broker data sources. It handles the complexities of Vietnamese stock identifiers and data formats.

3.  **Macroeconomic Data Challenges**: Unlike developed markets with standardized APIs (e.g., FRED), Vietnamese macroeconomic data requires manual collection from government sources (GSO, SBV). Researchers should plan for this additional data gathering effort and implement systematic data management practices.

4.  **Factor Model Construction**: Constructing Fama-French factors for Vietnam requires adapting standard methodologies to local market conditions, including appropriate breakpoints for size and value sorts that reflect Vietnamese market structure and accounting standards.

5.  **Database-Centric Workflow**: SQLite provides an efficient and portable database solution for managing Vietnamese financial data across research projects. The structured database approach enables reproducible research workflows, efficient queries, and easy data sharing among collaborators.

6.  **Data Quality Imperative**: Data quality validation is especially important for emerging market data. Implementing systematic checks for missing values, extreme returns, duplicate entries, and cross-source validation helps ensure research reliability and reproducibility.

7.  **Alternative Data Opportunities**: Foreign investor flows, corporate announcements, and media sentiment provide unique research opportunities in the Vietnamese market that can complement traditional price and fundamental analysis. These data sources can reveal insights about market dynamics not captured in standard datasets.

8.  **Continuous Maintenance**: Financial databases require ongoing maintenance including incremental updates, integrity checks, and optimization. Establishing systematic update procedures ensures data currency and database performance over time.