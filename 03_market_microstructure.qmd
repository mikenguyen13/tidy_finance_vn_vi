# Cấu trúc thị trường vi mô tại Việt Nam

::: callout-note
Trong chương này, chúng ta sẽ xem xét cách thức thiết kế thể chế của thị trường chứng khoán Việt Nam, chẳng hạn như phiên giao dịch, giới hạn giá, loại lệnh và thành phần nhà đầu tư, định hình giá cả, lợi nhuận và tính thanh khoản quan sát được. Chúng ta sẽ định lượng các ma sát vi mô và chứng minh tại sao việc bỏ qua các ma sát này dẫn đến suy luận sai lệch trong các bài kiểm tra định giá tài sản.
:::

Cấu trúc vi mô thị trường là nghiên cứu về cách các quy tắc giao dịch, cơ chế xử lý lệnh và thiết kế thị trường ảnh hưởng đến sự hình thành giá, chi phí giao dịch và tính thanh khoản. Lĩnh vực này, được tiên phong bởi @kyle1985continuous, @glosten1985bid và @hasbrouck2007empirical, cung cấp bộ công cụ phân tích để hiểu lý do tại sao giá quan sát được có thể sai lệch so với giá trị cơ bản và trong bao lâu.

Ở các thị trường phát triển với giao dịch điện tử liên tục, các nhà tạo lập thị trường được chỉ định và các ràng buộc pháp lý tối thiểu đối với biến động giá, ma sát cấu trúc vi mô thường là mối quan tâm thứ hai đối với các nhà nghiên cứu làm việc với tần suất hàng tháng hoặc thấp hơn. Trên thị trường chứng khoán Việt Nam, điều này rõ ràng là không đúng. Giới hạn giá hàng ngày, giao dịch mỏng, cơ sở chủ yếu là nhà đầu tư bán lẻ, kích thước đánh dấu rời rạc và không có các thỏa thuận tạo lập thị trường chính thức tạo ra ma sát lan truyền thành lợi nhuận hàng tháng, bóp méo tải yếu tố và suy luận cấp danh mục đầu tư thiên vị. Do đó, bất kỳ phân tích thực nghiệm nghiêm túc nào về chứng khoán Việt Nam đều phải bắt đầu bằng việc đánh giá cẩn thận cấu trúc vi mô thị trường.

Chương này cung cấp đánh giá đó. Trước tiên, chúng tôi mô tả cấu trúc thể chế của giao dịch chứng khoán Việt Nam. Sau đó, chúng tôi phát triển chẩn đoán cho các ma sát gây hậu quả nhất, chẳng hạn như mức giới hạn giá, ngày không lợi nhuận, kém thanh khoản và giao dịch không đồng bộ, đồng thời định lượng mức độ nghiêm trọng của chúng trong phần của các công ty niêm yết. Cuối cùng, chúng tôi rút ra hướng dẫn thực tế để điều chỉnh xây dựng danh mục đầu tư và kiểm tra định giá tài sản.

## Cấu trúc vi mô thị trường là gì?

Giả định trong sách giáo khoa về thị trường không ma sát ngụ ý rằng giá cả liên tục và không tốn kém kết hợp thông tin. Theo giả định này, lợi nhuận quan sát được trên bất kỳ tài sản nào ở bất kỳ tần suất nào bằng lợi nhuận "thực" được quy định bởi các nguyên tắc cơ bản. Cấu trúc vi mô thị trường nới lỏng giả định này bằng cách nhận ra rằng giá được tạo ra bởi một quy trình giao dịch cụ thể với chi phí, ràng buộc và sự không hoàn hảo thực tế.

Khuôn khổ kinh điển của @kyle1985continuous mô hình hóa một thị trường với ba loại người tham gia:

1. một nhà giao dịch hiểu biết về giá trị cơ bản của tài sản,
2. Nhà giao dịch tiếng ồn giao dịch vì lý do thanh khoản, và
3. Một nhà tạo lập thị trường đặt giá hòa vốn trong kỳ vọng.

Thông tin chi tiết quan trọng là nhà tạo lập thị trường không thể phân biệt luồng lệnh được thông báo với luồng lệnh không được thông báo, vì vậy giá điều chỉnh dần dần theo thông tin, tạo ra một khoảng cách giữa giá giao dịch và giá trị cơ bản. Kích thước của nêm này (chênh lệch giá mua-bán) và tốc độ điều chỉnh giá (độ sâu thị trường) là những đối tượng cốt lõi của lý thuyết cấu trúc vi mô.

@glosten1985bid mở rộng khuôn khổ này thành một thiết lập giao dịch tuần tự và cho thấy rằng chênh lệch giá mua-bán có hai thành phần: thành phần lựa chọn bất lợi (bù đắp cho giao dịch chống lại các nhà giao dịch có thông tin) và thành phần xử lý lệnh (bù đắp cho chi phí cơ học của giao dịch). @huang1997components phân tích thêm chênh lệch thành các thành phần chênh lệch thực tế và tác động giá. Những phân hủy này rất quan trọng vì chúng tiết lộ các nguồn chi phí giao dịch khác nhau và có ý nghĩa khác nhau đối với chất lượng thị trường.

Đối với định giá tài sản thực nghiệm, câu hỏi quan trọng là: ở tần suất nào và trong điều kiện nào thì các hiệu ứng cấu trúc vi mô trở nên không đáng kể? Trong các thị trường có tính thanh khoản cao, @bali2016empirical lập luận rằng lợi nhuận hàng tháng phần lớn không bị ô nhiễm cấu trúc vi mô. Ở Việt Nam, như chúng tôi trình bày dưới đây, đây không phải là trường hợp. Hiệu ứng cấu trúc vi mô tồn tại ở tần suất hàng tháng và thậm chí hàng quý đối với một phần đáng kể các công ty niêm yết.

### Giao diện giữa cấu trúc vi mô và định giá tài sản

Giao diện giữa cấu trúc vi mô và định giá tài sản hoạt động thông qua một số kênh. Thứ nhất, bản thân tính thanh khoản thấp có thể là một yếu tố rủi ro được định giá. @amihud2002illiquidity chỉ ra rằng tính thanh khoản thấp dự kiến ​​có mối quan hệ tích cực với lợi nhuận cổ phiếu dự kiến, ngụ ý một khoản phí bảo hiểm thanh khoản. @pastor2003liquidity phát triển một mô hình cân bằng trong đó rủi ro thanh khoản (tức là hiệp phương sai giữa tính thanh khoản của cổ phiếu với tính thanh khoản của thị trường) quyết định một khoản phí bảo hiểm rủi ro. Thứ hai, nhiễu cấu trúc vi mô trong giá cả làm sai lệch các hệ số beta ước tính, hệ số tải nhân tố và thống kê kiểm định. @scholes1977estimating lần đầu tiên xác định sự sai lệch này trong bối cảnh giao dịch không đồng bộ, và @dimson1979risk đề xuất một ước lượng hệ số tổng hợp để hiệu chỉnh nó. Thứ ba, giới hạn giá và các ràng buộc quy định khác kiểm duyệt phân phối lợi nhuận, tạo ra sai lệch cắt cụt trong ước tính biến động, mômen lợi nhuận và thống kê giá trị cực đoan [@kim1997price].

@tbl-microstructure-interface tóm tắt các kênh này và những hệ quả thực nghiệm của chúng.

| Kênh | Cơ chế | Hậu quả thực nghiệm |
|--------------------|------------------|----------------------------------|
| Phần bù rủi ro thanh khoản thấp | Bồi thường cho việc gánh chịu chi phí giao dịch và rủi ro tồn kho | Khả năng dự báo lợi nhuận theo phương pháp đo lường thanh khoản |
| Giao dịch không đồng bộ | Giao dịch không thường xuyên tạo ra giá cả lỗi thời | Hệ số beta lệch xuống, tương quan suy yếu và độ trễ-dẫn giả tạo |
| Giới hạn giá | Kiểm duyệt quy định đối với lợi nhuận hàng ngày | Phân phối lợi nhuận bị cắt cụt, sự lan truyền biến động và tương quan tự động nhân tạo |
| Bước giá rời rạc | Giá bị giới hạn trong một lưới | Biến động giá mua-bán, lợi nhuận rời rạc, biến động có thiên lệch |
| Thành phần nhà đầu tư | Dòng lệnh chủ yếu đến từ nhà đầu tư cá nhân | Giao dịch theo cảm tính, hành vi bầy đàn, định giá dựa trên tâm lý thị trường |

: Các kênh mà qua đó cấu trúc vi mô ảnh hưởng đến định giá tài sản {#tbl-microstructure-interface}

## Kiến trúc giao dịch tại Việt Nam

Việt Nam có hai sàn giao dịch chứng khoán: Sở Giao dịch Chứng khoán Thành phố Hồ Chí Minh (HOSE), thành lập năm 2000 và Sở Giao dịch Chứng khoán Hà Nội (HNX), thành lập năm 2005. HOSE niêm yết các công ty lớn hơn và chiếm phần lớn vốn hóa thị trường và khối lượng giao dịch. HNX niêm yết các công ty nhỏ hơn và cũng điều hành Thị trường công ty đại chúng chưa niêm yết (UPCoM) cho các doanh nghiệp chưa đáp ứng đầy đủ các yêu cầu niêm yết. Cả ba địa điểm đều vận hành hệ thống sổ lệnh giới hạn điện tử mà không có nhà tạo lập thị trường được chỉ định.

### Đặc điểm của Sàn giao dịch

@tbl-exchange-comparison trình bày sự khác biệt cấu trúc giữa HOSE, HNX và UPCoM. Những khác biệt này có ý nghĩa trực tiếp đến tính thanh khoản, phát hiện giá và mức độ nghiêm trọng của ma sát cấu trúc vi mô.

| Tính năng | VÒI | HNX | UPCoM |
|-------------------|------------------|------------------|------------------|
| Thành lập | 2000 | 2005 | 2009 |
| Hạng niêm yết | Vốn hóa lớn | Vốn hóa vừa/nhỏ | Niêm yết trước |
| Giới hạn giá hàng ngày | $\pm$ 7% | $\pm$ 10% | $\pm$ 15% |
| Chế độ kích thước tick | Phân cấp theo giá | Phân cấp theo giá | 100 VNĐ |
| Lô giao dịch | 100 cổ phiếu | 100 cổ phiếu | 100 cổ phiếu |
| Bán khống | Giới hạn | Không có sẵn | Không có sẵn |
| Giới hạn sở hữu nước ngoài | Ngành cụ thể | Ngành cụ thể | Ngành cụ thể |

: So sánh sàn giao dịch: HOSE, HNX và UPCoM {#tbl-exchange-comparison}

Các dải giới hạn giá không đồng nhất trên các sàn giao dịch tạo ra một thí nghiệm tự nhiên để nghiên cứu các hiệu ứng giới hạn. Dải $\pm$ 7% chặt chẽ hơn của HOSE có nghĩa là cổ phiếu vốn hóa lớn thường xuyên bị hạn chế hơn so với cổ phiếu vốn hóa trung bình trên HNX, với điều kiện cùng một cú sốc thông tin. Dải $\pm$ 15% rộng hơn của UPCoM cung cấp môi trường ít bị hạn chế nhất, mặc dù cổ phiếu của nó cũng có tính thanh khoản thấp nhất.

### Phiên giao dịch


Mỗi sàn giao dịch đều hoạt động theo một ngày giao dịch có cấu trúc với các phiên giao dịch riêng biệt. Hiểu rõ cấu trúc phiên giao dịch là điều cần thiết vì cơ chế hình thành giá khác nhau giữa các phiên, và một số phiên có tầm quan trọng đặc biệt đối với việc định giá chuẩn (@tbl-trading-sessions).


| Phiên | Thời gian | Cơ chế | Vai trò khám phá giá |
|---|---|---|---|
| Trước khi khai trương | 08:30–09:00 | Chỉ nhập lệnh, không khớp | Tiết lộ cung / cầu trước khi mở |
| Mở phiên đấu giá (ATO) | 09:00–09:15 | Đấu giá hàng loạt, giá đơn | Đặt giá mở cửa từ các lệnh tích lũy |
| Giao dịch liên tục (Buổi sáng) | 09:15–11:30 | Khớp lệnh giới hạn liên tục | Khám phá giá chính |
| Nghỉ trưa | 11:30–13:00 | Không giao dịch | — |
| Giao dịch liên tục (Buổi chiều) | 13:00–14:30 | Khớp lệnh giới hạn liên tục | Khám phá giá chính |
| Kết thúc phiên đấu giá (ATC) | 14:30–14:45 | Đấu giá hàng loạt, giá đơn | Đặt giá đóng cửa (điểm chuẩn) |
| Sau khi kết thúc | 14:45–15:00 | Giao dịch thỏa thuận (thương lượng) | Khối và thương lượng giao dịch |

: Cấu trúc phiên giao dịch trên HOSE {#tbl-trading-sessions}


Phiên đấu giá đóng cửa (ATC) cần được đặc biệt chú ý. Giá ATC là giá đóng cửa chính thức được sử dụng để tính toán chỉ số, tính toán giá trị tài sản ròng (NAV) và yêu cầu ký quỹ. Vì nó được xác định bởi một phiên đấu giá duy nhất, nên nó có thể bị thao túng bởi các lệnh được đặt vào thời điểm chiến lược, một hiện tượng đã được ghi nhận ở nhiều thị trường mới nổi [@comerton2009anonymity; @hillion2004manipulation]. Các nhà nghiên cứu sử dụng giá đóng cửa hàng ngày nên lưu ý rằng giá ATC có thể không phản ánh trạng thái cân bằng của phiên giao dịch liên tục, đặc biệt đối với các cổ phiếu kém thanh khoản, nơi một lệnh lớn duy nhất có thể làm thay đổi giá đóng cửa.

### Các loại lệnh và quy tắc khớp lệnh

Các sàn giao dịch Việt Nam hỗ trợ một số loại lệnh hạn chế so với các thị trường phát triển (@tbl-order-types).

| Loại lệnh | Mô tả | Tính khả dụng |
|-----------------------|-------------------------|-------------------------|
| Lệnh giới hạn (LO) | Chỉ định giá và số lượng | Tất cả các phiên |
| Lệnh thị trường (ATO/ATC) | Các trận đấu với giá đấu giá | Chỉ phiên đấu giá |
| Giới hạn thị trường (MTL) | Chuyển đổi thành giới hạn ở mức tốt nhất hiện có | Chỉ HNX |

: Các loại lệnh có sẵn {#tbl-order-types}

Việc không có các lệnh iceberg, lệnh dừng và lệnh ẩn đồng nghĩa với việc toàn bộ sổ lệnh giới hạn đều hiển thị cho tất cả người tham gia. Mặc dù điều này tăng cường tính minh bạch trước giao dịch, nhưng nó cũng có nghĩa là các lệnh lớn của tổ chức phải đối mặt với rủi ro rò rỉ thông tin đáng kể, điều này có thể làm giảm sự tham gia của các tổ chức và làm giảm độ sâu của thị trường.

Các lệnh được khớp dựa trên nguyên tắc ưu tiên giá-thời gian nghiêm ngặt trong các phiên giao dịch liên tục. Trong các phiên đấu giá, một giá thanh toán duy nhất được xác định nhằm tối đa hóa khối lượng giao dịch được thực hiện. Nếu nhiều giá thỏa mãn tiêu chí này, giá gần nhất với giá đóng cửa trước đó sẽ được chọn.

### Cấu trúc kích thước dấu tích

Bước giá trên HOSE được phân cấp theo mức giá, điều này tạo ra sự gián đoạn trong chênh lệch giá mua-bán tính theo tỷ lệ phần trăm của giá (@tbl-tick-sizes).

| Price Range (VND) | Tick Size (VND) | Minimum Spread as % of Midpoint |
|---|---|---|
| < 10,000 | 10 | 0.10% at 10,000 |
| 10,000–49,900 | 50 | 0.10% at 50,000 |
| ≥ 50,000 | 100 | 0.20% at 50,000 |

: Tick Size Schedule on HOSE {#tbl-tick-sizes}

Việc nhảy vọt từ mức giá 50 VND lên mức giá 100 VND tại ranh giới 50.000 VND có nghĩa là chênh lệch giá tối thiểu tăng gấp đôi một cách không liên tục. Điều này tạo ra một "vách đá kích thước bước giá" có thể ảnh hưởng đến phân bố giá mua-bán theo mặt cắt ngang và do đó, ảnh hưởng đến việc đo lường tính thanh khoản thấp [@vo2023minimum]. @bessembinder2003trade đã ghi nhận những hiệu ứng tương tự ở các thị trường khác có cấu trúc bước giá phân cấp.

### Investor Composition

The Vietnamese equity market is predominantly driven by retail investors. While foreign institutional investors account for a meaningful share of market capitalization (particularly in blue-chip stocks subject to foreign ownership limits), daily trading volume is overwhelmingly generated by domestic retail accounts.

```{python}
#| label: fig-investor-composition
#| fig-cap: "Approximate Investor Composition by Trading Value on HOSE"
import matplotlib.pyplot as plt
import numpy as np

categories = [
    "Domestic Retail",
    "Domestic Institutional",
    "Foreign Institutional",
    "Foreign Retail"
]
shares = [85, 5, 8, 2]
colors = ["#2C73D2", "#0089BA", "#00B7C7", "#5DCEAF"]

fig, ax = plt.subplots(figsize=(6.5, 4))
bars = ax.barh(categories, shares, color=colors, edgecolor="white", height=0.6)

for bar, share in zip(bars, shares):
    ax.text(
        bar.get_width() + 1, bar.get_y() + bar.get_height() / 2,
        f"{share}%", va="center", fontsize=10
    )

ax.set_xlabel("Share of Trading Value (%)")
ax.set_xlim(0, 100)
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.tight_layout()
plt.show()
```

This retail dominance has several consequences for microstructure. First, retail investors tend to submit smaller orders and trade more frequently, generating high message-to-trade ratios but limited depth at each price level. Second, retail order flow is more susceptible to herding and sentiment, which can amplify momentum and generate excess volatility [@barber2009just; @kaniel2012individual]. Third, the limited institutional presence means that sophisticated liquidity provision is scarce, particularly in mid- and small-cap stocks.

## Price Limits and Their Consequences

Vietnam enforces daily price limits on all listed equities. A stock's price cannot move beyond a fixed percentage of the previous day's closing price within a single trading day. The limit bands are $\pm$ 7% on HOSE, $\pm$ 10% on HNX, and $\pm$ 15% on UPCoM.

### Theoretical Framework

Price limits were introduced with the stated goal of reducing volatility and preventing panic-driven price dislocations. However, the academic literature presents a more nuanced picture. The "magnet effect" hypothesis [@subrahmanyam1994circuit] predicts that price limits actually accelerate price movement toward the limit as traders rush to execute before the limit is hit. The "delayed price discovery" hypothesis [@Fama1989] argues that limits merely postpone inevitable price adjustments, creating volatility spillover into subsequent days.

Formally, let $P_t^*$ denote the equilibrium price on day $t$ and $P_{t-1}^c$ the previous closing price. The observed return is:

$$
r_t^{obs} = \begin{cases}
\bar{L} & \text{if } r_t^* \geq \bar{L} \\
r_t^* & \text{if } \underline{L} < r_t^* < \bar{L} \\
\underline{L} & \text{if } r_t^* \leq \underline{L}
\end{cases}
$$ {#eq-price-limit}

where $r_t^* = \ln(P_t^* / P_{t-1}^c)$ is the latent (unconstrained) return, $\bar{L}$ is the upper limit, and $\underline{L}$ is the lower limit. The observed return $r_t^{obs}$ is a censored version of the true return. This censoring has several consequences:

1.  **Truncated moments**: The observed variance $\text{Var}(r_t^{obs}) < \text{Var}(r_t^*)$ because extreme returns are clipped. This biases downward any volatility-based risk measure.

2.  **Artificial autocorrelation**: When $r_t^{obs} = \bar{L}$ and $r_{t+1}^{obs} > 0$ (continued adjustment the next day), the return series exhibits positive autocorrelation that is purely mechanical, not informational.

3.  **Volatility spillover**: Define excess volatility on day $t+1$ as $\sigma_{t+1}^2 - E[\sigma_{t+1}^2 | \text{no limit hit on day } t]$. @kim1997price and @chu2019forecasting document significant positive spillover, where days following limit hits exhibit abnormally high volatility.

4.  **Biased extreme value statistics**: Measures such as Value-at-Risk, Expected Shortfall, and maximum drawdown are mechanically bounded by the limit, understating true tail risk.

### Detecting Price Limit Hits

We now implement a diagnostic to detect price limit hits in the daily data.

```{python}
#| label: detect-limit-hits
import pandas as pd
import numpy as np
import sqlite3

# Load daily price data
tidy_finance = sqlite3.connect(database="data/tidy_finance_python.sqlite")

# Assume prices_daily contains: symbol, date, close, exchange
prices_daily = pd.read_sql_query(
    # , exchange
    sql="""
        SELECT symbol, date, close
        FROM prices_daily
    """,
    con=tidy_finance,
    parse_dates=["date"]
).dropna()
```

```{python}
#| eval: false
# Define limit bands by exchange
limit_bands = {"HOSE": 0.07, "HNX": 0.10, "UPCoM": 0.15}

prices_daily = prices_daily.sort_values(["symbol", "date"])
prices_daily["prev_close"] = prices_daily.groupby("symbol")["close"].shift(1)
prices_daily["ret"] = prices_daily["close"] / prices_daily["prev_close"] - 1
prices_daily["limit_band"] = prices_daily["exchange"].map(limit_bands)

# A limit hit occurs when the return is within 0.1% of the theoretical limit
tolerance = 0.001
prices_daily["upper_hit"] = (
    prices_daily["ret"] >= prices_daily["limit_band"] - tolerance
)
prices_daily["lower_hit"] = (
    prices_daily["ret"] <= -prices_daily["limit_band"] + tolerance
)
prices_daily["limit_hit"] = (
    prices_daily["upper_hit"] | prices_daily["lower_hit"]
)
```

### Frequency of Limit Hits

```{python}
#| eval: false
#| label: fig-limit-hit-frequency
#| fig-cap: "Monthly Frequency of Price Limit Hits by Exchange"
prices_daily["year_month"] = prices_daily["date"].dt.to_period("M")

limit_hit_monthly = (
    prices_daily
    .groupby(["year_month", "exchange"])
    .agg(
        total_obs=("limit_hit", "count"),
        limit_hits=("limit_hit", "sum")
    )
    .reset_index()
)
limit_hit_monthly["hit_rate"] = (
    limit_hit_monthly["limit_hits"] / limit_hit_monthly["total_obs"]
)
limit_hit_monthly["date"] = limit_hit_monthly["year_month"].dt.to_timestamp()

fig, ax = plt.subplots(figsize=(8, 4))

for exchange, color in zip(
    ["HOSE", "HNX", "UPCoM"], ["#2C73D2", "#FF6B6B", "#5DCEAF"]
):
    subset = limit_hit_monthly[limit_hit_monthly["exchange"] == exchange]
    ax.plot(
        subset["date"], subset["hit_rate"] * 100,
        label=exchange, color=color, linewidth=1.2
    )

ax.set_ylabel("Limit Hit Rate (%)")
ax.set_xlabel("")
ax.legend(frameon=False)
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.tight_layout()
plt.show()
```

### Volatility Spillover Test

Following @kim1997price, we test whether days following a limit hit exhibit abnormally high volatility. Define the dummy variable $D_t = 1$ if a limit hit occurred on day $t$, and estimate:

$$
\sigma_{t+1}^2 = \alpha + \beta D_t + \gamma \sigma_t^2 + \varepsilon_{t+1}
$$ {#eq-vol-spillover}

where $\sigma_t^2$ is the squared return. A positive and significant $\beta$ indicates volatility spillover attributable to the price limit.

```{python}
#| eval: false
#| label: volatility-spillover-test
import statsmodels.api as sm

# Panel-level volatility spillover test
prices_daily["sq_ret"] = prices_daily["ret"] ** 2
prices_daily["sq_ret_lead"] = prices_daily.groupby("symbol")["sq_ret"].shift(-1)
prices_daily["limit_hit_int"] = prices_daily["limit_hit"].astype(int)

spillover_data = prices_daily.dropna(subset=["sq_ret_lead", "sq_ret"])

X = sm.add_constant(spillover_data[["limit_hit_int", "sq_ret"]])
y = spillover_data["sq_ret_lead"]

model = sm.OLS(y, X).fit(cov_type="cluster", cov_kwds={"groups": spillover_data["symbol"]})

spillover_results = pd.DataFrame({
    "Coefficient": model.params,
    "Std. Error": model.bse,
    "t-stat": model.tvalues,
    "p-value": model.pvalues
}).round(6)

print(spillover_results)
```

::: callout-tip
A significant positive coefficient on the limit hit dummy confirms that Vietnamese price limits do not eliminate volatility, they merely redistribute it across days. This has direct implications for risk management: daily VaR measures computed from censored returns understate true risk exposure.
:::

### Return Autocorrelation Induced by Price Limits

Price limits mechanically induce positive autocorrelation in returns. To quantify this, we compute the first-order autocorrelation coefficient separately for stocks that hit limits frequently versus those that do not.

```{python}
#| eval: false
#| label: tbl-autocorrelation-by-limit
#| tbl-cap: "Return Autocorrelation by Price Limit Hit Frequency"

# Classify stocks by limit hit frequency
stock_limit_freq = (
    prices_daily
    .groupby("symbol")
    .agg(
        hit_rate=("limit_hit", "mean"),
        n_obs=("ret", "count")
    )
    .query("n_obs >= 250")  # At least 1 year of data
)

stock_limit_freq["limit_group"] = pd.qcut(
    stock_limit_freq["hit_rate"], q=3,
    labels=["Low", "Medium", "High"]
)

# Compute autocorrelation by group
def compute_autocorr(group_symbols):
    subset = prices_daily[prices_daily["symbol"].isin(group_symbols)].copy()
    subset["ret_lag"] = subset.groupby("symbol")["ret"].shift(1)
    return subset[["ret", "ret_lag"]].dropna().corr().iloc[0, 1]

autocorr_results = []
for group in ["Low", "Medium", "High"]:
    symbols = stock_limit_freq[stock_limit_freq["limit_group"] == group].index
    ac = compute_autocorr(symbols)
    n_stocks = len(symbols)
    avg_hit_rate = stock_limit_freq.loc[symbols, "hit_rate"].mean()
    autocorr_results.append({
        "Group": group,
        "N Stocks": n_stocks,
        "Avg Limit Hit Rate (%)": round(avg_hit_rate * 100, 2),
        "AR(1)": round(ac, 4)
    })

pd.DataFrame(autocorr_results).style.hide(axis="index")
```

The expected pattern is a monotonically increasing autocorrelation from the Low to High limit-hit group, confirming that the observed serial dependence in returns is at least partly an artifact of price censoring rather than genuine return predictability.

## Liquidity, Thin Trading, and Zero Returns

Liquidity (i.e., the ability to trade quickly at low cost without moving the price) is a first-order concern in Vietnamese equities. A substantial fraction of listed firms, particularly on HNX and UPCoM, experience chronic illiquidity characterized by infrequent trading, wide bid-ask spreads, and frequent zero-return days.

### Measuring Liquidity

The academic literature has developed numerous liquidity measures, each capturing a different dimension of market quality. @#tbl-liquidity-measures summarizes the measures most applicable to Vietnamese data, given typical data availability.

| Measure | Formula | Interpretation | Data Required |
|------------------|------------------|------------------|------------------|
| Turnover ratio | $\text{TO}_{i,t} = \frac{\text{Volume}_{i,t}}{\text{Shares Outstanding}_{i}}$ | Trading intensity relative to float | Volume, shares outstanding |
| Amihud illiquidity | $\text{ILLIQ}_{i,t} = \frac{1}{D} \sum_{d=1}^{D} \frac{|r_{i,d}|}{V_{i,d}}$ | Price impact per unit of volume | Daily returns, daily volume |
| Zero-return proportion | $\text{ZR}_{i,t} = \frac{\#\{d : r_{i,d} = 0\}}{D}$ | Frequency of non-trading or stale pricing | Daily returns |
| Roll spread | $\hat{S}_i = 2\sqrt{-\text{Cov}(r_{i,d}, r_{i,d-1})}$ | Effective bid-ask spread estimate | Daily returns |
| Bid-ask spread | $\text{BA}_{i,d} = \frac{\text{Ask}_{i,d} - \text{Bid}_{i,d}}{(\text{Ask}_{i,d} + \text{Bid}_{i,d})/2}$ | Direct transaction cost | Quote data |

: Liquidity Measures for Vietnamese Equities {#tbl-liquidity-measures}

The Amihud illiquidity ratio [@amihud2002illiquidity] is particularly useful because it requires only daily return and volume data. It captures the price impact of trading (i.e., the return per unit of currency volume) and has been shown to correlate well with more sophisticated microstructure-based measures such as the effective spread [see @goyenko2009liquidity and @goyenko2009stock for a comprehensive comparison].

### Computing Liquidity Diagnostics

```{python}
#| label: compute-liquidity
#| eval: false
# Compute standard liquidity measures at the stock-month level
prices_daily["abs_ret"] = prices_daily["ret"].abs()
prices_daily["zero_return"] = (prices_daily["ret"] == 0).astype(int)
prices_daily["year_month"] = prices_daily["date"].dt.to_period("M")

# Assume volume is in shares and value is in VND
# Amihud: average |ret| / value (in billions VND)
prices_daily["amihud_daily"] = np.where(
    prices_daily["value"] > 0,
    prices_daily["abs_ret"] / (prices_daily["value"] / 1e9),
    np.nan
)

liquidity_monthly = (
    prices_daily
    .groupby(["symbol", "year_month"])
    .agg(
        zero_return_share=("zero_return", "mean"),
        avg_turnover=("turnover", "mean"),
        amihud=("amihud_daily", "mean"),
        trading_days=("ret", "count"),
        avg_daily_value=("value", "mean")
    )
    .reset_index()
)

# Flag severely illiquid stock-months
liquidity_monthly["illiquid_flag"] = (
    (liquidity_monthly["zero_return_share"] > 0.5) |
    (liquidity_monthly["trading_days"] < 10) |
    (liquidity_monthly["avg_daily_value"] < 1e8)  # < 100M VND/day
)
```

### Cross-Sectional Distribution of Liquidity

```{python}
#| label: tbl-liquidity-distribution
#| eval: false
#| tbl-cap: "Cross-Sectional Distribution of Liquidity Measures (Latest Full Year)"

latest_year = liquidity_monthly["year_month"].dt.year.max()
annual_liq = (
    liquidity_monthly[liquidity_monthly["year_month"].dt.year == latest_year]
    .groupby("symbol")
    .agg(
        zero_return_share=("zero_return_share", "mean"),
        avg_turnover=("avg_turnover", "mean"),
        amihud=("amihud", "mean"),
        avg_daily_value_m=("avg_daily_value", lambda x: x.mean() / 1e6)
    )
)

summary_stats = annual_liq.describe(percentiles=[0.10, 0.25, 0.50, 0.75, 0.90]).T
summary_stats = summary_stats[
    ["mean", "std", "10%", "25%", "50%", "75%", "90%"]
].round(4)
summary_stats.columns = ["Mean", "Std", "P10", "P25", "Median", "P75", "P90"]
summary_stats.index = [
    "Zero-Return Share",
    "Avg Daily Turnover",
    "Amihud Illiquidity",
    "Avg Daily Value (M VND)"
]
summary_stats
```

### Liquidity Distribution Across Exchanges

```{python}
#| label: fig-liquidity-by-exchange
#| eval: false
#| fig-cap: "Distribution of Zero-Return Share and Amihud Illiquidity by Exchange"

# Merge exchange info
stock_exchange = (
    prices_daily[["symbol", "exchange"]]
    .drop_duplicates("symbol")
)
annual_liq_exch = annual_liq.merge(
    stock_exchange, left_index=True, right_on="symbol"
)

fig, axes = plt.subplots(1, 2, figsize=(10, 4))

# Zero-return share
for exchange, color in zip(
    ["HOSE", "HNX", "UPCoM"], ["#2C73D2", "#FF6B6B", "#5DCEAF"]
):
    subset = annual_liq_exch[annual_liq_exch["exchange"] == exchange]
    axes[0].hist(
        subset["zero_return_share"], bins=30, alpha=0.6,
        color=color, label=exchange, density=True
    )
axes[0].set_xlabel("Zero-Return Share")
axes[0].set_ylabel("Density")
axes[0].legend(frameon=False)
axes[0].spines["top"].set_visible(False)
axes[0].spines["right"].set_visible(False)

# Amihud (log scale)
for exchange, color in zip(
    ["HOSE", "HNX", "UPCoM"], ["#2C73D2", "#FF6B6B", "#5DCEAF"]
):
    subset = annual_liq_exch[annual_liq_exch["exchange"] == exchange]
    amihud_log = np.log(subset["amihud"].clip(lower=1e-10))
    axes[1].hist(
        amihud_log, bins=30, alpha=0.6,
        color=color, label=exchange, density=True
    )
axes[1].set_xlabel("Log Amihud Illiquidity")
axes[1].set_ylabel("Density")
axes[1].legend(frameon=False)
axes[1].spines["top"].set_visible(False)
axes[1].spines["right"].set_visible(False)

plt.tight_layout()
plt.show()
```

The distributions typically reveal a bimodal pattern: HOSE stocks cluster at low illiquidity values, while HNX and especially UPCoM stocks exhibit a long right tail of extreme illiquidity. This heterogeneity implies that a single liquidity filter or treatment is insufficient for the entire cross-section.

### Time Variation in Aggregate Liquidity

Market-wide liquidity is not constant. It deteriorates during crises, policy uncertainty, and periods of capital outflow, and improves during bull markets and periods of foreign inflow. The time variation in aggregate liquidity is itself a risk factor [@pastor2003liquidity].

```{python}
#| label: fig-aggregate-liquidity
#| eval: false
#| fig-cap: "Time Series of Aggregate Liquidity (Market-Wide Amihud Illiquidity)"

agg_liquidity = (
    liquidity_monthly
    .groupby("year_month")
    .agg(
        median_amihud=("amihud", "median"),
        median_zero_ret=("zero_return_share", "median"),
        total_value=("avg_daily_value", "sum")
    )
    .reset_index()
)
agg_liquidity["date"] = agg_liquidity["year_month"].dt.to_timestamp()

fig, ax1 = plt.subplots(figsize=(8, 4))

ax1.plot(
    agg_liquidity["date"],
    np.log(agg_liquidity["median_amihud"].clip(lower=1e-10)),
    color="#2C73D2", linewidth=1.2
)
ax1.set_ylabel("Log Median Amihud", color="#2C73D2")
ax1.tick_params(axis="y", labelcolor="#2C73D2")

ax2 = ax1.twinx()
ax2.fill_between(
    agg_liquidity["date"],
    agg_liquidity["median_zero_ret"] * 100,
    alpha=0.3, color="#FF6B6B"
)
ax2.set_ylabel("Median Zero-Return Share (%)", color="#FF6B6B")
ax2.tick_params(axis="y", labelcolor="#FF6B6B")

ax1.spines["top"].set_visible(False)
plt.tight_layout()
plt.show()
```

::: callout-important
## Practical Recommendation

Before any asset pricing analysis, apply the following liquidity filter: exclude stock-months where the zero-return share exceeds 50%, where fewer than 15 trading days are observed, or where average daily trading value falls below a threshold (e.g., 100 million VND). Document the filter explicitly, and report sensitivity of results to alternative thresholds.
:::

## Bid-Ask Spread Estimation

In the absence of comprehensive quote data, the effective bid-ask spread can be estimated from transaction data using the method of @roll1984simple. The Roll estimator exploits the fact that if the bid-ask bounce is the sole source of negative serial covariance in returns, then:

$$
\hat{S}_{\text{Roll}} = 2\sqrt{-\text{Cov}(\Delta p_t, \Delta p_{t-1})}
$$ {#eq-roll}

where $\Delta p_t = p_t - p_{t-1}$ is the price change. When the autocovariance is positive (which occurs when information-driven serial correlation dominates the bid-ask bounce), the Roll estimator is undefined. @hasbrouck2009trading proposes a Bayesian variant that handles this case by imposing a prior on the spread.

```{python}
#| label: compute-roll-spread
#| eval: false
# Compute Roll spread estimate at the stock-month level
prices_daily["dprice"] = prices_daily.groupby("symbol")["close"].diff()
prices_daily["dprice_lag"] = prices_daily.groupby("symbol")["dprice"].shift(1)

roll_cov = (
    prices_daily
    .groupby(["symbol", "year_month"])
    .apply(
        lambda g: g[["dprice", "dprice_lag"]].dropna().cov().iloc[0, 1],
        include_groups=False
    )
    .reset_index(name="autocovariance")
)

# Roll spread is defined only when autocovariance is negative
roll_cov["roll_spread"] = np.where(
    roll_cov["autocovariance"] < 0,
    2 * np.sqrt(-roll_cov["autocovariance"]),
    np.nan
)

# As a percentage of price
roll_cov = roll_cov.merge(
    prices_daily.groupby(["symbol", "year_month"])["close"].mean()
    .reset_index(name="avg_price"),
    on=["symbol", "year_month"]
)
roll_cov["roll_spread_pct"] = roll_cov["roll_spread"] / roll_cov["avg_price"] * 100
```

```{python}
#| label: tbl-roll-spread-summary
#| eval: false
#| tbl-cap: "Distribution of Roll Spread Estimates (% of Price)"

roll_summary = (
    roll_cov
    .dropna(subset=["roll_spread_pct"])
    .groupby("year_month")["roll_spread_pct"]
    .describe(percentiles=[0.25, 0.50, 0.75])
    .reset_index()
)

# Show latest year summary
latest_year_roll = roll_cov[
    roll_cov["year_month"].dt.year == roll_cov["year_month"].dt.year.max()
]
print(
    latest_year_roll["roll_spread_pct"]
    .dropna()
    .describe(percentiles=[0.10, 0.25, 0.50, 0.75, 0.90])
    .round(3)
)
```

## Non-Synchronous Trading Bias

When stocks do not trade at the same frequency or at the same times, observed returns are misaligned. This non-synchronous trading bias, first formalized by @scholes1977estimating and @lo1990econometric, is one of the most consequential microstructure effects for asset pricing in thin markets.

### The Problem

Suppose the true (unobserved) return process for stock $i$ follows a single-factor model:

$$
r_{i,t}^* = \alpha_i + \beta_i r_{m,t}^* + \varepsilon_{i,t}
$$ {#eq-true-factor}

where $r_{m,t}^*$ is the true market return and $\beta_i$ is the true beta. If stock $i$ last traded $k$ days before the end of day $t$, the observed return incorporates information only up to day $t - k$. @scholes1977estimating show that the OLS estimate of beta from regressing observed returns on observed market returns is:

$$
\hat{\beta}_i^{OLS} = \beta_i \cdot \pi_i
$$ {#eq-beta-bias}

where $\pi_i$ is the probability that stock $i$ trades on any given day. For a stock that trades on only 50% of days, the OLS beta is biased downward by 50%. This bias is severe in Vietnam, where many small-cap stocks trade on fewer than half of all trading days.

### Quantifying the Bias

```{python}
#| label: fig-trading-frequency
#| eval: false
#| fig-cap: "Distribution of Daily Trading Frequency Across Listed Stocks"

# Compute trading frequency: proportion of market days with nonzero volume
market_days = prices_daily.groupby("year_month")["date"].nunique()
trading_freq = (
    prices_daily[prices_daily["value"] > 0]
    .groupby(["symbol", "year_month"])["date"]
    .nunique()
    .reset_index(name="days_traded")
)
trading_freq = trading_freq.merge(
    market_days.reset_index().rename(columns={"date": "market_days"}),
    on="year_month"
)
trading_freq["trade_prob"] = trading_freq["days_traded"] / trading_freq["market_days"]

# Annual average
annual_trade_freq = (
    trading_freq
    .groupby("symbol")["trade_prob"]
    .mean()
    .reset_index(name="avg_trade_prob")
)

fig, ax = plt.subplots(figsize=(7, 4))
ax.hist(
    annual_trade_freq["avg_trade_prob"], bins=50,
    color="#2C73D2", edgecolor="white", alpha=0.8
)
ax.axvline(
    annual_trade_freq["avg_trade_prob"].median(),
    color="#FF6B6B", linestyle="--", linewidth=1.5,
    label=f"Median = {annual_trade_freq['avg_trade_prob'].median():.2f}"
)
ax.set_xlabel("Average Trading Probability (Fraction of Market Days)")
ax.set_ylabel("Number of Stocks")
ax.legend(frameon=False)
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.tight_layout()
plt.show()
```

### The Dimson Beta Correction

@dimson1979risk proposes a simple correction: include lagged and leading market returns in the beta regression:

$$
r_{i,t} = \alpha_i + \sum_{k=-K}^{K} \beta_{i,k} \, r_{m,t-k} + \varepsilon_{i,t}
$$ {#eq-dimson}

The Dimson-corrected beta is $\hat{\beta}_i^{Dimson} = \sum_{k=-K}^{K} \hat{\beta}_{i,k}$. Typically $K = 1$ or $K = 2$ is sufficient. The summed coefficients capture the full response of the stock's observed return to market information, regardless of when the stock actually trades.

```{python}
#| label: dimson-beta-estimation
#| eval: false
# Estimate Dimson betas with K=1 lag and lead
# Merge market return
market_ret = (
    prices_daily
    .groupby("date")
    .apply(
        lambda g: np.average(g["ret"].dropna(), weights=g["mktcap"].loc[g["ret"].dropna().index])
        if g["ret"].dropna().shape[0] > 0 else np.nan,
        include_groups=False
    )
    .reset_index(name="rm")
)

prices_daily = prices_daily.merge(market_ret, on="date", how="left")
prices_daily["rm_lag1"] = prices_daily.groupby("symbol")["rm"].shift(1)
prices_daily["rm_lead1"] = prices_daily.groupby("symbol")["rm"].shift(-1)

def estimate_dimson_beta(group):
    """Estimate OLS and Dimson(K=1) betas for a single stock."""
    g = group.dropna(subset=["ret", "rm", "rm_lag1", "rm_lead1"])
    if len(g) < 60:
        return pd.Series({"beta_ols": np.nan, "beta_dimson": np.nan, "n_obs": len(g)})

    # OLS beta
    X_ols = sm.add_constant(g["rm"])
    ols_model = sm.OLS(g["ret"], X_ols).fit()
    beta_ols = ols_model.params["rm"]

    # Dimson beta
    X_dim = sm.add_constant(g[["rm_lag1", "rm", "rm_lead1"]])
    dim_model = sm.OLS(g["ret"], X_dim).fit()
    beta_dimson = dim_model.params[["rm_lag1", "rm", "rm_lead1"]].sum()

    return pd.Series({
        "beta_ols": beta_ols,
        "beta_dimson": beta_dimson,
        "n_obs": len(g)
    })

beta_comparison = (
    prices_daily
    .groupby("symbol")
    .apply(estimate_dimson_beta, include_groups=False)
    .reset_index()
)
```

```{python}
#| label: fig-beta-comparison
#| eval: false
#| fig-cap: "OLS Beta vs. Dimson-Corrected Beta"

beta_valid = beta_comparison.dropna()

fig, ax = plt.subplots(figsize=(6, 6))
ax.scatter(
    beta_valid["beta_ols"], beta_valid["beta_dimson"],
    alpha=0.3, s=10, color="#2C73D2"
)
lims = [
    min(ax.get_xlim()[0], ax.get_ylim()[0]),
    max(ax.get_xlim()[1], ax.get_ylim()[1])
]
ax.plot(lims, lims, "--", color="gray", linewidth=1)
ax.set_xlabel("OLS Beta")
ax.set_ylabel("Dimson Beta (K=1)")
ax.set_aspect("equal")
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.tight_layout()
plt.show()
```

The scatter plot should reveal a systematic pattern: Dimson betas exceed OLS betas for most stocks, with the discrepancy largest for thinly traded stocks. Points above the 45-degree line indicate stocks whose OLS betas are biased downward by non-synchronous trading.

```{python}
#| label: tbl-beta-bias-by-liquidity
#| eval: false
#| tbl-cap: "Beta Bias by Trading Frequency Tercile"

beta_with_freq = beta_valid.merge(annual_trade_freq, on="symbol")
beta_with_freq["freq_tercile"] = pd.qcut(
    beta_with_freq["avg_trade_prob"], q=3,
    labels=["Low (Thin)", "Medium", "High (Liquid)"]
)

beta_bias_summary = (
    beta_with_freq
    .groupby("freq_tercile")
    .agg(
        n_stocks=("symbol", "count"),
        avg_trade_prob=("avg_trade_prob", "mean"),
        mean_beta_ols=("beta_ols", "mean"),
        mean_beta_dimson=("beta_dimson", "mean"),
        median_beta_ols=("beta_ols", "median"),
        median_beta_dimson=("beta_dimson", "median")
    )
    .round(3)
)

beta_bias_summary["bias_pct"] = (
    (beta_bias_summary["mean_beta_dimson"] - beta_bias_summary["mean_beta_ols"])
    / beta_bias_summary["mean_beta_dimson"] * 100
).round(1)

beta_bias_summary
```

::: callout-warning
For the thinnest-traded tercile, OLS beta underestimates true systematic risk by 20-40% on average. Using uncorrected betas for cost of equity estimation or factor model tests will produce systematically incorrect results for these stocks.
:::

### The Scholes-Williams Estimator

An alternative correction, proposed by @scholes1977estimating, estimates beta as:

$$
\hat{\beta}_i^{SW} = \frac{\hat{\beta}_{i,-1} + \hat{\beta}_{i,0} + \hat{\beta}_{i,+1}}{1 + 2\hat{\rho}_m}
$$ {#eq-sw}

where $\hat{\beta}_{i,k}$ is the slope from regressing $r_{i,t}$ on $r_{m,t-k}$ alone, and $\hat{\rho}_m$ is the first-order autocorrelation of the market return. The Scholes-Williams estimator is consistent under the assumption that non-trading is the sole source of serial cross-correlation, while the Dimson estimator is more robust to additional sources of lead-lag structure.

```{python}
#| label: scholes-williams-beta
#| eval: false
def estimate_sw_beta(group):
    """Estimate Scholes-Williams beta."""
    g = group.dropna(subset=["ret", "rm", "rm_lag1", "rm_lead1"])
    if len(g) < 60:
        return np.nan

    # Separate regressions
    beta_lag = sm.OLS(g["ret"], sm.add_constant(g["rm_lag1"])).fit().params.iloc[1]
    beta_0 = sm.OLS(g["ret"], sm.add_constant(g["rm"])).fit().params.iloc[1]
    beta_lead = sm.OLS(g["ret"], sm.add_constant(g["rm_lead1"])).fit().params.iloc[1]

    # Market autocorrelation
    rho_m = g["rm"].autocorr(lag=1)

    beta_sw = (beta_lag + beta_0 + beta_lead) / (1 + 2 * rho_m)
    return beta_sw

beta_comparison["beta_sw"] = (
    prices_daily
    .groupby("symbol")
    .apply(estimate_sw_beta, include_groups=False)
    .values
)
```

## Implications for Portfolio Construction

The microstructure frictions documented above have direct consequences for portfolio construction, particularly for strategies that involve rebalancing across the full cross-section of listed firms.

### Equal-Weighted vs. Value-Weighted Returns

Equal-weighted portfolio returns give the same weight to each stock, including illiquid small-cap stocks that may contribute stale or noisy prices. Value-weighted returns tilt toward large, liquid stocks and are less susceptible to microstructure contamination.

```{python}
#| label: fig-ew-vs-vw
#| eval: false
#| fig-cap: "Cumulative Returns: Equal-Weighted vs. Value-Weighted Market Portfolio"

monthly_returns = (
    prices_daily
    .groupby(["symbol", "year_month"])
    .agg(
        monthly_ret=("ret", lambda x: (1 + x).prod() - 1),
        last_mktcap=("mktcap", "last")
    )
    .reset_index()
)
monthly_returns["date"] = monthly_returns["year_month"].dt.to_timestamp()

# Equal-weighted
ew_ret = monthly_returns.groupby("date")["monthly_ret"].mean().reset_index(name="ew")

# Value-weighted
def vw_return(group):
    w = group["last_mktcap"] / group["last_mktcap"].sum()
    return (w * group["monthly_ret"]).sum()

vw_ret = (
    monthly_returns.groupby("date")
    .apply(vw_return, include_groups=False)
    .reset_index(name="vw")
)

port_comp = ew_ret.merge(vw_ret, on="date")

fig, ax = plt.subplots(figsize=(8, 4))
for col, label, color in [
    ("ew", "Equal-Weighted", "#FF6B6B"),
    ("vw", "Value-Weighted", "#2C73D2")
]:
    cum_ret = (1 + port_comp[col]).cumprod()
    ax.plot(port_comp["date"], cum_ret, label=label, color=color, linewidth=1.2)

ax.set_ylabel("Cumulative Return (Growth of 1 VND)")
ax.set_xlabel("")
ax.legend(frameon=False)
ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
plt.tight_layout()
plt.show()
```

A persistent divergence between equal-weighted and value-weighted cumulative returns is a hallmark of microstructure effects: the equal-weighted portfolio overstates attainable returns because it implicitly assumes costless trading in illiquid stocks.

### Recommended Liquidity Filters

Based on the diagnostics developed in this chapter, we recommend the following pre-analysis filters:

```{python}
#| label: tbl-recommended-filters
#| include: false
#| tbl-cap: "Recommended Liquidity Filters for Asset Pricing Research"

filters = pd.DataFrame({
    "Filter": [
        "Minimum trading days per month",
        "Maximum zero-return share per month",
        "Minimum average daily value (VND)",
        "Minimum listing age",
        "Exclude UPCoM stocks"
    ],
    "Threshold": [
        "≥ 15 days",
        "≤ 50%",
        "≥ 100 million",
        "≥ 6 months",
        "Optional but recommended"
    ],
    "Rationale": [
        "Ensures sufficient price observations for return computation",
        "Removes stocks with predominantly stale prices",
        "Ensures rebalancing is approximately feasible",
        "Avoids IPO effects and thin early trading",
        "UPCoM stocks have minimal disclosure and extreme illiquidity"
    ]
})

filters.style.hide(axis="index")
```

::: callout-tip
Always report results with and without liquidity filters. If results are qualitatively different, the baseline findings may be driven by microstructure artifacts rather than genuine economic effects.
:::

### Monthly vs. Daily Frequency

For most asset pricing applications, monthly return aggregation is preferable to daily analysis in Vietnam because:

1.  Monthly returns smooth out intraday noise, bid-ask bounce, and price limit effects.
2.  Stocks that trade infrequently within a month still produce a meaningful monthly return.
3.  Factor portfolio sorts are conventionally conducted at monthly frequency.
4.  Statistical tests have better size properties when microstructure noise is reduced.

However, monthly aggregation does not eliminate all biases. Stocks with zero returns for an entire month still contribute stale observations. The Dimson and Scholes-Williams corrections should still be applied at monthly frequency for beta estimation.

## Implications for Asset Pricing Tests

### Factor Model Estimation

Standard factor model estimation assumes that returns are observed synchronously and without censoring. In Vietnam, both assumptions are violated. The practical consequences are in @tbl-assumption-violations

| Assumption | Violation in Vietnam | Consequence |
|-------------------|--------------------------------|---------------------|
| Synchronous observation | Thin trading | Biased betas, attenuated R² |
| Uncensored returns | Price limits | Truncated distributions, biased moments |
| Continuous trading | Discrete ticks | Return discreteness, bid-ask bounce |
| No transaction costs | Wide spreads | Overstated portfolio returns |

: Standard Assumptions and Their Violations {#tbl-assumption-violations}

### Adjusted Testing Procedure

We recommend the following adjustments to standard asset pricing tests when applied to Vietnamese data:

1.  **Beta estimation**: Use Dimson ($K \ge 1$) or Scholes-Williams betas, not OLS betas.

2.  **Factor construction**: When forming size and value portfolios, apply liquidity filters before sorting. Consider excluding the smallest quintile of stocks by market capitalization, which is most affected by thin trading.

3.  **Return aggregation**: Use monthly frequency. If daily analysis is necessary, include lagged market returns in the time-series regression.

4.  **Robust inference**: Cluster standard errors by stock to account for persistent microstructure-induced serial correlation. Use Newey-West HAC standard errors with sufficient lags.

5.  **Price limit adjustment**: For volatility analysis or risk measurement, consider the @chu2019forecasting approach of modeling the latent (uncensored) return distribution using truncated regression:

$$
r_{i,t}^* \sim N(\mu_i, \sigma_i^2), \quad r_{i,t}^{obs} = \max(\underline{L}, \min(\bar{L}, r_{i,t}^*))
$$ {#eq-truncated}

Estimate $\mu_i$ and $\sigma_i^2$ via maximum likelihood for the truncated normal.

```{python}
#| label: truncated-volatility
from scipy.optimize import minimize
from scipy.stats import norm

def truncated_normal_nll(params, returns, lower, upper):
    """Negative log-likelihood of truncated normal."""
    mu, log_sigma = params
    sigma = np.exp(log_sigma)

    # Interior observations
    interior = (returns > lower) & (returns < upper)
    ll_interior = norm.logpdf(returns[interior], mu, sigma)

    # Lower censored
    ll_lower = norm.logcdf(lower, mu, sigma)
    n_lower = (returns <= lower).sum()

    # Upper censored
    ll_upper = np.log(1 - norm.cdf(upper, mu, sigma) + 1e-15)
    n_upper = (returns >= upper).sum()

    nll = -(ll_interior.sum() + n_lower * ll_lower + n_upper * ll_upper)
    return nll

def estimate_true_volatility(returns, limit_band):
    """Estimate latent volatility correcting for price limit censoring."""
    result = minimize(
        truncated_normal_nll,
        x0=[returns.mean(), np.log(returns.std())],
        args=(returns.values, -limit_band, limit_band),
        method="Nelder-Mead"
    )
    mu, log_sigma = result.x
    return np.exp(log_sigma)
```

6.  **Sensitivity reporting**: Always report key results under alternative specifications: with and without liquidity filters, using OLS vs. Dimson betas, at daily vs. monthly frequency, and using observed vs. truncation-corrected volatility.

## Summary

This chapter has established that Vietnamese equity markets exhibit microstructure characteristics that materially affect observed prices, returns, and risk measures. The key findings are:

1.  **Price limits** censor daily returns, inducing positive autocorrelation, volatility spillover, and truncated distributions. The $\pm$ 7% band on HOSE is particularly restrictive for volatile stocks.

2.  **Thin trading and zero returns** afflict a substantial fraction of listed firms. Trading probabilities below 50% are common on HNX and UPCoM, generating non-synchronous trading bias that attenuates OLS beta estimates by 20-40%.

3.  **Illiquidity** varies dramatically across the cross-section, with Amihud ratios spanning several orders of magnitude. Value-weighted portfolio returns are less contaminated than equal-weighted returns.

4.  **The Dimson and Scholes-Williams beta corrections** effectively address non-synchronous trading bias and should be used as the default beta estimator for Vietnamese equities.

5.  **Liquidity filters** should be applied before any asset pricing analysis, and results should be reported with and without these filters as a robustness check.

Ignoring these frictions does not merely add noise to empirical results, it systematically biases estimates in predictable directions. The diagnostics and corrections presented in this chapter provide the foundation for credible empirical asset pricing in Vietnam.

<!-- ## Exercises

1.  **Intraday liquidity patterns**: Using intraday data, compute the average bid-ask spread and depth at 15-minute intervals throughout the trading day. Document the U-shaped intraday liquidity pattern and discuss how it relates to the theoretical predictions of @admati1988theory.

2.  **Magnet effect test**: Test the @subrahmanyam1994circuit magnet effect hypothesis. Conditional on a stock hitting a price limit by the end of the day, does price acceleration toward the limit occur in the final 30 minutes of continuous trading? Compare the speed of price approach to the limit on limit-hit days versus non-limit-hit days.

3.  **Liquidity-adjusted factor model**: Construct a tradeable liquidity factor (IML: Illiquid-Minus-Liquid) by sorting stocks into liquidity terciles using the Amihud ratio and forming a long-short portfolio. Augment the Fama-French three-factor model with this liquidity factor and test whether it improves the pricing of Vietnamese equities.

4.  **Multi-day limit hits**: Identify episodes where the same stock hits the price limit on two or more consecutive days. How much cumulative price adjustment occurs over these multi-day limit episodes? Does the total adjustment exceed what would be expected under a one-day price change distribution?

5.  **Non-synchronous trading and momentum**: The momentum effect may be partly an artifact of non-synchronous trading: past winners may simply be stocks with more recent prices. Re-examine the momentum premium after replacing OLS returns with Dimson-adjusted returns and after excluding stocks with trading probability below 50%.

6.  **Cross-exchange comparison**: Exploit the difference in price limit bands across HOSE ($pm$ 7%), HNX ($pm$ 10%), and UPCoM ($pm$ 15%) to test the causal effect of price limit tightness on volatility spillover, zero-return frequency, and return autocorrelation. Use a difference-in-differences design if any exchange has changed its limit band during the sample period. -->